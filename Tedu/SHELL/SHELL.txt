第二阶段

Day01

Shell脚本
  1.bash解释器:-快捷键、Tab键补齐
		-命令历史
		-命令别名
		-标准输入输出
		-重定向
		-管道操作
	  其他解释器则不全面
	  $0：查看当前解释器是什么！
	  命令行快捷键：Ctrl+A：将光标移至行首
			Ctrl+E：将光标移至行尾
			Ctrl+C：终止操作
			Ctrl+D：退出当前Shell
			Ctrl+M：回车
			Ctrl+U：删除光标之前本行所有内容
			Ctrl+W：删除光标之前的一个单词（已空格分离）
			Ctrl+S：挂起，冻结终端（隐藏当前输入内容）
			Ctrl+Q：解除冻结终端
			Alt+.：调用上一条命令的最后一个单词
			方向键（上下）：历史命令
			Tab键：补齐命令、选项、路径等（需要bash-completion软件包）
		
  2.history:查看历史记录
	    	-c 临时清除历史记录
   	> /root/.bash_history:永久清除历史记录	

  3.别名alias
	alias 别名=‘命令’：临时更改别名
	unalias 别名：取消临时别名
	/etc/.bashrc：永久添加别名文件	

  4.重定向标准输入/输出/错误输出
	标准输入（stdin），描述号为0
	标准输出（stdout），描述号为1
	标准错误（stderr），描述号为2
(此处省略1)>:覆盖重定向(收集正确的信息)
	2>:覆盖重定向（收集错误的信息）
	&>:覆盖重定向（正确、错误全部收集）
	>>:追加重定向(收集正确的信息)
	2>>:追加重定向（收集错误的信息）
	&>>:追加重定向（正确、错误全部收集）
	<:重定向标准输入

  5.运行脚本方式：
	1>直接给文件X权限
	2>bash 文件（在bash中启用一个子bash去运行）
		如果脚本中有exit，则退出的是子bash
	3>source（可以用.代替） 文件（不会产生子bash）
		如果脚本中有exit，则会直接退出当前bash

  6.shell变量
	自定义变量：unset（取消变量）
	环境变量：PWD,USER,HOME,SHELL...
	位置变量：$1,$2....
	预定义变量：$0(查看当前解释器)、$?（显示结果0正常，非0异常）、$#(显示输入位置变量个数)、$*（显示所有位置变量输入的值）、$$(PID进程号)
	PS1='[\u@\h \W]\$'(可以更改一级提示)
	PS2=‘>'(可以更改二级提示)  	\：换行输入

  7.三种引号对变量赋值的影响
	1）双引号的应用:使用双引号可以界定一个完整字符串。
	2）单引号的应用:界定一个完整的字符串，*并且可以实现屏蔽特殊符号的功能*。
	3）反撇号或$()的应用:使用反撇号或$()时，可以将命令执行的标准输出作为字符串存储，因此称为命令替换。
  
  8.交互式产生变量
	1)read 变量名 内容
	  read -p “提示信息” 变量
	2）stty终端显示控制
	将回显功能关闭（stty -echo），
	将回显功能恢复（stty echo），后需换行！
	
  9.全局变量定义
	普通变量值是局部变量，更换解释器则不可用
	文件/etc/profile中export后有系统定义好的环境变量
	export 变量名 ：此定义为全局变量
********************************************************************************

Day02

一、数值运算
  1.整数运算
	1>expr命令（仅取前面整数位，小数位全部省略）
	  	+、-、\*、/、%(符号两边需有空格)
	2>$[]或$(())
		此命令*无需转意，且运算符号两边无需空格，引用变量时可省略$
	3>let
		此命令可以更新变量的值
  2.小数运算
	1>bc交互式运算
		bc
	2>bc非交互式运算
		scale=N（小数位数）
		例：echo ‘scale=2；10/3’ | bc

二、条件测试
  1.基本语法格式
	test 表达式  或   [ 表达式 ]（两边至少有一个空格）
  2.字符串的测试
     	1>==:两个字符串一致为真      
    	2>!=:两个字符串不一致为真
	3>一行执行多条命令
		A && B 	当A执行成功才执行B命令
		A || B	当A执行失败才执行B命令
		A ; B		执行A后，执行B，两者无逻辑关系
		A && B || C	当A和B都执行成功，则不执行C；否则执行C
	4>-z检查变量的值是否未设置（空值）
  3.整数值比较
	-gt:大于
	-ge:大于等于
	-eq:等于
	-ne:不等于
	-lt:小于
	-le:小于等于
  4.检查文件/目录状态
	-e:文档存在为真
	-d:文档存在,且必须为目录才为真
	-f:文档存在,且必须为文件才为真
	-r:文档存在,且必须对其有读取权限才为真
	-w:文档存在,且必须对其有写入权限才为真
	-x:文档存在,且必须对其有执行权限才为真

三、if结构
  1.单分支：    if  条件测试
		 then  
		    命令序列
		 fi
  2.双分支：    if  条件测试
		 then
		    命令序列1
		 else  
		    命令序列2
		 fi
  3.多分支：    if    条件测试1 ;then  
		    命令序列1
		 elif  条件测试2 ;then  
		    命令序列2
		 else
		    命令序列n
		 fi
*******************************************************************************

Day03

一、for循环（适合有固定次数的循环）
  1.for循环格式
	for 变量 in 值列表
  	do
	  命令代码
	done
  2.seq:数字排序命令
	seq 数值列表
  3.echo 选项
	-n 	不输出末尾的换行符。
	-e 	启用反斜线转义。
	\b 	退格
	\\ 	反斜线
	\n 	新行
	\r 	回车
	\t 	水平制表符
	\v 	垂直制表符
　　　　\c　　显示后不换行 
　　　　\f　　在终端上屏幕的开始处显示 
  4.颜色输出的命令:
	echo -e "\033[32m   OK \033[0m"
		     颜色的开头/文字/改回自身颜色
		     \033[30+字体颜色，40+背景颜色
	31:红色	
	32:绿色
	33:黄色
	34:蓝色
	35:紫色
	36:青色
	37:浅灰色
	#!/bin/bash
	cecho(){
	  echo -e "\033[$1m$2\033[0m"
	}


二、while循环（适合死循环）
  1.格式
	while  条件测试 或 while：（无条件死循环）
	do
	    命令序列
	done
  2.死循环中加入sleep 0.1会节省cpu资源

三、case分支
  1.格式
   case  变量  in
    模式1)-------------------------->条件|条件。。。（可以多个条件判断）
        命令序列1 ;;
    模式2)
        命令序列2 ;;
        .. ..
    *)
        默认命令序列
    esac

四、shell函数
  1.格式1：    function  函数名 {
			命令序列
			.. ..
		    }
  2.格式2：    函数名() {
			命令序列
			.. ..
		    }
  3.wait命令的作用是等待所有后台进程都结束才结束脚本。

五、中断及退出
  1.break:结束整个循环
  2.continue:跳过本次循环
  3.exit：结束整个脚本
**********************************************************************************

Day04

一、字符串处理
  1.字符串截取
	1）${变量名:起始位置:长度}------------>起始位置从0开始计算
    	2）expr substr "$变量名" 起始位置 长度------>起始位置从1开始计算
    	3）echo $变量名 | cut -b 起始位置-结束位置------>起始位置从1开始计算
		 	选项 -b 表示按字节截取字符
			1-6：截取1-6
			8-：截取8以后所有
			-6：截取6以前所有
			9：截取第9个字符
			1，4，3：截取不连续字符
  2.字符串的替换
	1) 只替换第一个匹配结果：${变量名/old/new}
    	2)替换全部匹配结果：${变量名//old/new}

  3.字符串的掐头去尾
	1）从左向右，最短匹配删除：${变量名#*关键词}
    	2）从左向右，最长匹配删除：${变量名##*关键词}
	3）从右向左，最短匹配删除：${变量名%关键词*}
	4）从右向左，最长匹配删除：${变量名%%关键词*}
  4.字符串初值的处理
	1）只取值，${var:-word}
	若变量var已存在且非Null，则返回 $var 的值；否则返回字串“word”，原变量var的值不受影响。

二、expect预期交互
  1.发送邮件方法：
		echo 内容 | mail -s 主旨 收件人
		mail -s 主旨 收件人 < 文件
		mail -s 主旨 收件人 << EOF  .....  EOF
  2.远程免交互式脚本
	yum -y install expect
	#!/bin/bash
	expect << EOF
	spawn ssh -o StrictHostKeyChecking=no 172.25.0.10
	expect "password:" {send "redhat\n"}
	expect "#" {send "rm -rf /abc\n"}
	expect "#" {send "exit\n"}
	expect "#" {send "\n"}
	EOF
  3.数组
	赋值：  变量名=(数值1 数值2 数值3...)
		变量名[数组下标]=数值
			...
三、正则表达式（主要作用过滤文本）
  1.egrep（支持所有grep所有功能）
  常用选项：
	-i		忽略字母大小写
	-v		条件取反
	-c		统计匹配的行数
	-q 		无任何输出，一般用于检测（看$?）
	-n		显示出匹配结果所在的行号
	--color	标红显示匹配子串
  2.		基本正则列表
 	^		匹配行首
	$		匹配行尾
	[]		集合，匹配集合中的*任意单个字符*
	[^]		对集合取反
	.		匹配任意单个字符
	*		匹配前一个字符任意次数（不可单独使用）
	.*		匹配所有
	\{n,m\}	匹配前一个字符n到m次（grep用法）
	{n,m}		匹配前一个字符n到m次（egrep用法）
	\{n\}		匹配前一个字符n次（grep用法）
	{n}		匹配前一个字符n次（egrep用法）
	\{n,\}	匹配前一个字符n次以上（grep用法）
	{n,}		匹配前一个字符n次以上（egrep用法）
 	\(\)		保留（grep用法）
		扩展正则列表
	+		最少匹配一次
	？		最多匹配一次(可以是0次)
	()		组合为整体，保留
	|		或者
	\b		单词边界
********************************************************************************

Day05

处理的是行
一、sed基本用法
  1.主要用法
	-格式1：前置命令 | sed [选项] '编辑指令'
	-格式2：sed [选项] '编辑指令' 文件...
  2.常见选项
	-n：屏蔽默认输出（全部文本）
	-i：直接修改文件内容
	-r：启用扩展正则表达式，若与其他选项一起使用应作为首个选项
  3.常见指令
	p：打印行
		1p：打印第一行
		2p；4p：打印第二、第四行
		2，4p：打印2-4行
		2，+4p：打印第二行及其后的4行
		1~2p：步长（每次增长2行长度）
		$=：打印文件行数
	d：删除行（用法同上）
		$d：删除最后一行
		=：显示所有行号
		!：取反
	s：字符串替换（/可以用#、&等）
		2s/old/new/：将第二行第一个old替换为new
		s/old/new/3：将每行第三个old替换为new
		s/old/new/g：将所有的old替换为new
		s/(^.)(.*)(.$)/\3\2\1/：将第一个字符与最后一个字符调换，()表示复制到\1
  4.注意事项
	-行号可以使用单个数字表示单行
	-或者n，m表示连续多行
	-省略条件，默认逐行处理全部文本
	-匹配正则时，需要使用//(中间出现/需转译\)
  5.通过yum安装vsftpd软件包
    修改vsftpd服务配置，开启匿名上传（/etc/vsftpd/vsftpd.conf里的#anon注释打开）
    调整/var/ftp/pub目录权限，允许写入（防火墙，SElinux，chmod）
    启动vsftpd服务，并设置开机自运行

二、sed进阶用法
  1.扩展指令
 	i：在指定行之前插入
		'2a XX'：第二行之后插入XX
	a：在指定行之后插入
	c：替换指定的行
  2.导入导出操作
	r：读取文件
		3r 文件名：在第三行下插入文件内容
	w：保存到文件（覆盖式）
		2w 文件名：将第二行另存到文件中（若没有会自动创建）
  3.sed的复制剪切
 	-H：模式空间----[追加]---->保持空间（复制）
	-h：模式空间----[覆盖]---->保持空间（复制）
	-G：模式空间----[追加]---->保持空间（粘贴）
	-g：模式空间----[覆盖]---->保持空间（粘贴）
	保持空间：类似剪切版，默认有一个空行
		'1,3H;$G'：将第1-3行追加复制，追加粘贴到最后一行
************************************************************************************

Day06

处理的是列
一、awk基本用法（以字段为单为对文本执行过滤操作，无修改权限）
  1.格式1：前置命令 | awk [选项] '[条件]{指令}'
    格式2：awk [选项] '[条件]{指令}' 文件
	print 是最常用的编辑指令；若有多条编辑指令，可用分号分隔。
  2.选项
	-F：指定分割符
  3.常用内置变量
	$0 文本当前行的全部内容
	$n 文本的第n列
	NR 文件当前行的行号
	NF 文件当前行的列数（有几列）
  4.过滤的时机
	awk  [选项]  'BEGIN{指令}{指令}END{指令}'  文件	
   	BEGIN{ } 行前处理，读取文件内容前执行，指令执行1次
   	{ } 逐行处理，读取文件过程中执行，指令执行n次
  	END{ } 行后处理，读取文件结束后执行，指令执行1次
	;：多条指令
	,：空格
  5.处理条件
	1）-/正则表达式/
	   -～匹配、!～不匹配（模糊匹配）
	2）使用数值/字符串比较设置条件
	   比较符号：==(等于) !=（不等于） >（大于）
	   >=（大于等于） <（小于） <=（小于等于）
	3）逻辑测试条件
	   -&&：且
	   -||：或
	4）数学运算
	
二、awk高级应用
  1.分支结构
	单分支:{if(条件){编辑指令}}
	双分支:{if(条件){编辑指令1}else{编辑指令2}}
	多分支:{if(条件){编辑指令1}else if(条件){编辑指令2}... else{编辑指令N}}
  2.数组
  	1）数组的语法格式
	定义数组的格式：数组名[下标]=元素值
	调用数组的格式：数组名[下标]----------->${变量[下标]}
	遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}
	命令中的变量一般不用加$
	
	例子:awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}' 文件
	个人理解:ip[$1]++表示数组ip[下标]的值++,下标的值不会发生变化
	for i in ip循环:i表示数组ip的下标值,ip表示数组,ip[i]表示对应下标的值

Day07
  一、netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
	-n以数字格式显示端口号
	-t显示TCP连接的端口
	-u显示UDP连接的端口
	-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
	-p显示监听端口的服务名称是什么（也就是程序名称）
  二、查看性能数据的命令
	 uptime                      //查看CPU负载
	 ifconfig eth0               //查看网卡流量
	 free                        //查看内存信息
	 df                          //查看磁盘空间
	 wc -l /etc/passwd           //查看计算机账户数量
	 who |wc -l                  //查看登录账户数量
	 rpm -qa |wc -l              //查看已安装软件包数量	

	Nginx默认安装路径为/usr/local/nginx,该目录下会提供4个子目录，分别如下：
	/usr/local/nginx/conf 配置文件目录
	/usr/local/nginx/html 网站页面目录
	/usr/local/nginx/logs Nginx日志目录
	/usr/local/nginx/sbin 主程序目录

	$!:最后一条后台的任务的PID
















