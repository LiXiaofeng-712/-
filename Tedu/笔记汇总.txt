
Day1

• TCP/IP是最广泛支持的通信协议集合
 – 包括大量Internet应用中的标准协议
 – 支持跨网络架构、跨操作系统平台的通信

• 主机与主机之间通信的三个要素
  – IP地址(IP address)
   – 子网掩码(subnet mask)
  – IP路由(IP router)

IP地址(IP address)
     用来唯一标识一个计算机

• 地址组成(点分十进制):
    – 一共32个二进制数
    – 表示为4个十进制数,以 . 隔开

用于一般计算机网络
– A类:1 ~ 127         网+主+主+主
– B类:128 ~ 191     网+网+主+主
– C类:192 ~ 223     网+网+网+主

• 组播及科研专用
– D类:224 ~ 239     组播
– E类:240 ~ 254     科研

子网掩码：为计算机区分IP地址的网络位与主机位
                 利用二进制的1代表网络位
                 利用二进制的0代表主机位

DNS服务器：将用户在浏览器输入的域名，解析为对应的IP地址

默认windows防火墙，禁止ping进行通信

网关设备：一般为路由器

网关地址：一个网络到另一个网络的关口（作用解决不同网络通信）


Day2

  蓝色(d)：目录
  黑色(f)：文本文件
  绿色：可以运行的程序
  青色(l)：快捷方式 

Linux是一种操作系统!!  
 
  操作系统：一堆软件的集合，让计算机硬件正常运行

• UNIX诞生, 1970-1-1

• Linux之父,Linus Torwalds

 一套公开发布的完整Linux系统
	– Linux内核 + 各种应用软件
	   内核=让计算机硬件正常的启动

• 发行版的名称/版本由发行方决定
– Red Hat Enterprise Linux 5/6/7
– Suse Linux Enterprise 12
– Debian Linux 7.8
– Ubuntu Linux 14.10/15.04

格式化：赋予空间存储数据的规则（文件系统）
   常见的文件系统：
    Windows：   NTFS    FAT
    Linux：   ext4（RHEL6）  xfs (RHEL7) 
              SWAP,交换空间(虚拟内存)
                                     缓解内存不足
根目录(/)：Linux系统所有数据都存放在此目录下
           Linux系统的起点

    /dev：存放设备（键盘  鼠标  光驱   硬盘）相关的数据
	
  hd,表示IDE设备
  sd,表示SCSI设备
  vd,表示虚拟化设备
   /dev/sda3表示的含义：SCSI设备第一块第三个分区 

 命令行提示标识的含义
– [当前用户@主机名 当前所在的位置]$
– 若当前用户是root,则最后一个字符为 #

• 列出内核版本
[root@room9pc01 ~]# uname -r

• 列出CPU处理器信息
[root@room9pc01 ~]# lscpu

• 检查内存大小、空闲情况
[root@room9pc01 ~]# cat /proc/meminfo
MemTotal:       16166612 kB

查看及切换目录
• pwd — Print Working Directory
– 用途:查看当前所在的位置

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd  [目标文件夹位置]
/root：管理员的家目录
   /home:存放所有普通用户家目录的地方  

    ～：表示用户的家目录
  ~user表示用户user的家目录

• ls — List
– 格式:ls [选项]... [目录或文件名]...
• 常用命令选项
 – -l:以长格式显示
 – -A:包括名称以 . 开头的隐藏文档
 – -d:显示目录本身(而不是内容)的属性
 – -h:提供易读的容量单位(K、M等)

• mkdir 创建目录
• mkdir — Make Directory
– 格式:mkdir [-p] [/路径/]目录名...
   -R：递归

• touch命令
– 用途:新建空文件
– 格式:touch 文件名

 less分屏阅读工具
• 格式:less [选项] 文件名...
– 优势:支持前后翻页
• 基本交互操作
– 按 / 键向后查找(n、N切换)

• head、tail 命令
– 格式: head -n 数字 文件名
      tail -n 数字 文件名

mv 移动/重命名
• mv — Move
– 格式:mv  原文件...     目标路径
   重命名：路径不变的移动 

• rm — Remove
  – 格式:rm [选项]...  文件或目录...
• 常用命令选项
 – -r、-f:递归删除(含目录)、强制删除

cp 复制
• cp — Copy
– 格式:cp [选项]... 原文件...    目标路径
• 常用命令选项
– -r:递归,复制目录时必须有此选项
  复制时重名文档
  复制支持两个以上的参数，
  永远把最后一个参数作为目标，其他参数全部作为源

• grep工具
– 用途:输出包含指定字符串的行
– 格式:grep '查找字符串'      目标文件

cat查看文本文件内容
 ..(两个点) 表示父目录,上一级目录
 . 表示当前目录

使用通配符
• 针对不确定的文档名称,以特殊字符表示
 – *:任意多个任意字符
 – ?:单个字符
• 针对不确定的文档名称,以特殊字符表示
– [a-z]:多个字符或连续范围中的一个,若无则忽略
– {a,min,xy}:多组不同的字符串,全匹配


vim文本编辑器

  命令模式    插入模式    末行模式
 i，o
                命-----------------》 插入模式(按Esc回到命令模式)
                令
                模
                式 -----------------》末行模式(按Esc回到命令模式)
                       :(英文)

             末行模式   :wq  保存并退出
               :q!  强制不保存退出

Day3

• 快捷键
– Ctrl + l:清空整个屏幕
– Ctrl + a:在命令行光标移动到行首

– Ctrl + u:清空至行首
– Ctrl + w:往回删除一个单词(以空格界定)

• Linux命令
 –  用来实现某一类功能的指令或程序
  Linux大多数命令执行，都要找到相应的程序青色：快捷方式 
 –  命令的执行依赖于解释器 (默认的解释器/bin/bash)
• Linux命令的分类
– 内部命令:属于解释器的一部分
– 外部命令:解释器之外的其他程序

-mount挂载操作:让目录成为设备的访问点
注意事项：
   1.卸载：当前路径不要是挂载点内
   [root@A dvd]# umount /dvd/
   umount: /dvd：目标忙。

   2.挂载尽量自己创建目录进行挂载,会覆盖原文件内容


/root：管理员的家目录
   /home:存放所有普通用户家目录的地方  

    ～：表示用户的家目录
  ~user表示用户user的家目录

-别名的定义：简化复杂的命令

• 查看已设置的别名
– alias  [别名名称]

• 定义新的别名
– alias  别名名称= '实际执行的命令行'

• 取消已设置的别名
– unalias  [别名名称]


Day4

LANG=en        #临时改变系统语言为英文

配置网络参数的顺序:
    1.配置主机名  
    2.配置IP地址 子网掩码 网关地址  
  3.DNS服务器地址

为真机设置永久的别名
[root@room9pc01 ~]# ls /root/.bashrc  #系统级配置文件

传统的安装软件包的命令
– rpm -q 软件名...
– rpm -ivh 软件名-版本信息.rpm...
– rpm -e 软件名...

构建Yum仓库   自动解决依赖关系，安装软件
 服务：为客户端自动解决依赖关系，安装软件
   虚拟机classroom
   服务端：  1.众多的软件包 
                  2.仓库的数据文件（仓库清单文件）
                  3.搭建服务共享光盘所有内容
   虚拟机server
   客户端：书写一个配置文件，指定服务端位置
   路径及名称：/etc/yum.repos.d/*.repo
   错误的文件会影响正确文件
  yum  repolist      #显示所有仓库信息
  yum  install 软件名
  yum clean  all  #清空Yum所有缓存
  yum remove  软件名    #卸载

  客户机.repo配置文件内容
  [rhel7]         #仓库的标识，随意写不要出现空格
  name=rhel7.0    #仓库的描述信息，随意写
  baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/    #指定服务端位置
  enabled=1       #是否启用本文件
  gpgcheck=0      #是否检测软件包红帽签名

• 快速建立repo配置文件
– yum-config-manager --add-repo 软件仓库地址
  echo 'gpgcheck=0' >> /etc/yum.repos.d/*.repo

配置网络参数
一 配置永久主机名
[root@server0 ~]# vim /etc/hostname

二  配置永久的  IP地址    子网掩码      网关地址

 网卡配置文件:/etc/sysconfig/network-scripts/ifcfg-eth0

方法一: 命令行指令,交互式配置(伪图形)
  nmtui 修改IP地址为172.25.0.120/24 网关地址 172.25.0.254

      1. Edit a connection（回车）#编辑连接
      2. System eth0（回车）          #选择网卡
      3. IPv4 CONFIGURATION   <Manual>  #手工配置IP
            4.   选择  <Show> ------>书写IP地址
      Addresses 172.25.0.120/24 <Remove>  
                 
      Gateway 172.25.0.254      
    
      5. Require IPv4 addressing for this connection
                 #利用IPv4进行激活 

      6. Automatically connect
                 #每次开机自动激活配置  
  激活配置
[root@A ~]# nmcli  connection  up  'System eth0'

方法二: 命令配置IP地址,非交互式 

 1.查看识别的网卡名称      
[root@server0 ~]# nmcli connection show
名称        
System eth0   

2.配置IP地址  子网掩码   网关地址    
# nmcli  connection  modify  'System eth0' 
  ipv4.method  manual           
  ipv4.addresses  '172.25.0.110/24  172.25.0.254'   
  connection.autoconnect  yes

  nmcli  connection   修改    
  ipv4.方法      手工配置
  ipv4.地址      'IP地址/子网掩码     网关地址'  
    每次开机自动启用配置

3.激活配置
# nmcli  connection  up  'System eth0'

查看网关地址命令:
[root@server0 ~]# route -n

     Gateway        
       172.25.0.254     

三 指定本机DNS服务器地址
      DNS服务器:将域名解析为IP地址
      /etc/resolv.conf  #DNS服务器配置文件 



Day5

管理用户和组
 用户帐号：1.可以登陆操作系统    
                     2.可以依据不同的身份，设置不同的权限

     组：方便管理用户

     唯一标识： UID   GID

     管理员root的UID为0
    
     组帐号分类：一个用户至少属于一个组
           基本组：由系统创建同名的组，由系统加入进去
           附加组（从属组）：由管理员创建，由管理员加入进去

添加用户

• 使用 useradd 命令
– useradd [选项]... 用户名
• 常用命令选项
– -u 用户id、-d 家目录路径、-G 附加组、-s 登录Shell  /sbin/nologin :禁止用户登陆操作系统

usermod  #修改已存在用户的属性

用户基本信息存放在 /etc/passwd 文件
[root@server0 ~]# head -1 /etc/passwd
  root:x:0:0:root:/root:/bin/bash

用户名:密码占位符:UID:基本组GID:用户描述信息:家目录:解释器程序

重定向操作:将前面命令的输出结果，写入到文本文件中
  >：覆盖重定向
  >>：追加重定向
|  管道操作：
        将前面命令的输出结果，交由后面命令再处理一遍，作为后面命令的参数

设置登录密码
用户密码信息存放在 /etc/shadow 文件

• 使用 passwd 命令
– passwd [用户名]（交互式）--根据电脑提示输入密码，有交互的动作
– echo '密码' | passwd --stdin 用户名(非交互式)--直接更改密码，无交互的动作

[root@A ~]# su - nsd01   #临时切换用户身份

• 使用 usermod 命令
– usermod [选项]... 用户名
• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录Shell
– -G 附加组

• 使用 userdel  命令
– userdel   [-r]   用户名
             -r: 连同家目录一并删除
– userdel    用户名      #仅删除用户信息

组基本信息存放在 /etc/group 文件
[root@A ~]# grep stugrp /etc/group
  stugrp:x:1507:
    组名:组的密码占位符:组的GID:本组成员列表

• 使用 groupadd 命令（新增组）
– groupadd [-g 组ID] 组名
  [-g 组ID]一般不用

• 使用 gpasswd 命令
– gpasswd -a  用户名   组名（将用户加入组）
– gpasswd -d  用户名   组名（将用户移除组）

删除组
• 使用 groupdel 命令
– groupdel   组名

压缩与解压缩源文件均不会消失
    归档及压缩： 1.减小占用的空间  2.将零散的文件归成一个压缩包

Linux独有压缩格式及命令工具:
       gzip---> .gz 
       bzip2---> .bz2 
       xz---> .xz 
归档及压缩的格式：
打包：
 tar  选项    /路径/归档压缩之后的名字      被归档压缩源文档......

解包：         
 tar  选项    /路径/压缩包      -C     释放路径

– -c:创建归档
– -x:释放归档
– -f:指定归档文件名称
– -z、-j、-J:调用 .gz、.bz2、.xz 格式的工具进行处理
– -t:查看tar包中文件清单
– -C:指定释放的位置

NTP网络时间协议
• Network Time Protocol
– NTP服务器为客户机提供标准时间
– NTP客户机需要与NTP服务器保持沟通

  NTP服务器:虚拟机classroom  

  NTP客户机:虚拟机server
    1.安装chrony软件,寻找NTP服务端进行沟通
  [root@A ~]# yum -y install chrony
  [root@A ~]# rpm -q chrony

    2.修改配置文件/etc/chrony.conf
  [root@A ~]# vim  /etc/chrony.conf  
     以#开头的行代表注释
     #server 0.rhel.pool.ntp.org iburst
     #server 1.rhel.pool.ntp.org iburst
     #server 2.rhel.pool.ntp.org iburst
     server  classroom.example.com  iburst
    
     3.重起程序（重起服务）
      daemon:超级守护程序
   [root@A ~]# systemctl restart chronyd  #重起服务
   [root@A ~]# systemctl enable chronyd   #设置开机自起

     4.验证
  [root@A ~]# date  #查看时间
    2018年 10月 09日 星期二 17:44:38 CST
  [root@A ~]# date -s  "年-月-日   时:分:秒"    #修改时间
  [root@A ~]# date -s "2008-9-10  10:58:09"
  [root@A ~]# date
  [root@A ~]# systemctl restart chronyd
  [root@A ~]# date
  [root@A ~]# date
  [root@A ~]# date

周期性计划任务

cron任务概述
• 用途:按照设置的时间间隔为用户反复执行某一项固
定的系统任务
• 软件包:cronie、crontabs
• 系统服务:crond
• 日志文件:/var/log/crond

如何编写crontab任务记录
• 配置格式可参考 /etc/crontab 文件
–   分   时   日   月   周     任务命令行(绝对路径)
     30   8    *    *    *      执行的命令
     1  23   *    *    1,3,5      执行的命令
     1  23   *    *    1-5         执行的命令
     1  23   1    *    1         满足其中一个即可

	*:匹配范围内任意时间
	,:分隔多个不连续的时间点
	-:指定连续时间范围
	/n:指定时间频率,每n ...

• 使用 crontab 命令
– 编辑:crontab -e  [-u 用户名]
– 查看:crontab -l  [-u 用户名]
– 清除:crontab -r  [-u 用户名]

* * * * *   date  >>  /opt/time.txt


Day6

权限和归属

基本权限的类别
• 访问方式(权限)
– 读取:允许查看内容-read  r
– 写入:允许修改内容-write   w
– 可执行:允许运行和切换-execute  x

  对于文本文件：
      读取 r ： cat  less  head tail 
      写入 w ： vim 可以保存退出   重定向  >   >>
      可执行 x : 学习Shell脚本

常见提示：权限不足
 Permission denied

目录的 r 权限:能够 ls 浏览此目录内容

目录的 w 权限:能够执行 rm/mv/cp/mkdir/touch/等更改目录内容的操作

目录的 x 权限:能够 cd 切换到此目录


– 所有者:拥有此文件/目录的用户-user  u
– 所属组:拥有此文件/目录的组-group    g
– 其他用户:除所有者、所属组以外的用户-other o


查看权限
• 使用 ls -l 命令
– ls -ld 文件或目录...

    以 - 开头:文本文件
    以 d 开头:目录
    以 l 开头:快捷方式

设置基本权限
• 使用 chmod 命令
– chmod [-R] 归属关系+-=权限类别 文档...  

        [-R]：递归设置权限

Linux判断用户具备的权限           匹配及停止
    1.看用户的所处角色                所有者>所属组>其他人
    2.查看相应权限位置的权限

设置文档归属
• 使用 chown 命令
– chown [-R] 属主   文档...
– chown [-R] :属组   文档...
– chown [-R] 属主:属组   文档...

附加权限（特殊权限）

Set GID
• 附加在属组的 x 位上
– 属组的权限标识会变为 s
– 适用于目录,Set GID可以使目录下新增的文档自动设置与父目录相同的属组
– 让目录下新增的子文档，自动继承父目录的所属组

Set UID
• 附加在属主的 x 位上
– 属主的权限标识会变为 s
– 适用于可执行文件,Set UID可以让使用者,具有可执行文件的,属主的身份及部分权限
– 传递所有者身份

Sticky Bit(粘滞位)
• 附加在其他人的 x 位上              
– 其他人的权限标识会变为 t
– 适用于开放 w 权限的目录,可以阻止用户滥用 w 写入
权限(禁止操作别人的文档)

acl访问控制列表（ACL策略  ACL权限）

• acl访问策略
– 能够对个别用户、个别组设置独立的权限
– 大多数挂载的EXT3/4、XFS文件系统默认已支持

ACL策略设置黑名单
[root@server0 /]# setfacl -m u:zhangsan:---  /nsd11
[root@server0 /]# getfacl  /nsd11

实现一个用户lisi可以读取文件redhat.txt内容，请问入如何设置权限，你有几种方法？

       第一：利用其他人进行配置
          chmod  o+r   redhat.txt

       第二：利用所属组进行配置
                 将lisi加入到redhat.txt所属组中
          chmod  g+r redhat.txt

       第三：利用所有者进行配置
          chown  lisi  redhat.txt
          chmod  u+r   redhat.txt

       第四：利用ACL进行配置
          setfacl -m u:lisi:r  redhat.txt

• 使用 getfacl、setfacl 命令
– getfacl 文档...
– setfacl [-R] -m u:用户名:权限类别   文档...
– setfacl [-R] -m g:组名:权限类别   文档...
– setfacl [-R] -x u:用户名:    文档...    #删除指定的ACL策略
– setfacl [-R] -b 文档...                      #删除所有的ACL策略

使用LDAP认证
     作用：实现网络用户认证，用户集中管理

家目录漫游

什么是NFS共享
• Network File System,网络文件系统
– 由NFS服务器将指定的文件夹共享给客户机
– 客户机将此共享目录 mount 到本地目录,访问此共享
资源就像访问本地目录一样方便
– 类似于 EXT4、XFS等类型,只不过资源在网上

查看共享文件命令：showmount -e 服务端IP地址

扩展文件系统	ext4
高级文件系统	xfs
交换文件系统   swap


Day7

查找文本内容
• 根据字符串模式提取文本行
– grep [选项] '匹配模式'   文本文件...

• 常用命令选项
– -v,取反
– -i,忽略大小写

– ^word 以字符串word开头
– word$ 以字符串word结尾
–  ^$       匹配空行
–  ^#        匹配以#号开头的行

查找文件
• 根据预设的条件递归查找对应的文件
– find [目录] [条件1] [-a|-o(或者)] [条件2] ...

– 常用条件表示:（+表示大于，-表示小于）
  -type 类型(f文件、d目录、l快捷方式)
  -name "文档名称"
  -size +|-文件大小(k、M、G)  1默认不识别
  -user 用户名
  -iname  根据名称查找,忽略大小写
  -group  根据所属组进行查找
  -maxdepth  限制目录查找的深度(最大层数)
  -mtime  根据文件修改时间(所有的时间,都是过去时间)

• 使用find命令的 -exec 操作
– find .. .. -exec 处理命令 {} \;
– 优势:以 {} 代替每一个结果,逐个处理,遇 \; 结束


Day1

 扇区  512 字节
一块硬盘的“艺术”之旅
• 识别硬盘 => 分区规划 => 格式化 => 挂载使用
   毛坯楼层 => 打隔断 => 装修 => 入驻

 识别硬盘,由系统自动完成
 格式化:赋予空间存储数据的规则(文件系统)
	列出所有识别的硬盘设备:lsblk

分区的规划  
    MBR分区模式
          三种分区类型: 主分区   扩展分区   逻辑分区
          3个主分区, 一个扩展分区, N个逻辑分区
          可以存储数据的分区: 主分区  逻辑分区
          最多划分4主分区
          此模式支持最大空间  2.2T

开机自动挂载
• 配置文件 /etc/fstab 的记录格式
 – 设备路径      挂载点       类型      参数         备份标记   检测顺序

总结:
1.识别硬盘   lsblk
2.进行分区   fdisk
3.刷新所有分区   partprobe
4.进行格式化    mkfs.ext4  mkfs.xfs  blkid(查看文件系统)
5.挂载使用  mount  ---> df -h (查看是否挂载成功)
6.书写配置文件/etc/fstab   ---> mount -a(测试)

上课笔记供参考：

1.识别硬盘
2.分区
	分区：fdisk 路径
	查看：lsblk(查看分区信息)
	刷新所有分区表：partprobe
3.格式化
	格式化：mkfs.类型（ext4,xfs） 路径
	查看：blkid 路径（查看格式化文件类型）
4.挂载
	挂载：mount
	查看：df -h（查看挂载信息）
5.开机自动挂载
	配置文件/etc/fstab
	格式：路径  挂载路径  类型  参数  备份标记   检测顺序
	自动检测挂载：mount -a 


6.综合分区
	MBR分区：3个主分区，一个扩展分区，N个逻辑分区fdisk /dev/vdc

LVM逻辑卷   
   作用: 
      1.可以整合分散的空间(分区或整个硬盘)
      2.空间可以扩大
     将众多的物理卷(PV)组建成卷组(VG),再从卷组中划分逻辑卷(LV)
      砖------>大房子------>打隔断------->装修------->入住

successfully 成功

逻辑卷的扩展：支持线上工作，即不影响数据等

	逻辑卷的空间来源与卷组，只能找创建它的卷组
1.卷组空间足够
	查看卷组空间：vgs
	1>扩展逻辑卷空间
		lvextend -L 需扩展的大小/+多大  路径
	2>扩展系统文件空间
		ext4文件系统刷新命令：resize2fs 路径
		xfs文件系统刷新命令：xfs_growfs 路径
2.卷组空间不足
	1>扩展卷组fdisk /dev/vdc
		vgextend 卷组名 硬盘路径
	2>扩展逻辑卷空间
		lvextend -L 需扩展的大小/+多大  路径
	3>扩展系统文件空间
		ext4文件系统刷新命令：resize2fs 路径
		xfs文件系统刷新命令：xfs_growfs 路径


了解：逻辑卷也可减小，有数据丢失的风险，不可控
	ext4文件系统支持减小
	xfs文件系统不支持减小

硬盘划分最小空间单位：默认512字节
卷组划分最小空间单位：PE 默认4M（4的倍数）
	新增的卷组修改PE大小：vgcreate -s PE大小 -n 卷组名 硬盘路径
	已存在的卷组修改PE大小：vgchange -s PE大小 卷组名
	创建逻辑卷的时候指定PE个数：lvcreate -l PE个数 -n 逻辑卷名 卷组名
	
Day02

Shell脚本

   什么是脚本：可以执行的一个文本文件，可以实现某种功能

规范Shell脚本的一般组成      
• #! 环境声明，下面的代码用哪一个程序来解释
• # 注释文本
• 可执行代码

重定向输出

    > :只收集前面命令的正确信息
    2>:只收集前面命令的错误信息
    &>：收集前面命令的错误信息与正确信息
    >&2:将输出信息显示为错误信息

	黑洞设备：/dev/null

为了增加脚本灵活，适应多变的环境，所以使用变量
  变量：容器    以不变的名称，存放可以变化的值 

    变量名=储存的值      
   使用变量储存的值 $变量名

什么是变量
• 以不变的名称存放的可能会变化的值
– 变量名=变量值
– 方便以固定名称重复使用某个值
– 提高对任务需求、运行环境变化的适应能力


– 变量名只能由字母/数字/下划线组成,区分大小写
– 变量名不能以数字开头,不要使用关键字和特殊字符

• 基本格式
– 引用变量值:$变量名
– 查看变量值:echo $变量名、echo ${变量名}

 降低脚本的使用难度，可以产生交互
  read  
  -p '屏幕输出信息'
     作用：1. 可以产生交互   2.记录用户在键盘上的输入
              3.将用户在键盘上的输入内容赋值给变量储存
	  单引 '  ' ：取消所有特殊字符含义
	$( )或 反撇号`  `:将命令的输出，作为参数参与下一个命令执行
       %F    完整日期格式，等价于  年-月-日



环境变量  变量名一般都大写,用来设置用户/系统环境
              系统定义赋值完成，用户直接使用即可

    USER=永远储存当前登陆的用户名

位置变量  bash内置,存储执行脚本时提供的命令行参数(非交互)
              系统定义赋值完成，用户直接使用即可

预定义变量   bash内置,可直接调用的特殊值,不能直接修改
                  系统定义赋值完成，用户直接使用即可

	$#  已加载的位置变量的个数
	$*  所有位置变量的值
	$?  程序退出后的状态值,0表示正常,其他值异常

条件测试  – [  测试表达式  ]   条件表达式每一部分都要有空格

• 检查文件状态
	-e:文档存在为真
	-d:文档存在,且必须为目录才为真
	-f:文档存在,且必须为文件才为真
	-r:文档存在,且必须对其有读取权限才为真
	-w:文档存在,且必须对其有写入权限才为真
	-x:文档存在,且必须对其有执行权限才为真

• 比较整数大小    
   -gt:大于
   -ge:大于等于
   -eq:等于
   -ne:不等于
   -lt:小于
   -le:小于等于

• 字符串比对
     ==:两个字符串一致为真      
     !=:两个字符串不一致为真


if双分支处理

	if [条件测试];then
	   命令序列xx
	else
	   命令序列yy
	fi

if多分支处理

	if [条件测试1];then
	  命令序列xx
          命令序列bb
	elif [条件测试2];then
	  命令序列yy
     elif [条件测试3];then
	  命令序列aa
          ......
	else
	  命令序列zz
	fi

for循环处理
• 遍历/列表式循环
– 根据变量的不同取值,重复执行xx处理

	for 变量名   in  值列表
	do
	    重复执行的代码
	done

造数机制: {起始值..结束值}
             {1..10}:  1到10 所有的数字         
             {20..38}:  20到38所有的数字

判断输入参数是否为空：$#,(-z$n)

切换为disabled需重起
	查看当前模式：getenforce
	临时切换：setenforce 0（permissive模式）/1（enforcing模式）
	永久切换：/etc/selinux/config

系统安全保护

SELinux概述
• Security-Enhanced Linux
– 美国NSA国家安全局主导开发,一套增强Linux系统安
全的强制访问控制体系

– 集成到Linux内核(2.6及以上)中运行
– RHEL7基于SELinux体系针对用户、进程、目录和文件
提供了预设的保护策略,以及管理工具


• SELinux的运行模式
– enforcing(强制)、permissive(宽松)
– disabled(彻底禁用)

 任何模式变成disabled都要经历重起系统

• 切换运行模式
– 临时切换:setenforce 1|0
– 固定配置:/etc/selinux/config 文件

配置用户环境

• 影响指定用户的 bash 解释环境
– ~/.bashrc,每次开启 bash 终端时生效

• 影响所有用户的 bash 解释环境
– /etc/bashrc,每次开启 bash 终端时生效

搭建web服务（访问网页）
	1.安装httpd软件包
	  常用软件包：httpd,Nginx(tengine升级版),Tomcat
	  apache(开发软件的一个组织)
	2.重起httpd服务
	  systemctl restart httpd
	  systemctl enable httpd(设为开机启动)
	3.书写一个页面文件
	  默认存放网页文件的路径：/var/www/html
	  默认网页文件的名字：index.html
	4.本机测试
		html语言：
		<h1>字体大小
		<font color=颜色>字体颜色
		<marquee>字体已滚动形式出现

搭建FTP服务（传输文件）
	1.安装vsftpd服务软件
	2.重起vsftpd服务
	3.本机测试
  	默认FTP共享数据的路径：/var/ftp


防火墙的应用
	作用：隔离  过滤
  硬件防火墙：一般保护的是一个网络所有主机
  软件防火墙：一般保护本机

RHEL7的防火墙体系
  系统服务：firewalld
  管理工具：firewall-cmd(命令)  firewall-config(图形)
  
  默认规则：允许出站，过滤入站

预设安全区域
  public:仅允许访问本机的sshd,dhcp,ping少数几个服务
  trusted:允许任何访问
  block:拒绝任何来访请求（明确拒绝）
  drop:丢弃任何来访的数据包（非明确拒绝，直接丢弃,节省资源）

数据包的内容：源IP地址，目标IP地址，数据,目标端口号
防火墙判断的机制：
  1.查看客户端数据包中源IP地址，查看所有区域哪个有该源IP地址的策略，则进入此区域
  2.进入默认区域（public）

  查看默认模式：firewall-cmd --get-default-zone
  修改默认模式：firewall-cmd --set-default-zone=(public,trusted,block,drop)
  查看各区域协议：firewall-cmd --zone=public --list-all
  区域添加协议:firewall-cmd --zone=public --add-service=需添加的协议
  为防火墙添加永久协议:firewall-cmd --permanent --zone=public --add-service=需添加的协议
  删除添加的永久协议：firewall-cmd --permanent --zone=public --remove-service=需删除的协议
  添加源ip到区域：firewall-cmd --zone=public --add-source=ip地址
  刷新防火墙信息：firewall-cmd --reload

在区域中添加允许的协议
  扩展  互联网常见的协议
	http:超文本传输协议			默认端口：80
	https:安全超文本传输协议     		  443
	ftp：文件传输协议			 	  21
 	dns：域名解析协议				  53
	telnet：远程管理协议				  23
	tftp：简单文件传输协议			  69
	smtp：邮件协议（用户发邮件）			  25	
	pop3：邮件协议（用户收邮件）			  110
	snmp：网络管理协议 				  161	

实现本机的端口映射(端口转发)
• 本地应用的端口重定向(端口1 --> 端口2)
  – 从客户机访问 端口1 的请求,自动映射到本机 端口2
# firewall-cmd --permanent  --zone=public --add-service=http

# firewall-cmd --reload 

# firewall-cmd --permanent --zone=public 
--add-forward-port=port=5423:proto=tcp:toport=80

# firewall-cmd --reload 

# firewall-cmd --zone=public --list-all


Day04

Samba服务基础:实现跨平台的共享(Windows与Linux)
   
• Samba 软件项目
  – 用途:为客户机提供共享使用的文件夹
  – 协议:SMB(TCP 139)、CIFS(TCP 445)
  • 所需软件包:samba
  • 系统服务:smb

• Samba用户 —— 专用来访问共享文件夹的用户
– 采用独立设置的密码  
– 但需要提前建立同名的系统用户  
• 使用 pdbedit 管理工具
– 添加用户:pdbedit -a 用户名
– 查询用户:pdbedit -L [用户名]
– 删除用户:pdbedit -x 用户名

• 修改 /etc/samba/smb.conf
[自定共享名]
path = 文件夹绝对路径
; public = no|yes      //默认no
; browseable = yes|no //默认yes
; read only = yes|no   //默认yes
; write list = 用户1 .. .. //默认无
; valid users = 用户1 .. .. //默认任何用户
; hosts allow = 客户机地址 .. ..
; hosts deny = 客户机地址 .. ..

一  环境配置               
虚拟机Server0:
# firewall-cmd --set-default-zone=trusted
 
虚拟机Desktop0:
# firewall-cmd --set-default-zone=trusted 

二 搭建基本的Samba服务
虚拟机Server0:
1.安装samba软件包:samba
2.创建Samba的共享帐号
  pdbedit -L          #查看所有Samba的共享帐号
  pdbedit -a 用户名     #将用户添加为共享帐号
  pdbedit -x 用户名     #删除共享帐号
3.修改配置文件/etc/samba/smb.conf
  1)创建目录
  [root@server0 ~]# mkdir  /common
[root@server0 ~]# echo  123  >  /common/1.txt
[root@server0 ~]# ls  /common/

  2)此服务器必须是 STAFF 工作组的一个成员
     发布目录 /common,共享名为 common
[root@server0 ~]# vim  /etc/samba/smb.conf
  末行模式  输入 :set  nu  开启行号

    89   workgroup = STAFF

  命令模式  按 G(大写) 到全文最后
	321  [common]           #共享名
	322  path = /common     #共享实际路径
4.重起smb服务
[root@server0 ~]# systemctl restart smb
[root@server0 ~]# systemctl enable smb

客户端虚拟机desktop0: 

1.安装客户端软件包samba-client
[root@desktop0 ~]# yum -y install samba-client

• 列出共享资源
– smbclient -L 服务器地址
• 连接到共享文件夹
– smbclient -U 用户名 //服务器地址/共享名

虚拟机desktop0:
# smbclient  -L   172.25.0.11
Enter root's password:       #直接敲回车
Anonymous login successful
Domain=[STAFF] OS=[Unix] Server=[Samba 4.1.1]

	Sharename       Type      Comment
	---------                      ----                 -------
	common          Disk     

# smbclient -U harry  //172.25.0.11/common
Enter harry's password:      #输入harry的密码
Domain=[STAFF] OS=[Unix] Server=[Samba 4.1.1]
smb: \> 

客户端:更加科学方便的访问方式  
  mount挂载:本地目录作为Samba服务的访问点
1.安装cifs-utils软件包,支持cifs文件系统的软件包
2.挂载访问
3.开机自动挂载/etc/fstab
  _netdev:网络设备
                   指明本设备需要具备所有网络参数后,在进行挂载
  格式：//172.25.0.11/common  /mnt/smb   cifs defaults,user=harry,pass=123,_netdev   0  0

总结:
搭建Samba服务:
  1.修改防火墙策略
  2.安装软件包samba
  3.创建Samba共享帐号   pdbedit
  4.创建共享目录,修改配置文件发布共享 
  5.重起smb服务
  6.修改SELinux功能的开关

客户端:
   1.修改防火墙策略
   2.安装软件包cifs-utils
   3.利用mount挂载的方式
   4.实现开机自动挂载

客户端:
   1.修改防火墙策略
   2.安装软件包samba-clinet
   3.访问

总结:读写Samba共享
	搭建Samba服务:
	  1.修改防火墙策略
	  2.安装软件包samba
	  3.创建Samba共享帐号   pdbedit
	  4.创建共享目录,修改配置文件发布共享,添加可写用户
	  5.重起smb服务
	  6.修改SELinux功能的开关(rw读写功能)
	  7.赋予本地目录(可写用户身份)读写执行的权限

	客户端:
	   1.修改防火墙策略
	   2.安装软件包cifs-utils
	   3.利用mount挂载的方式
	   4.实现开机自动挂载（挂载路径上为共享名，不是共享目录）

客户端访问服务端:
  1.防火墙策略
  2.服务端的服务本身访问控制
  3.安全增强版 SELinux
  4.本地目录的权限

虚拟机Server0:只读NFS共享的实现
1.安装软件包
2.创建共享目录发布共享
• 修改 /etc/exports
– 文件夹路径    客户机地址(权限) 客户机地址(权限) .. ..
3.重起nfs-server服务

客户端:虚拟机Desktop0
  • 查看NFS资源
  – showmount -e [服务器地址]
  • 挂载NFS共享目录
  – mount 服务器地址:目录路径   本地挂载点

multiuser机制
 作用:客户端挂载时采用权限较小的用户挂载,当客户端有一个普通用户需要较大的权限,可以临时切换Samba共享帐号的身份

• SMB客户端的 multiuser 挂载技术
– 管理员只需要作一次挂载
– 客户端在访问挂载点时,若需要不同权限,可以临时
切换为新的共享用户(无需重新挂载)

• mount.cifs 的挂载参数
– multiuser,提供对客户端多个用户身份的区分支持
– sec=ntlmssp,提供NT局域网管理安全支持

搭建读写的Samba共享
	-发布共享/public,共享名为haxi
	-共享用户chihiro对共享具备读写权限

虚拟机server:发布共享/public,共享名为haxi

虚拟机desktop:将共享,开机自动挂载到/mnt/samba


Day05

iSCSI网络磁盘(共享分区或整个磁盘)  默认端口:3260
• Internet SCSI,网际SCSI接口
– 一种基于C/S架构的虚拟磁盘技术
– 服务器提供磁盘空间,客户机连接并当成本地磁盘使用

• backstore,后端存储(大冰箱)  /dev/vdb1
– 对应到服务端提供实际存储空间的设备,需要起一个管理名称

• target,磁盘组(木质箱子)
– 是客户端的访问目标,作为一个框架,由多个lun组成

• lun,逻辑单元(将大冰箱放入木质箱子)
– 每一个lun需要关联到某一个后端存储设备,在客户端
会视为一块虚拟硬盘

使用targetcli建立配置
• ISCSI Qualified Name 名称规范
– iqn.yyyy-mm.倒序域名:自定义标识
–  用来识别 target 磁盘组, 也用来识别客户机身份

总结:
服务端:
  1.防火墙默认区域设置为trusted
  2.安装软件包targetcli
      A:建立后端存储
      B:建立target磁盘组
      C:关联lun
      D:设置acl访问控制,客户端声称的名字
      E:开启本机的IP地址及端口
  3.重起target服务

客户端:
  1.防火墙默认区域设置为trusted
  2.安装软件包iscsi-initiator-utils
  3.修改文件/etc/iscsi/initiatorname.iscsi客户端声称的名字
  4.重起iscsid服务刷新客户端iqn标识
  5.书写客户端发现命令,参照man iscsiadm
  6.重起iscsi服务,加载共享存储  最终利用lsblk查看新磁盘

数据库管理

数据库:存放数据的仓库

– 社区开源版 MariaDB  默认端口:3306     

• RHEL7 中的 MariaDB 相关包
– mariadb-server:提供服务端有关的系统程序
– mariadb:提供客户端及管理工具

 mariadb数据库中,会有很多的库,在每一个库中会有很多的表格


 禁止监听,只服务于本机,MariaDB主配文件为/etc/my.cnf
 导入/恢复到数据库
– mysql [-u用户名] [-p[密码]] 数据库名 < 备份文件.sql


数据库：存放数据的仓库

社区开源版：MariaDB		默认端口：3306

一、安装数据库mariadb-server

二、数据库基本操作
	MySQL进入数据库：show databases;(查看库)
			   create database 库名（创建新库）
			   drop database 库名 （删除库）
			   use 库名（切换库）
			   show tables(查看库中表格)
	
三、为数据库管理员设置密码
	数据库管理员root：MariaDB数据库信息存放在MySQL库-->user表中
	系统管理员root：账户信息放在/etc/passwd
	新用户设置密码：mysqladmin -u root password '123'
	修改密码：mysqladmin -u root -p（此处没有空格）旧密码 password '新密码'
	进入数据库：mysql -u root -p123（非交互）
		    mysql -u root -p（交互）
	导入/恢复库：mysql -u root -p456 库名 < users.sql

	表字段（列）	表记录（行）	
	desc（查表结构）
	insert（增）	delete（删）	update（改）	select（查）
	select 表字段 from 表名;	
	select 表字段 from 库名.表名;

数据库的授权：与本地用户没关系，不需创建本地用户
	grant 权限（all，增删改查） on 数据库名.表名 to 用户名@客户机地址（localhost本地） identified by ‘密码’


Day06

HTTP服务基础  

搭建基本Web服务
虚拟机server0
1.安装软件包httpd
2.书写一个页面文件
 echo '<h1>NSD1809 Web' > /var/www/html/index.html
3.重起服务
# systemctl restart httpd
# systemctl enable httpd

4.虚拟机desktop0 访问测试: firefox  172.25.0.11

Web通信基本概念
• 基于 B/S (Browser/Server)架构的网页服务
– 服务端提供网页
– 浏览器下载并显示网页

• Hyper Text Markup Language(HTML),超文本标记语言
• Hyper Text Transfer Protocol(HTTP),超文本传输协议

• 软件包:httpd
• 系统服务:httpd
• 提供的默认配置
– Listen:监听地址:端口(80)
– ServerName:本站点注册的DNS名称(空缺)
– DocumentRoot:网页根目录(/var/www/html)	#指定网页文件存放路径
– DirectoryIndex:起始页/首页文件名(index.html)  

主配置文件:/etc/httpd/conf/httpd.conf
当 客户端  172.25.0.11:80  服务端 httpd--->DocmentRoot

DocumentRoot "/var/www/myweb" 

网络路径:firefox  server0.example.com
实际路径:/var/www/myweb

虚拟Web主机
– 由同一台服务器提供多个不同的Web站点
一旦使用虚拟web主机功能,所有的网站都必须用虚拟web主机实现

• 区分方式
– 基于域名的虚拟主机
– 基于端口的虚拟主机
– 基于IP地址的虚拟主机

– 基于域名的虚拟主机

 <VirtualHost  IP地址:端口>
   ServerName  此站点的DNS名称
   DocumentRoot  此站点的网页根目录
 </VirtualHost>
 <VirtualHost  *:80>         #所有IP地址开放80端口
   ServerName    www0.example.com  #指定网站名称
   DocumentRoot  /var/www/qq       #指定网页文件存放路径
 </VirtualHost>

• 配置文件路径
– /etc/httpd/conf/httpd.conf  主配置文件
– /etc/httpd/conf.d/*.conf    调用配置文件

网页内容访问
客户机地址限制

• 使用 <Directory> 配置区段
– 每个文件夹自动继承其父目录的访问权限
– 除非针对子目录有明确设置
<Directory  /var/www/html>
	Require all denied|granted #拒绝所有 | 允许所有
	Require ip 172.25.0.10   #仅允许172.25.0.10进行访问
   </Directory>


案例3:配置网页内容访问
在 Web 网站 http://server0.example.com 的
DocumentRoot 目录下创建一个名为 private 的子目录,要求如下:

1.查看 server0.example.com 的DocumentRoot 目录
2.创建目录,写入页面文件
3.在虚拟机server与虚拟机desktop上 访问测试
4.从 server0 上,任何人都可以浏览 private的内容,
但是从其他系统不能访问这个目录的内容
5.在虚拟机desktop0进行验证:

案例4:使用自定Web根目录
调整 Web 站点 http://server0.example.com 的网页
目录,要求如下:
1)新建目录 /webroot,作为此站点新的网页目录
  # mkdir /webroot
  # echo '<h1>wo shi webroot' > /webroot/index.html
2)修改虚拟Web主机配置文件,指定新的网页目录
 # vim /etc/httpd/conf.d/nsd01.conf 
   <VirtualHost *:80>
    ServerName  server0.example.com
    DocumentRoot  /webroot
   </VirtualHost>
3)修改Web访问控制配置文件,允许所有人访问
  # vim /etc/httpd/conf.d/nsd02.conf 
   <Directory    "/webroot">
     Require  all  granted      
   </Directory>
4)重起服务
[root@server0 ~]# systemctl restart httpd

5) 修改SELinux策略,安全上下文值(标签值)  
[root@server0 ~]# ls  -Zd  /var/www/
[root@server0 ~]# ls  -Zd  /webroot/

• 方式1:参照标准目录,重设新目录的属性
– chcon [-R] --reference=模板目录   新目录

# chcon  -R --reference=/var/www/  /webroot

[root@server0 ~]# ls  -Zd  /var/www/
[root@server0 ~]# ls  -Zd  /webroot/ 

 客户端访问服务端:
        1.防火墙
        2.服务本身的访问控制
        3.本地目录的权限
        4.安全增强版 SELinux策略


部署动态网站
   LAMP (Linux Apache MySQL/MariaDB php/python) 
   LNMP (Linux Nginx MySQL/MariaDB php/python) 

静态网站的运行
• 服务端的原始网页 = 浏览器访问到的网页
– 由Web服务软件处理所有请求
– 文本(txt/html)、图片(jpg/png)等静态资源

动态网站的运行
• 服务端的原始网页 ≠ 浏览器访问到的网页
– 由Web服务软件接受请求,动态程序转后端模块处理
– PHP网页、Python网页、JSP网页......

虚拟机Server0:
1.以webapp0.example.com部署Python页面
2.用户方便的访问(页面跳转/页面的别名)
  Alias   网络路径    本机实际路径
3.安装mod_wsgi软件包,翻译Python页面代码
4.修改配置文件,进行翻译Python页面代码
WsgiScriptAlias  /  /var/www/baidu/webinfo.wsgi

5.此虚拟主机侦听在端口8909
Listen 8909           #配置httpd程序监听8909端口
<VirtualHost *:8909>  #虚拟web主机监听8909
6. SELinux非默认端口的开放
# semanage port -a -t http_port_t     -p tcp 8909 
   -a:添加    -t:类型     -p:协议
7.验证

默认端口访问优先级最高,默认端口不匹配,显示第一个虚拟Web主机内容


Day07

安全的Web的构建   

• Public Key Infrastructure,公钥基础设施
– 公钥:主要用来加密数据
– 私钥:主要用来解密数据(与相应的公钥匹配)
– 数字证书:证明拥有者的合法性/权威性(单位名称、
有效期、公钥、颁发机构及签名、......)
– Certificate Authority,数字证书授权中心:负责证书
的申请/审核/颁发/鉴定/撤销等管理工作

1.部署网站证书
	cd /etc/pki/tls/certs   默认放网站证书路径
2.部署根证书
	/etc/pki/tls/certs
3.部署私钥
	cd /etc/pki/tls/private
4.安装软件包
	httpd
	mod_ssl(支持加密通信的软件):在/etc/httpd/conf.d/下生成ssl.conf文件，需重起httpd服务去识别这个文件
5.修改配置文件/etc/httpd/conf.d/ssl.conf
  创建一个网页
  进入配置文件修改：   DocumentRoot "/var/www/html"
			ServerName www0.example.com:443
			SSLCertificateFile（指定网站证书）
			SSLCertificateKeyFile（指定私钥）
			SSLCACertificateFile(根证书)
6.重起httpd服务
7.验证

基础邮件服务

• 电子邮件服务器的基本功能
– 为用户提供电子邮箱存储空间(用户名@邮件域名)
– 处理用户发出的邮件 —— 传递给收件服务器
– 处理用户收到的邮件 —— 投递到邮箱

    SMTP:用户发出的邮件的协议  默认端口  25
    pop3:用户收到的邮件的协议  默认端口 110

1.搭建邮件服务，安装postfix软件包
2.修改配置文件/etc/postfix/main.cf
	myorigin = server0.example.com    默认补全后缀
	inet_interfaces = all		   允许本机所有接口使用邮件服务
	mydestination = server0.example.com	判断目标是否为本域邮件
3.重起服务

邮件测试：
	1.建立邮箱帐号
	2.收发邮件
	交互式发送命令：mail -s '主题' -r 发件人 收件人
	回车后判断结束机制是：单独一行已.结尾
	非交互式：echo 内容 | mail -s 主题 -r 发件人 收件人
	接受：mail -u 收件人
	& q     #退出

•使用fdisk操作适合  MBR分区模式,最大容量2.2TB
            1GB=1000MB   (厂商)
            1GiB=1024MiB   (计算机)

•使用parted操作适合 GPT分区模式,支持128主分区,最大容量18EB
             1EB=1000PB
             1PB=1000TB
             1TB=1000GB      
GPT分区
	使用parted操作，支持128个主分区，最大容量18EB（1EB=1000PB，1PB=1000TB）
	mktable gpt  重新规划分区模式为gpt
	mkpart  分区
	print   查看
	unit GB 以GB为单位
	q	  退出

什么是交换空间
• 相当于虚拟内存
– 当物理内存不够用时,使用磁盘空间来模拟内存
– 在一定程度上缓解内存不足的问题
– 交换分区:以空闲分区充当的交换空间

1.格式化交换文件系统
	mkswap 磁盘路径
2.启用交换分区
	swapon 磁盘路径	
	swapon -s  查看当前组建为交换空间的成员
	优先级，权限大的先使用，留意这里用负数表示
3.停用交换分区磁盘
	swapoff 磁盘路径    
4.开机自动启用交换分区
	/etc/fstab
	访问点：swap，其他参数一样
	swapon -a

MariaDB数据库
1.装包mariadb-server
2.重起mariadb
3.设置数据库管理员密码
4.建立nsd库
5.导入数据
6.查询密码为***的人的名字
有条件的查询（单表查询）：
	select * from 表格名 where password='***'
				 	name='XXX'...
多表格查询：
	select * from 表1，表2... where 条件1 and 条件2...  
	条件表示：表1.name之类
	count（*）统计满足条件的总数
在表中插入数据：
	insert 表名 values（‘添加内容’。。。）

禁止root用户空密码登陆数据库
删除：delete from 表 where 条件。。。
刷新user表：flush privileges

Day01

为虚拟机A与虚拟机B搭建Yum仓库
服务端:虚拟机A  
           1.搭建FTP服务   2.共享光盘所有内容

   1)图形将光盘内容,放入虚拟光驱中
   2)安装vsftpd软件包
   3)利用FTP共享光盘所有内容,默认共享路径下/var/ftp
   4)重起vsftpd服务验证
 客户端:虚拟机B
[root@pc207 ~]# vim /etc/yum.repos.d/rhel7.repo
 [rhel7]
 name=rhel7
 baseurl=ftp://192.168.4.7/rhel7
 enabled=1
 gpgcheck=0

真机上搭建服务端 ：
  1.众多的软件包   2.仓库数据文件  3.搭建FTP服务共享内容
  1）搭建FTP服务
  2)挂载光盘内容到/var/ftp/rhel7
  3)最终测试

扩展的几个应用
目录结构
• 认识Linux的目录层次:
– man hier

常见一级目录的用途
 /boot 存放系统引导必需的文件,包括内核、启动配置
 /bin、/sbin 存放各种命令程序
 /dev 存放硬盘、键盘、鼠标、光驱等各种设备文件
 /etc 存放Linux系统及各种程序的配置文件
 /root、/home/用户名 分别是管理员root、普通用户的默认家目录
 /var 存放日志文件、邮箱目录等经常变化的文件
 /proc 存放内存中的映射数据,不占用磁盘
 /tmp 存放系统运行过程中使用的一些临时文件


权限的数值表示
• 权限的数值化
– 基本权限:r = 4,w = 2,x = 1
– 附加权限:SUID = 4,SGID = 2,Sticky Bit = 1
• 采用数值形式设置权限
– chmod [-R] nnn 文档...
– chmod [-R] xnnn 文档..

历史命令
• 管理/调用曾经执行过的命令
– history:查看历史命令列表
– history -c:清空历史命令
– !n:执行命令历史中的第n条命令
– !str:执行最近一次以str开头的历史命令
调整历史命令的数量
[root@svr7 ~]# vim /etc/profile
HISTSIZE=1000

自定义Yum仓库

 1.准备从互联网下载的软件包
    真机的数据传递到虚拟机A中
 2.在虚拟机A中验证
 3.进行tar解包
 4.生成仓库数据文件
 5.书写yum客户端配置文件

• du,统计文件的占用空间
– du [选项]... [目录或文件]...
– -s:只统计每个参数所占用的总空间大小
– -h:提供易读容量单位(K、M等)

• date,查看/调整系统日期时间
– date +%F、date +%R
– date +"%Y-%m-%d %H:%M:%S"
– date -s "yyyy-mm-dd HH:MM:SS"

vim编辑技巧

命令模式操作

	Home 键 或 ^、数字 0  跳转到行首
	End 键 或“$”键 	跳转到行尾
	1G 或 gg 		跳转到文件的首行
	G 			跳转到文件的末尾行

	复制 yy、#yy 	复制光标处的一行、#行
	粘贴 p、P 		粘贴到光标处之后、之前
	x 或 Delete键 	删除光标处的单个字符
	dd、#dd 		删除光标处的一行、#行
	d^ 			从光标处之前删除至行首
	d$ 			从光标处删除到行尾

	/word 	向后查找字符串“word”
	n、N 		跳至后/前一个结果
	u 		撤销最近的一次操作
	Ctrl + r 	取消前一次撤销操作
	ZZ(大写) 	保存修改并退出

末行模式操作
        :q!                  放弃已有更改后强制退出
        :wq 或 :x             保存已有修改后退出
        :r /etc/filesystems  读入其他文件内容
字符串替换
	:s/root/abc        替换当前行第一个“root”
	:s/root/abc/g      替换当前行所有的“root”
	:1,10 s/root/abc/g 替换第1-10行所有的“root”
	:% s/root/abc/g    替换文件内所有的“root
开关参数的控制
	:set nu|nonu    显示/不显示行号
	:set ai|noai    启用/关闭自动缩进
补充:vim 缓存文件的产生

     发现交换文件,恢复正常 删除交换文件

源码编译安装
• 主要优点
– 获得软件的最新版,及时修复bug
– 软件功能可按需选择/定制,有更多软件可供选择
– 源码包适用各种平台

 源码包----gcc make---->可以执行的程序------------>运行安装

步骤1:安装gcc与make
步骤2:tar解包,释放源代码至指定目录
步骤3:  ./configure 配置,指定安装目录/功能模块等选项
                                 作用1:检测系统是否安装gcc与make
                                 作用2:指定安装目录/功能
步骤4:make 编译,生成可执行的二进制程序文件
步骤5:make install 安装,将编译好的文件复制到安装目录

实用小命令工具(续2)
• ln,创建软连接
– 软连接 --> 原始文档 --> i节点 --> 文档数据
– ln -s 原始文件或目录   软连接文件

   若原始文件或目录被删除,连接文件将失效
   软连接可存放在不同分区/文件系统

• ln,创建硬连接
– 硬连接 --> i节点 --> 文档数据
– ln 原始文件 硬连接文件

  若原始文件被删除,连接文件仍可用
  硬连接与原始文件必须在同一分区/文件系统

制作快捷方式:
[root@svr7 /]# ln -s /路径/源文件   /路径/快捷方式

i节点:硬盘存储空间的一个编号
 读取数据的过程:   首先找到源文件----->i节点编号   
                              通过编号----->存储的区域   取得数据


Day02

DNS服务器的功能
– 正向解析:根据注册的域名查找其对应的IP地址
– 反向解析:根据IP地址查找对应的注册域名,不常用
  所有完整的域名都必须以点结尾   

            根域名:  .  
顶级域名:   .cn    .us   .jp   .kr  .tw  .hk ......
二级域名:   .com.cn   .net.cn  .org.cn  .tedu.cn    
三级域名:   .nb.com.cn  .haxi.com.cn  .xixi.com.cn  
完整域名(FQDN): www.nb.com.cn  ftp.nb.com.cn 

• BIND服务器端程序     
– 系统服务:named
– 默认端口:TCP/UDP 53
– 运行时的虚拟根环境:/var/named/chroot/

• 主配置文件:/etc/named.conf    指定本机负责解析的域名
• 地址库文件:/var/named/        完整的域名与IP对应关系    

• NS,域名服务器(Name Server)记录
• A,地址(Address)记录,仅用于正向解析区域

搭建基本DNS服务

虚拟机A:
1.安装软件包
2.修改配置文件/etc/named.conf
3.创建地址库文件/var/named/tedu.cn.zone
4.重起named服务
客户端验证
1.指定DNS服务器位置
2.域名解析测试

多区域的DNS服务器
虚拟机A:
1.修改配置文件/etc/named.conf  
2.创建地址库文件/var/named/qq.com.zone
3.重起named服务
客户端验证
1.指定DNS服务器位置
2.域名解析测试

特殊的解析记录,以tedu.cn.zone为例
一 DNS的负载均衡,轮询的相同解析记录(了解)
二 泛域名解析		*
三 解析记录的别名(了解)	CNAME
四   有规律的泛域名解析	内置函数: $GENERATE   产生连续的数字

DNS服务器常见的资源解析记录都有那些?
  NS解析记录    A解析记录     CNAME解析记录

DNS子域授权 ,qq.com域名为例
   
            父域:www.qq.com

            子域:www.bj.qq.com

            父域的DNS服务器为虚拟机A,负责解析qq.com       
  
            子域的DNS服务器为虚拟机B,负责解析bj.qq.com 

虚拟机B
1.安装软件包
2.修改配置文件/etc/named.conf
3.创建地址库文件/var/named/bj.qq.com.zone
4.重起named服务
子域授权
  通过父域的DNS服务器为虚拟机A,能够解析www.bj.qq.com
虚拟机A:
[root@svr7 /]# vim /var/named/qq.com.zone
 qq.com.     NS  svr7
 bj.qq.com.  NS  pc207
 svr7        A   192.168.4.7
 pc207       A   192.168.4.207
重起验证

递归查询: 
     客户端向首选DNS服务器寻求解析,首选DNS服务器与其他DNS服务器交互,最终将解析结果,带回来的过程
	recursion  no;    #禁止递归
迭代查询：首选DNS服务器与其他DNS服务器交互

直接起到DNS解析的功能(只能对本机解析) 
  /etc/hosts 主机名映射文件（本地主机名与IP地址对应关系）
	[root@svr7 /]# vim /etc/hosts
	[root@svr7 /]# tail -1 /etc/hosts
	192.168.4.110   www.360.com
客户端解析域名顺序：
      1./etc/hosts
      2./etc/resolv.conf
        3.找寻DNS服务器

缓存DNS: 利用内存进行缓存解析记录，加速解析
真机搭建缓存DNS服务器
1.搭建Yum仓库
2.查看达内   内网DNS服务器地址
3.修改DNS服务器主配置文件，指定转发给内网DNS服务器
	  options {
           directory       "/var/named";
           forwarders   {  172.40.1.10;  };
   };
4. 重起named服务
5.在虚拟机上验证

Day03

Split分离解析(视图解析)          

什么是分离解析
• 当收到客户机的DNS查询请求的时候
 – 能够区分客户机的来源地址
 – 为不同类别的客户机提供不同的解析结果(IP地址)
 – 为不同的客户端，提供最近最适合的服务器
• 根据源地址集合将客户机分类
– 不同客户机获得不同结果(待遇有差别)

注意事项：
1.客户端必须找到，自己的分类，需要管理员分类合理
2.view客户端由上及下，匹配及停止
3.所有的zone都必须在view中
 acl地址列表
• 为大批量的客户机地址建立列表
补充:多区域的分离解析
  每一个view中,zone的个数保持一致,域名的个数保持一致

RAID磁盘阵列

RAID阵列概述
• 廉价冗余磁盘阵列
– Redundant Arrays of Inexpensive Disks
– 通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘

– 阵列的价值:提升I/O效率、硬件级别的数据冗余
– 不同RAID级别的功能、特性各不相同


• RAID 0,条带模式
– 同一个文档分散存放在不同磁盘
– 并行写入以提高效率
– 至少由两块磁盘组成


• RAID 1,镜像模式
– 一个文档复制成多份,分别写入不同磁盘
– 多份拷贝提高可靠性,效率无提升
– 至少由两块磁盘组成


• RAID5,高性价比模式
– 相当于RAID0和RAID1的折中方案
– 需要至少一块磁盘的容量来存放校验数据
– 至少由三块磁盘组成

• RAID6,高性价比/可靠模式
– 相当于扩展的RAID5阵列,提供2份独立校验方案
– 需要至少两块磁盘的容量来存放校验数据
– 至少由四块磁盘组成

RAID0/1/10
• RAID 0+1/RAID 1+0
– 整合RAID 0、RAID 1的优势
– 并行存取提高效率、镜像写入提高可靠性
– 至少由四块磁盘组成

进程管理

     程序：静态的代码，仅占硬盘空间

     进程：动态的代码，占用CPU、内存资源

   PID：进程的编号  
 
      父进程/子进程

查看进程树
• pstree — Processes Tree
– 格式:pstree [选项] [PID或用户名]

• 常用命令选项
– -a:显示完整的命令行
– -p:列出对应PID编号
  systemd:上帝进程是所有进程的父进程  PID编号为1

查看进程快照
• ps — Processes Snapshot
– 格式:ps [选项]...

• 常用命令选项
– aux:显示当前终端所有进程(a)、当前用户在所有
终端下的进程(x), 以用户格式输出(u)
– -elf:显示系统内所有进程(-e)、以长格式输出(-l)
信息、包括最完整的进程信息(-f)

  ps  aux:输出进程信息非常详细
     – 列出正在运行的所有进程

  ps  -elf:输出进程信息比较详细，有该进程的父进程信息
     – 列出正在运行的所有进程

   PPID:父进程的PID号
补充： wc统计 wc -l

进程动态排名
• top 交互式工具
– 格式:top [-d 刷新秒数] [-U 用户名]

   按键盘上  P（大写）按照CPU排序
   按键盘上  M（大写）按照内存排序

检索进程
• pgrep — Process Grep
– 用途:pgrep [选项]... 查询条件

• 常用命令选项
– -l:输出进程名,而不仅仅是 PID
– -U:检索指定用户的进程
– -t:检索指定终端的进程
– -x:精确匹配完整的进程名

who  #当前系统有哪些用户正在登陆v

控制进程
• 后台启动
– 在命令行末尾添加“&”符号,(运行并转入后台)
• Ctrl + z 组合键
– 挂起当前进程(暂停并转入后台)
• jobs 命令
– 查看后台任务列表
• fg 命令
– 将后台任务恢复到前台运行
• bg 命令
– 激活后台被挂起的任务

杀死进程
• 干掉进程的不同方法
– Ctrl+c 组合键,中断当前命令程序
– kill [-9] PID... 
– killall [-9] 进程名...
– pkill 查找条件

日志概述

• 系统和程序的“日记本”
– 记录系统、程序运行中发生的各种事件
– 通过查看日志,了解及排除故障
– 信息安全控制的“依据

内核及系统日志
• 由系统服务rsyslog统一记录/管理

• 常见的日志文件
  /etc/rsyslog.conf  记录下列所有日志的路径
  /var/log/messages  记录内核消息、各种服务的公共消息
  /var/log/dmesg     记录系统启动过程的各种消息
  /var/log/cron      记录与cron计划任务相关的消息
  /var/log/maillog   记录邮件收发相关的消息
  /var/log/secure    记录与访问限制相关的安全消息

日志分析
     tailf:实时跟踪日志

• 通用分析工具
– tail、tailf、less、grep等文本浏览/检索命令
– awk、sed等格式化过滤工具

用户登录分析
• users、who、w 命令
– 查看已登录的用户信息,详细度不同

• last、lastb 命令
– 查看最近登录成功/失败的用户信息

日志消息的优先级
• Linux内核定义的事件紧急程度        
– 分为 0~7 共8种优先级别
– 其数值越小,表示对应事件越紧急/重要
 
  0  EMERG（紧急）        会导致主机系统不可用的情况
  1  ALERT（警告）         必须马上采取措施解决的问题
  2  CRIT（严重）	        比较严重的情况
  3  ERR（错误）	       运行出现错误
  4  WARNING（提醒）    可能会影响系统功能的事件
  5  NOTICE（注意）      不会影响系统但值得注意
  6  INFO（信息）	       一般信息
  7  DEBUG（调试）       程序或系统调试信息等

使用journalctl工具
• 提取由 systemd-journal 服务搜集的日志
– 主要包括内核/系统日志、服务日志

• 常见用法
– journalctl | grep 关键词
– journalctl -u 服务名   [-p 优先级]
– journalctl -n 消息条数
– journalctl --since="yyyy-mm-dd HH:MM:SS" --
until="yyyy-mm-dd HH:MM:SS"

systemctl控制

• Linux系统和服务管理器
– 是内核引导之后加载的第一个初始化进程(PID=1)
– 负责掌控整个Linux的运行/服务资源组合

对于服务的管理
 systemctl restart  服务名   #重起服务
 systemctl start  服务名       #开启服务
 systemctl stop  服务名         #停止服务
 systemctl status  服务名     #查看服务当前的状态
 
 systemctl enable  服务名      #设置服务开机自启动
 systemctl disable  服务名    #设置服务不开机自启动
 systemctl enable  服务名 

systemd
• 一个更高效的系统&服务管理器
– 开机服务并行启动,各系统服务间的精确依赖

– 服务目录:/lib/systemd/system/

RHEL6:运行级别   200 

         0：关机     0
         1：单用户模式（基本功能的实现，破解Linux密码）50 
	 2：多用户字符界面（不支持网络） 80
	 3：多用户字符界面（支持网络）服务器默认的运行级别  100
	 4：未定义
	 5：图形界面    190
	 6：重起   0
   
    切换运行级别：init  数字    

RHEL7：运行模式

   字符模式：multi-user.target
   图形模式：graphical.target
设置永久策略，每次开机自动进入graphical.target
# systemctl set-default graphical.target 

Day04

网络装机概述

网络装机的优势
• 规模化:同时装配多台主机
• 自动化:装系统、配置各种服务
• 远程实现:不需要光盘、U盘等物理安装介质

• 需要哪些服务组件?
– DHCP服务,分配IP地址、定位引导程序
– TFTP服务,提供引导程序下载
– HTTP服务,提供yum安装源

一、搭建配置DHCP服务
1.指定写一个服务器地址
2.重起服务
二、配置TFTP服务
1.安装tftp-server软件
2.重起tftp服务
3.部署pxelinux.0文件
4.部署菜单文件
5.部署图形的模块(vesamenu.c32)与背景图片(splash.png)
6.部署 启动内核（vmlinuz） 与  驱动程序（initrd.img）
7.修改菜单文件/var/lib/tftpboot/pxelinux.cfg/default
三、搭建httpd服务，共享光盘所有内容
1.安装软件包
2.重起服务
3.共享光盘所有内容
4.访问测试
四、部署无人值守安装，生成应答文件
1.通过图形的system-config-kickstart软件可以生成
2.运行图形的system-config-kickstart进行图形配置
五、应答文件
修改菜单文件，指定应答文件位置

自我总结：
pxe自动装机
 一、搭建dhcp服务
	1.安装软件包dhcpd
	2.修改配置文件/etc/dhcp/dhcpd.conf
	3.指定下一个服务器地址，配置文件
		next-server 下一个服务器地址;
		filename “pxelinux.0";		
	#网卡引导文件，说明书，二进制文件安装软件，会自动生成pxelinux.0文件
	4.重起服务
 二、配置TFTP服务
  tftp：简单的文件传输协议
   默认端口：69
   默认共享路径：/var/lib/tftpboot
	1.安装软件包tftp-server
	2.重起tftp服务
	3.部署pxelinux.0
		查询文件/命令所需软件包：yum provides 文件/命令名路径
		查询软件包安装的东西：rpm -ql 软件名
	4.部署菜单文件
	  默认存放路径:/var/lib/tftpboot/pxelinux.cfg/
	   pxelinux.0要求默认路径/var/lib/tftpboot/pxelinux.cfg/default(文件名)
	5.部署图形的模块与背景图片
	6.部署启动内核与驱动程序
	7.修改菜单文件/var/lib/tftpboot/pxelinux.cfg/default

总结开机顺序：	1.dhcp-->ip地址、next-server、filename
		2.tftp-->pxeliunx.0
		3.pxeliunx.0-->default
		4.default-->目录文件
	initrd.img/pxelinux.0/pxelinux.cfg/splash.png/vesamenu.c32/vmlinuz
	ks=http://192.168.4.7/ks.cfg
		5.ks-->--url=http://192.168.4.7/ks.cfg
三、搭建httpd服务，共享光盘所有内容
	1.装包
	2.启服务
	3.将光盘内容放入/var/www/html下
	4.访问测试
四、部署无人值守安装，生成应答文件
  	1.通过图形的system-config-kickstart软件生成
	检测“软件包选择”是否可以选择
	需要光盘的源的yum仓库支持，要求“仓库表示必须为[development]
五、应答文件ks.cfg
	利用httpd服务，将应答文件共享出去
	修改菜单文件，指定应答文件位置

部署多版本pxe，内核，驱动，ks文件不同，其余一式双份


Day05

rsync同步操作

• 命令用法
– rsync [选项...] 源目录      目标目录

• 同步与复制的差异
– 复制:完全拷贝源到目标
– 同步:增量拷贝,只传输变化过的数据

• 本地同步
– rsync [选项...] 本地目录1   本地目录2
– rsync [选项...] 本地目录1/   本地目录2
• rsync操作选项
 – -n:测试同步过程,不做实际修改
 – --delete:删除目标文件夹内多余的文档
 – -a:归档模式,相当于-rlptgoD
 – -v:显示详细操作信息
 – -z:传输过程中启用压缩/解压

rsync+SSH同步（远程同步）

• 与远程的 SSH目录保持同步
– 下行:rsync [...]  user@host:远程目录     本地目录
– 上行:rsync [...]  本地目录        user@host:远程目录

实时同步
一、部署公钥  私钥，实现远程ssh无密码验证
虚拟机A：
1.生成公钥  私钥：ssh-keygen
2.传递公钥 到虚拟机B：ssh-copy-id
3.虚拟机B：查看
4.虚拟机A：测试无密码同步
二、监控目录内容的变化
• Linux内核的 inotify 机制
– 提供事件响应式的文件系统通知机制
– 安装 inotify-tools 控制工具可调用此机制实现监控
1.真机传递tools.tar.gz到虚拟机A
2.虚拟机A验证：
3.安装源码包
	步骤1:安装gcc与make
	步骤2:  ./configure 配置,指定安装目录/功能模块等选项
	 # cd  /root/inotify-tools-3.13/
	 # ./configure 
	步骤4:make 编译,生成可执行的二进制程序文件
	 # make
	步骤5:make install 安装,将编译好的文件复制到安装目录

inotifywait监控
• 基本用法
– inotifywait [选项] 目标文件夹

• 常用命令选项
– -m,持续监控(捕获一个事件后不退出)
– -r,递归监控、包括子目录及文件
– -q,减少屏幕输出信息
– -e,指定监视的 modify、move、create、delete、attrib 等事件类别

三、书写Shell脚本完成，实时同步

       死循环： while

     while  [条件]
     do
              重复执行的代码
     done

IPv6地址配置

IPv4:
由32个二进制组成  最终以  点  分隔 4部分  每部分用1个十进制数表示

IPv6:
由128个二进制组成  最终以 冒号 分隔 8部分 每部分用4个16进制数表示
– 每段内连续的前置 0 可省略、连续的多个 : 可简化为 ::

  子网掩码均为：64位网络位  64位主机位

umask系统环境变量：0022  linux系统最大权限：777    所有默认权限是755
第一位0是特殊权限，默认权限=最大权限-系统定义环境变量值

PATH变量：提供命令的搜寻路径

zip压缩与解压所（跨平台）

  压缩：zip -r（压缩目录是需加） /路径/压缩包名.zip  被压缩的源文档
  解压缩：unzip /路径/压缩包名.zip -d 指定释放位置
#####################################################################
Day01

一、什么是计算机？
	-硬件方面：通过线缆将网络设备和计算机连接起来
	-软件方面：操作系统，应用软件，应用程序通过通过通信线路互连
	-实现资源共享、信息传递

  计算机的网络功能：数据通信、资源共享、增加可靠性、提高系统处理能力
	
  计算机网络发展阶段
	60年代：分组交换
	70-80年代：TCP/IP
	90年代后：Web技术

  标准化组织
	ISO(国际标准化组织)
	ANSI(美国国家标准化局)
	ITU-T(国际电信联盟-电信标准部)	
	IEEE(电气和电子工程师学会)

  广域网(Wide-Area Network)
	-范围:几十到几千千米
	-作用:连接远距离的计算机网络
	-典型应用:Internet
  局域网(Local-Area Network)
	-范围:1km左右
	-作用:连接近距离的计算机网络
	-典型应用:校园网,企业网

二、网络设备及拓扑
　生产厂商：Cisco（思科）、华为
  路由交换设备：路由器，交换机
  网络拓扑结构:点对点、星型及扩展的星型、网状
	-点对点：两台设备之间有一条单独的连接（专用广域网中电路连接的两台路由器）
	-星型拓扑：
		优点：1.易于实现
		      2.易于网络扩展
		      3.易于故障排查
		缺点：1.中心节点压力大
		      2.组网成本较高
	-网状拓扑：
		优点：1.一个节点与多个节点相连
		      2.提供冗余性和容错性
		      3.可靠性高
		缺点：组网成本高

三、网络通信参考模型
	OSI七层框架：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层
	OSI的七层框架功能：
	应用层：网络服务与最终用户的一个接口
	表示层：数据的表示、安全、压缩
	会话层：建立、管理、中止会话
	传输层：定义传输数据的协议端口号，以及流程和差错校验
	网络层：进行逻辑地址寻址，实现不同网络之间的路径选择
	数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能
	物理层：建立、维护、断开物理连接

  TCP/IP五层模型
	应用层：http，ftp,tftp,smtp,dns.. 	设备：应用程序
	传输层：tcp,udp 	单位：数据段  	代表设备：防火墙 
	网络层：icmp,igmp,ip,rap,arap..	单位：数据包 	设备：路由器
	数据链路层：由底层协议构成	单位：数据帧  	设备：交换机
	物理层：由底层协议构成	单位：比特流	设备：网卡

1.物理层：以太网接口：RJ-45（接头名）,RJ-11(电话用)传输电信号
	  光纤接口：传输光纤接口，种类繁多
	  双绞线（TP）：俗称网线，8根纤芯，两两缠绕在一起
		非屏蔽双绞线（UTP）		屏蔽双绞线（STP）
	  双绞线标准：类型		传输速率
		     cat5		100Mbps
		     cat5e		100Mbps（常用）
		     cat6		1000Mbps（1Gbps）（常用）
		     cat7		10000Mbps（10Gbps）
	线缆的连接：
		T568A：白绿，绿，白橙，蓝，白蓝，橙，白棕，棕
		发送+		白色和绿色
		发送-		绿色
		接受+		白色和橘黄色
		不被使用	蓝色
		不被使用	白色和蓝色
		接受-		橘黄色
		不被使用	白色和棕色
		不被使用	棕色
		T568B：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕
		与T568A相反

	连接交换机：标准网线（直通线）
	连接路由器：交叉网线（交叉线）
	全反线：第一次配置路由、交换机时使用的网线
  	中继器：放大信号，延长网络传输距离

Day02

一、数据链路层
  MAC地址：用来识别一个以太网上某个设备
	24比特（供应商标示）+24比特（网卡的唯一标示）
	第8位为0：单播地址，1为组播地址
	数据帧格式：目标地址	源地址	类型/长度	数据	帧校验序列
			6字节	6字节	2字节	   46-1500字节	    4字节
  Linux中：db5sum校验文件命令
	

  0单播：1对1
  1组播：1对多
  48个1广播：1对所有

二、交换机
  工作原理：1.学习：接受源MAC地址，和目标地址
	    2.广播：MAC表中没有目标地址，发送广播
	    3.转发
	    4.更新：MAC地址表老化时间300秒，接口断掉也会删除此端口MAC地址
  广播域：若主机太多影响太大	    
	
三、VLAN技术
    主要作用：1.分割广播域，即广播控制
		2.降低网络延迟
		3.增加安全性  
		4.提高带宽利用  

   VLAN划分
	基于接口划分的静态VLAN
	动态划分不常用，且有些交换机不支持动态划分
   添加vlan，删除vlan，将接口添加到vlan，查看vlan

   Trunk中继链路
	解决相同Vlan间线路太多的问题
	vlan标识的种类：ISL（思科私有协议）、IEEE 802.1Q（公有的）
   channel-group 1 mode on（添加以太通道命令）
   show etherchannel summarry（查看添加的以太通道命令）
   以太通道:	多条线路负载均衡，带宽提高
		容错，当一条线路失效时，其他线路正常通信，不会丢包
   
Day03

网络层
  功能：定义IP地址
	连接不同媒介
	选择数据通过网络的最佳路线
  网段：A 1-127
	B  128-191
	C  192-223
	127		本机回环
	169.254.X.X	临时的无效地址
	以下适用A-C类：
		0.0.0.0网络ID，表示网段范围
		255.255.255.255广播地址
  ICMP协议
	ping ip地址 -t（无限ping）
		     -l 数字（修改ping字节大小）
	路由环路  ttl 生命周期，每跨越一个路由减1
	一般网络延迟不超过50MS
   
   路由原理及配置
	路由是什么？
	  将数据包从一个网络发送到另一个网络
		-需要依靠路由器来完成
		-路由器只关心网络的状态，决定最佳路径
  	路由器工作事情
		-识别数据包的目标IP地址
		-识别数据包的源IP地址（主要用于策略路由）
		-在路由表中发现可能的路径
		-选择路由表中到达目标最好的路径
		-维护和检查路由信息
	获取路由表
	  静态、默认路由
		-由管理员在路由器上手工指定
		-适合分支机构、家居办公等小型网络
	  动态路由
		-根据网络拓扑或流量变化，由路由器通过路由协议自动设置
		-适合ISP服务商、广域网、园区网等大型网络

	一台路由器配置：配置路由器两个接口的ip并开启ip address ip地址 子网掩码
			服务器配置ip地址和网关即可通信
	
	直链路由C
	静态路由S:使计算机可以访问非直连的计算机
	查看路由表：show ip route

	配置静态路由	
		使用ip route 目标网络ID 子网掩码 下一跳地址

	三层交换机
		使用三层交换技术实现VLAN间通信，三层交换=二层交换+三层转发
		三层交换机上配置的VLAN接口为虚接口
	配置：创建所需VLAN
		为每个VLAN配置IP地址
		启用SVI接口
		启用三层交换机的IP路由功能
		如果需要，配置三层交换机的动态或静态路由

  	动态路由:基于某种路由协议实现
	   特点:减少管理任务,但占用了网络带宽
	动态路由协议OSPF:Open Shortest Path First(开放式最短路径优先)
			   适合大中型网络使用
  	配置掩码是反掩码


Day04

传输层
  TCP(Transmission Control Protocol)协议
	-传输控制协议
	-可靠的、面向连接的协议
	-传输效率低
  UDP(User Datagram Protocol)协议
	-用户数据报协议
	-不可靠的、无连接的服务
	-传输效率高

	TCP格式：数据段：20字节
		  SYN：请求建立连接	
		  ACK：同意建立连接
		  FIN：请求断开连接
		三次握手（请求建立连接，对方同意建立，开始传输数据），
		四次断开（请求断开，对方同意，对方发送断开请求，同意断开）

   ACL访问控制列表
	标准访问控制列表
	   -基于源IP地址过滤数据包
	   -标准访问控制列表的访问控制列表号1-99
	配置：access-list 列表号 {permit|deny} 网段 反掩码（0严格匹配，1不匹配）
	  查看：show access-lists
	  删除：no access-lists 列表号

   	扩展访问控制列表
	   -基于源IP地址、目标IP地址、指定协议、端口来过滤数据包
	   -扩展访问控制列表的访问控制列表号是100-199
	配置：access-lists 列表号 {permit|deny} 协议 本地地址 目标地址 eq 端口号

  NAT(网络地址转换)
	作用：通过将内部网络的私有ip地址翻译成全球唯一的公网ip地址，
		使内部网络可以连接到互联网等外部网络上
	私有IP地址分类（仅限内部使用，重点）
		A类：10.0.0.0-10.255.255.255
		B类：172.16.0.0-172.31.255.255
		C类：192.168.0.0-192.168.255.255
	优点：节约公有合法IP地址，处理地址重叠，安全性
	缺点：延迟增大，配置和维护的复杂性
	NAT实现方式
	  1.静态转换（主要服务器用）
	      	配置步骤：接口ip地址配置
			   决定需要转换的主机地址
			   决定采用什么公有地址
			   在内部和外部接口上启用NAT
	  NAT端口映射配置：只想发送某一个服务到公网上
	     ip nat inside source static tcp 192.168.1.1 80(端口号) 公网 端口号
	  2.端口多路复用（PAT）：普通用户使用
		内网访问外网，外网访问不了内网


	总结：TCP：有连接的，安全的，效率低，三次握手（syn,ack与ack,ack），
			四次分开(fin,ack,fin,ack)
	     UDP：
	     NAT:
	     PAT:


Day05

STP生成树协议
    逻辑上断开环路，防止广播风暴的产生，当线路故障，阻塞接口被激活，恢复通信，起备份作用
  每个vlan中都会有各自的STP
  网桥ID：网桥优先级+MAC地址（固定的）
	   取值范围：0-65535
	   缼省值（优先级默认值）：32768
	   优先级必须是4096被数，与小越优先
  查看STP：show spanning-tree vlan 数字
  BLK（block）阻塞接口 	FWD转发接口
PVST+（思科私有设备）  每vlan生成树+  
MSTP（华为私有）	多实例生成树

HSRP（热备份协议）Hot Standby Routing Protocol 思科私有协议
vrrp（华为私有协议）


项目重点：设备作用及其优势
技术点：
  vlan、trunk、以太通道、stp、hsrp、nat、acl、ospf（动态路由）、默认路由（网关设备）、bbs、mail、dns、pxe、pat、dhcp（一般给员工电脑分配IP用）

网络设备：
	品牌及型号：Cisco 2960、3560（市面已换为3650）、2911
	对应华为设备：s3700、s5700、ar2200

交换机要求指标接口数量、接口速率、背板带宽（接口数*接口速率*2）、POE供电 有源以太网（双绞线中备用的线路利用起来）
路由器要求指标内存、Flash、协议支持、模块扩展
 
服务器：
	规模：入门级、工作组级、部门级、企业级
	外形：机架式（最主流的）、塔式、刀片（节省空间，贵）、机柜式（很少用）
	尺寸：1U=1.75英寸=4.445厘米，设备一般在1U-2U之间
	机柜容量：22U、37U、42U
	机柜深度：网络机柜：600或800mm
		   服务器机柜：900或1000mm
	参数：至少2颗CPU颗数、CPU核心数  至少12核（一颗有多少核心数）
	内存：内存卡槽数（24个以上）、最大支持容量（1T以上最好）  
	硬盘：普通1-2T，数据库服务器几十T
	RAID：支持级别、电池
	电源数量（单/双电（服务器一般用双电））、功率
	选型原则：品牌、型号、配置（实用+够用、适合扩展）
	戴尔的服务器R720、R730  15000左右


第二阶段

Day01

Shell脚本
  1.bash解释器:-快捷键、Tab键补齐
		-命令历史
		-命令别名
		-标准输入输出
		-重定向
		-管道操作
	  其他解释器则不全面
	  $0：查看当前解释器是什么！
	  命令行快捷键：Ctrl+A：将光标移至行首
			Ctrl+E：将光标移至行尾
			Ctrl+C：终止操作
			Ctrl+D：退出当前Shell
			Ctrl+M：回车
			Ctrl+U：删除光标之前本行所有内容
			Ctrl+W：删除光标之前的一个单词（已空格分离）
			Ctrl+S：挂起，冻结终端（隐藏当前输入内容）
			Ctrl+Q：解除冻结终端
			Alt+.：调用上一条命令的最后一个单词
			方向键（上下）：历史命令
			Tab键：补齐命令、选项、路径等（需要bash-completion软件包）
		
  2.history:查看历史记录
	    	-c 临时清除历史记录
   	> /root/.bash_history:永久清除历史记录	

  3.别名alias
	alias 别名=‘命令’：临时更改别名
	unalias 别名：取消临时别名
	/etc/.bashrc：永久添加别名文件	

  4.重定向标准输入/输出/错误输出
	标准输入（stdin），描述号为0
	标准输出（stdout），描述号为1
	标准错误（stderr），描述号为2
(此处省略1)>:覆盖重定向(收集正确的信息)
	2>:覆盖重定向（收集错误的信息）
	&>:覆盖重定向（正确、错误全部收集）
	>>:追加重定向(收集正确的信息)
	2>>:追加重定向（收集错误的信息）
	&>>:追加重定向（正确、错误全部收集）
	<:重定向标准输入

  5.运行脚本方式：
	1>直接给文件X权限
	2>bash 文件（在bash中启用一个子bash去运行）
		如果脚本中有exit，则退出的是子bash
	3>source（可以用.代替） 文件（不会产生子bash）
		如果脚本中有exit，则会直接退出当前bash

  6.shell变量
	自定义变量：unset（取消变量）
	环境变量：PWD,USER,HOME,SHELL...
	位置变量：$1,$2....
	预定义变量：$0(查看当前解释器)、$?（显示结果0正常，非0异常）、$#(显示输入位置变量个数)、$*（显示所有位置变量输入的值）、$$(PID进程号)
	PS1='[\u@\h \W]\$'(可以更改一级提示)
	PS2=‘>'(可以更改二级提示)  	\：换行输入

  7.三种引号对变量赋值的影响
	1）双引号的应用:使用双引号可以界定一个完整字符串。
	2）单引号的应用:界定一个完整的字符串，*并且可以实现屏蔽特殊符号的功能*。
	3）反撇号或$()的应用:使用反撇号或$()时，可以将命令执行的标准输出作为字符串存储，因此称为命令替换。
  
  8.交互式产生变量
	1)read 变量名 内容
	  read -p “提示信息” 变量
	2）stty终端显示控制
	将回显功能关闭（stty -echo），
	将回显功能恢复（stty echo），后需换行！
	
  9.全局变量定义
	普通变量值是局部变量，更换解释器则不可用
	文件/etc/profile中export后有系统定义好的环境变量
	export 变量名 ：此定义为全局变量
********************************************************************************

Day02

一、数值运算
  1.整数运算
	1>expr命令（仅取前面整数位，小数位全部省略）
	  	+、-、\*、/、%(符号两边需有空格)
	2>$[]或$(())
		此命令*无需转意，且运算符号两边无需空格，引用变量时可省略$
	3>let
		此命令可以更新变量的值
  2.小数运算
	1>bc交互式运算
		bc
	2>bc非交互式运算
		scale=N（小数位数）
		例：echo ‘scale=2；10/3’ | bc

二、条件测试
  1.基本语法格式
	test 表达式  或   [ 表达式 ]（两边至少有一个空格）
  2.字符串的测试
     	1>==:两个字符串一致为真      
    	2>!=:两个字符串不一致为真
	3>一行执行多条命令
		A && B 	当A执行成功才执行B命令
		A || B	当A执行失败才执行B命令
		A ; B		执行A后，执行B，两者无逻辑关系
		A && B || C	当A和B都执行成功，则不执行C；否则执行C
	4>-z检查变量的值是否未设置（空值）
  3.整数值比较
	-gt:大于
	-ge:大于等于
	-eq:等于
	-ne:不等于
	-lt:小于
	-le:小于等于
  4.检查文件/目录状态
	-e:文档存在为真
	-d:文档存在,且必须为目录才为真
	-f:文档存在,且必须为文件才为真
	-r:文档存在,且必须对其有读取权限才为真
	-w:文档存在,且必须对其有写入权限才为真
	-x:文档存在,且必须对其有执行权限才为真

三、if结构
  1.单分支：    if  条件测试
		 then  
		    命令序列
		 fi
  2.双分支：    if  条件测试
		 then
		    命令序列1
		 else  
		    命令序列2
		 fi
  3.多分支：    if    条件测试1 ;then  
		    命令序列1
		 elif  条件测试2 ;then  
		    命令序列2
		 else
		    命令序列n
		 fi
*******************************************************************************

Day03

一、for循环（适合有固定次数的循环）
  1.for循环格式
	for 变量 in 值列表
  	do
	  命令代码
	done
  2.seq:数字排序命令
	seq 数值列表
  3.echo 选项
	-n 	不输出末尾的换行符。
	-e 	启用反斜线转义。
	\b 	退格
	\\ 	反斜线
	\n 	新行
	\r 	回车
	\t 	水平制表符
	\v 	垂直制表符
　　　　\c　　显示后不换行 
　　　　\f　　在终端上屏幕的开始处显示 
  4.颜色输出的命令:
	echo -e "\033[32m   OK \033[0m"
		     颜色的开头/文字/改回自身颜色
		     \033[30+字体颜色，40+背景颜色
	31:红色	
	32:绿色
	33:黄色
	34:蓝色
	35:紫色
	36:青色
	37:浅灰色
	#!/bin/bash
	cecho(){
	  echo -e "\033[$1m$2\033[0m"
	}


二、while循环（适合死循环）
  1.格式
	while  条件测试 或 while：（无条件死循环）
	do
	    命令序列
	done
  2.死循环中加入sleep 0.1会节省cpu资源

三、case分支
  1.格式
   case  变量  in
    模式1)-------------------------->条件|条件。。。（可以多个条件判断）
        命令序列1 ;;
    模式2)
        命令序列2 ;;
        .. ..
    *)
        默认命令序列
    esac

四、shell函数
  1.格式1：    function  函数名 {
			命令序列
			.. ..
		    }
  2.格式2：    函数名() {
			命令序列
			.. ..
		    }
  3.wait命令的作用是等待所有后台进程都结束才结束脚本。

五、中断及退出
  1.break:结束整个循环
  2.continue:跳过本次循环
  3.exit：结束整个脚本
**********************************************************************************

Day04

一、字符串处理
  1.字符串截取
	1）${变量名:起始位置:长度}------------>起始位置从0开始计算
    	2）expr substr "$变量名" 起始位置 长度------>起始位置从1开始计算
    	3）echo $变量名 | cut -b 起始位置-结束位置------>起始位置从1开始计算
		 	选项 -b 表示按字节截取字符
			1-6：截取1-6
			8-：截取8以后所有
			-6：截取6以前所有
			9：截取第9个字符
			1，4，3：截取不连续字符
  2.字符串的替换
	1)只替换第一个匹配结果：${变量名/old/new}
    	2)替换全部匹配结果：${变量名//old/new}

  3.字符串的掐头去尾
	1）从左向右，最短匹配删除：${变量名#*关键词}
    	2）从左向右，最长匹配删除：${变量名##*关键词}
	3）从右向左，最短匹配删除：${变量名%关键词*}
	4）从右向左，最长匹配删除：${变量名%%关键词*}
  4.字符串初值的处理
	1）只取值，${var:-word}
	若变量var已存在且非Null，则返回 $var 的值；否则返回字串“word”，原变量var的值不受影响。

二、expect预期交互
  1.发送邮件方法：
		echo 内容 | mail -s 主旨 收件人
		mail -s 主旨 收件人 < 文件
		mail -s 主旨 收件人 << EOF  .....  EOF
  2.远程免交互式脚本
	yum -y install expect
	#!/bin/bash
	expect << EOF
	spawn ssh -o StrictHostKeyChecking=no 172.25.0.10
	expect "password:" {send "redhat\n"}
	expect "#" {send "rm -rf /abc\n"}
	expect "#" {send "exit\n"}
	expect "#" {send "\n"}
	EOF
  3.数组
	赋值：  变量名=(数值1 数值2 数值3...)
		变量名[数组下标]=数值
			...
三、正则表达式（主要作用过滤文本）
  1.egrep（支持所有grep所有功能）
  常用选项：
	-i		忽略字母大小写
	-v		条件取反
	-c		统计匹配的行数
	-q 		无任何输出，一般用于检测（看$?）
	-n		显示出匹配结果所在的行号
	--color	标红显示匹配子串
  2.		基本正则列表
 	^		匹配行首
	$		匹配行尾
	[]		集合，匹配集合中的*任意单个字符*
	[^]		对集合取反
	.		匹配任意单个字符
	*		匹配前一个字符任意次数（不可单独使用）
	.*		匹配所有
	\{n,m\}	匹配前一个字符n到m次（grep用法）
	{n,m}		匹配前一个字符n到m次（egrep用法）
	\{n\}		匹配前一个字符n次（grep用法）
	{n}		匹配前一个字符n次（egrep用法）
	\{n,\}	匹配前一个字符n次以上（grep用法）
	{n,}		匹配前一个字符n次以上（egrep用法）
 	\(\)		保留（grep用法）
		扩展正则列表
	+		最少匹配一次
	？		最多匹配一次(可以是0次)
	()		组合为整体，保留
	|		或者
	\b		单词边界
********************************************************************************

Day05

处理的是行
一、sed基本用法
  1.主要用法
	-格式1：前置命令 | sed [选项] '编辑指令'
	-格式2：sed [选项] '编辑指令' 文件...
  2.常见选项
	-n：屏蔽默认输出（全部文本）
	-i：直接修改文件内容
	-r：启用扩展正则表达式，若与其他选项一起使用应作为首个选项
  3.常见指令
	p：打印行
		1p：打印第一行
		2p；4p：打印第二、第四行
		2，4p：打印2-4行
		2，+4p：打印第二行及其后的4行
		1~2p：步长（每次增长2行长度）
		$=：打印文件行数
	d：删除行（用法同上）
		$d：删除最后一行
		=：显示所有行号
		!：取反
	s：字符串替换（/可以用#、&等）
		2s/old/new/：将第二行第一个old替换为new
		s/old/new/3：将每行第三个old替换为new
		s/old/new/g：将所有的old替换为new
		s/old/&xxx/:&表示前面原文追加xxx
		s/(^.)(.*)(.$)/\3\2\1/：将第一个字符与最后一个字符调换，()表示复制到\1
  4.注意事项
	-行号可以使用单个数字表示单行
	-或者n，m表示连续多行
	-省略条件，默认逐行处理全部文本
	-匹配正则时，需要使用//(中间出现/需转译\)
  5.通过yum安装vsftpd软件包
    修改vsftpd服务配置，开启匿名上传（/etc/vsftpd/vsftpd.conf里的#anon注释打开）
    调整/var/ftp/pub目录权限，允许写入（防火墙，SElinux，chmod）
    启动vsftpd服务，并设置开机自运行

二、sed进阶用法
  1.扩展指令
 	i：在指定行之前插入
		'2a XX'：第二行之后插入XX
	a：在指定行之后插入
	c：替换指定的行
  2.导入导出操作
	r：读取文件
		3r 文件名：在第三行下插入文件内容
	w：保存到文件（覆盖式）
		2w 文件名：将第二行另存到文件中（若没有会自动创建）
  3.sed的复制剪切
 	-H：模式空间----[追加]---->保持空间（复制）
	-h：模式空间----[覆盖]---->保持空间（复制）
	-G：模式空间----[追加]---->保持空间（粘贴）
	-g：模式空间----[覆盖]---->保持空间（粘贴）
	保持空间：类似剪切版，默认有一个空行
		'1,3H;$G'：将第1-3行追加复制，追加粘贴到最后一行
************************************************************************************

Day06

处理的是列
一、awk基本用法（以字段为单为对文本执行过滤操作，无修改权限）
  1.格式1：前置命令 | awk [选项] '[条件]{指令}'
    格式2：awk [选项] '[条件]{指令}' 文件
	print 是最常用的编辑指令；若有多条编辑指令，可用分号分隔。
  2.选项
	-F：指定分割符
  3.常用内置变量
	$0 文本当前行的全部内容
	$n 文本的第n列
	NR 文件当前行的行号
	NF 文件当前行的列数（有几列）
  4.过滤的时机
	awk  [选项]  'BEGIN{指令}{指令}END{指令}'  文件	
   	BEGIN{ } 行前处理，读取文件内容前执行，指令执行1次
   	{ } 逐行处理，读取文件过程中执行，指令执行n次
  	END{ } 行后处理，读取文件结束后执行，指令执行1次
	;：多条指令
	,：空格
  5.处理条件
	1）-/正则表达式/
	   -～匹配、!～不匹配（模糊匹配）
	2）使用数值/字符串比较设置条件
	   比较符号：==(等于) !=（不等于） >（大于）
	   >=（大于等于） <（小于） <=（小于等于）
	3）逻辑测试条件
	   -&&：且
	   -||：或
	4）数学运算
	
二、awk高级应用
  1.分支结构
	单分支:{if(条件){编辑指令}}
	双分支:{if(条件){编辑指令1}else{编辑指令2}}
	多分支:{if(条件){编辑指令1}else if(条件){编辑指令2}... else{编辑指令N}}
  2.数组
  	1）数组的语法格式
	定义数组的格式：数组名[下标]=元素值
	调用数组的格式：数组名[下标]----------->${变量[下标]}
	遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}
	命令中的变量一般不用加$
	
	例子:awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}' 文件
	个人理解:ip[$1]++表示数组ip[下标]的值++,下标的值不会发生变化
	for i in ip循环:i表示数组ip的下标值,ip表示数组,ip[i]表示对应下标的值

Day07
  一、netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
	-n以数字格式显示端口号
	-t显示TCP连接的端口
	-u显示UDP连接的端口
	-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
	-p显示监听端口的服务名称是什么（也就是程序名称）
  二、查看性能数据的命令
	 uptime                      //查看CPU负载
	 ifconfig eth0               //查看网卡流量
	 free                        //查看内存信息
	 df                          //查看磁盘空间
	 wc -l /etc/passwd           //查看计算机账户数量
	 who |wc -l                  //查看登录账户数量
	 rpm -qa |wc -l              //查看已安装软件包数量	

	Nginx默认安装路径为/usr/local/nginx,该目录下会提供4个子目录，分别如下：
	/usr/local/nginx/conf 配置文件目录
	/usr/local/nginx/html 网站页面目录
	/usr/local/nginx/logs Nginx日志目录
	/usr/local/nginx/sbin 主程序目录

	$!:最后一条后台的任务的PID


Nginx

Day01

常见的web服务
Linux和Unix:Apache,Nginx,Tengine,Lighttpd,Tomcat,IBM WebSphere,Jboss
Windowns:IIS

Nginx并发量高:可以同时支持上万人同时访问
网页中F12-->网络中显示
响应头(服务端给客户端的回复):server会显示服务器类型
请求头:客户端发起的
官网:http://nginx.org

源码装思路:
1)安装依赖	Nginx依赖包:gcc,pcre-devel,openssl-devel
2)tar -xf  
3)./configure  --prefix=指定路径  --with-http_ssl_module:提供ssl加密功能(模块)
	--user=指定用户  --group=指定组   指定了用户和组以后启动Nginx会默认为此用户和组
4)make
5)make install


安全:(权限)  针对用户
	程序的权限依赖于启动该程序的用户
	所以需创建普通用户启动一些程序

Nginx文件:
  nginx path prefix: "/usr/local/nginx"
  nginx binary file: "/usr/local/nginx/sbin/nginx"
  nginx configuration prefix: "/usr/local/nginx/conf"
  nginx configuration file: "/usr/local/nginx/conf/nginx.conf"
  nginx pid file: "/usr/local/nginx/logs/nginx.pid"
  nginx error log file: "/usr/local/nginx/logs/error.log"
  nginx http access log file: "/usr/local/nginx/logs/access.log"
  nginx http client request body temporary files: "client_body_temp"
  nginx http proxy temporary files: "proxy_temp"
  nginx http fastcgi temporary files: "fastcgi_temp"
  nginx http uwsgi temporary files: "uwsgi_temp"
  nginx http scgi temporary files: "scgi_temp"

Nginx服务命令
  /usr/local/nginx/sbin/nginx                    //启动服务
  /usr/local/nginx/sbin/nginx -s stop            //关闭服务
  /usr/local/nginx/sbin/nginx -s reload        //重新加载配置文件
  /usr/local/nginx/sbin/nginx –V                //查看软件信息
  ln -s /usr/local/nginx/sbin/nginx /sbin/        //方便后期使用

netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）

curl:字符界面的浏览器

安装Nginx服务思路
总结:1.源码装包
     2.起服务
     3.设置防火墙和SELinux
     4.访问测试
#########################################################################

一、升级Nginx程序
原nginx中的文件不需变动:
	/usr/local/nginx/conf	配置文件
	/usr/local/nginx/html	页面内容
	/usr/local/nginx/logs	日志文件
修改/usr/local/nginx/sbin/nginx即可
步骤:
1.解压新版本tar包
2../configure ...  生成objs目录
3.make		生成objs/nginx
4.将新版本nginx复制到/usr/local/nginx/sbin/下(提前备份老版本,改名)
5.killall nginx 杀掉老程序,重新启动新程序,完成升级!
  ==>make upgrade(与上述效果相同)

配置文件/usr/local/nginx/conf/nginx.conf
  worker_connections  1024;   同时访问数量默认1024
文件格式
  server{
  	listen 端口;
	server_name 域名;
	root html根目录(相对路径);
	index  index.html(默认首页);   
  }

二、用户认证
1.修改配置文件
  添加: auth_basic 英文提示信息
	auth_basic_user_file /usr/local/nginx/pass(认证密码文件)
2.安装httpd-tools生成密码文件
  htpasswd -c(创建,追加时不需加此选项) 配置文件路径 用户名
  提示输入密码
3.重新加载配置文件
  nginx -s reload
  报错:1.服务未启动	2.配置文件书写错误

三、基于域名、端口、IP的虚拟主机
类似与Apache,配置文件增加一项服务即可
  server {
   	listen 80;
	server_name localhost;
	location / {
	  root html;
	  index index.html;
	}
  }

四、加密算法
HTTP协议时明文(tcp/ip)
HTTPS加密协议

对称算法有：AES、DES，主要应用在单机数据加密。
	加密发送时对方没有密码(一般用于本机电脑文件加密)
非对称算法有：RSA、DSA，主要应用在网络数据加密。
	公钥和私钥,加密和解密算法不同(一般用于网站加密)
信息摘要：MD5、sha256，主要应用在数据完整性校验、数据秒传等。
	md5sum 文件名
 	随机生成码随文件内容变化而变化

五、配置SSL虚拟主机
1.生成公钥私钥的文件需在/usr/local/nginx/conf下
  生成私钥:openssl genrsa > 文件名
  生成公钥:openssl req -new -x509 -key 文件名 > 公钥名
	国家名(2个字母):cn
	省份:
	城市:
	公司:
	单位:
	主机名:
	邮箱地址:
2.修改配置文件
3.重起服务
4.域名解析

#######################################################################

Day02

静态网页和动态网页
	静态网页：被访问的文件是静态的，不需要程序编译的
	动态网页：需要专业的程序编译执行才可以访问，JAVA，PHP，PYTHON语言
一、LNMP部署
  NMP（Linux、Nginx、MySQL、PHP）
  在RHEL7系统中，源码安装Nginx，使用RPM包安装MariaDB、PHP、PHP-FPM软件。
  操作过程中需要安装的软件列表如下：
	nginx
	mariadb、mariadb-server、mariadb-devel
	php、php-fpm、php-mysql
  备注：mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、
	mariadb-devel（其他客户端软件的依赖包）、php（解释器）、
	php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）。
二、构建LNMP平台
 1. 动静分离
	如果用户访问的是静态数据，则直接找到文件，返回
	如果用户访问的是动态数据，则转发给解释器PHP
   location 匹配用户地址栏(支持正则)
	location / { ---------->/的优先级最低
		root html;	
	}
    	location ~ \.php$ {
		转发给解释器PHP
	}
  程序：在硬盘中的叫程序 QQ
  进程：程序启动后会放入内存，内存里的就是进程（耗内存）
	一个PHP进程大约25-30M
  线程：在进程下起3个线程（消耗一个进程的内存，节省内存）
	PHP端口号9000
  2.修改配置文件，添加转发解释器
  3.重起，访问
  4.常见报错： nginx未启动			无法连接
		php-fpm未启动		An Error
		没有修改nginx.conf		未解释文件
		test.php没有			404 not found
		test.php语法错误		空白
	Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
	Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
	PHP默认错误日志文件为/var/log/php-fpm/www-error.log
	如果动态网站访问失败，可用参考错误日志，查找错误信息。
三、地址重写
  1.修改配置文件
	rewrite 旧地址 新地址 [选项]
	rewrite /a.html /b.html;(将a页面转化为b页面)
 	rewrite /a.html /b.html redirect;(地址转换为b地址)
	rewrite ^/ http://www.tmooc.cn/;(所有本地地址跳转到tmooc)
	rewrite ^/ 是从网络地址以后开始匹配转换地址的

	#这里，~符号代表正则匹配，*符号代表不区分大小写
	if ($http_user_agent ~* firefox) {         //识别客户端firefox浏览器
	rewrite ^/(.*)$ /firefox/$1;
	}

	server {
		listen 80;
		server_name www.a.com;
		rewrite ^/ www.baidu.com;  
	}
	server {
		listen 80;
		server_name www.b.com;
		rewrite ^/ www.sina.com;
	}
  2.重起，验证
	常见配置项：/usr/local/nginx/logs/access.log日志文件顺序
	1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；
	2.$remote_user ：用来记录客户端用户名称；
	3.$time_local ： 用来记录访问时间与时区；
	4.$request ： 用来记录请求的url与http协议；
	5.$status ： 用来记录请求状态；成功是200；
	6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；
	7.$http_referer ：用来记录从那个页面链接访问过来的；
	8.$http_user_agent ：记录客户端浏览器的相关信息；
  3.地址重写格式【总结】
	rewrite 旧地址 新地址 [选项];
	  常见选项:
		last 不再读其他rewrite	一个{}中
		break 不再读其他语句，结束请求	不同{}中
		redirect 临时重定向
		permament 永久重定向
总结:
一、部署LNMP
	1.安装软件包
	  Linux：系统
	  Nginx：web服务器
	  Mariadb：客户端软件
	  Mariadb-server：数据库服务
	  Mariadb-devel：依赖包
	  Php：客户端解释器
	  Php-fpm：Php服务器
	  Php-mysql：连接数据库模块
	2.起服务
二、LNMP平台，动静分离
	1.修改配置文件
	location / {root html;}
	location ~ \.php$ {
		root html;
		fastcgi_pass 127.0.0.1:9000;
		include fastcgi.conf;	
	}
	2.重起，验证
三、地址重写
	1.配置文件
	server {
		root html;
		server_name localhost;
		rewrite /a.html /b.html;   #页面跳转到b.html
		rewrite /a.html /b.html redirect; #网址直接临时跳转为b	
	}
	server {
		root html;
		server_name localhost;
		#将所有页面跳转到百度下的此页面
		rewrite ^/(.*) http://www.baidu.com/$1;
	}
	设置访问浏览器不同出现不同页面
	location / {
		#将匹配到的firefox浏览器页面转发
		if ($http_user_agent ~* firefox){
		rewrite ^/(.*) /firefox/$1;	
	}
	}
	2.重起，验证
	3.常见rewrite选项
		last：不再读取下一个rewrite
		break：直接退出，不再读取后续语句
		redirect：临时重写地址
		permament：永久重写地址


####################################################################3
Day03

一、Nginx代理服务器(也叫调度器)
  1.作用:负载均衡(海量请求分配给其他服务器处理),轮询方式
	 自带健康检查(可以及时发现其他服务器是否坏机,将请求交给其他服务器处理)
  2.搭建HTTP调度
	1>部署后端web服务器
	2>修改Nginx配置文件
	#使用upstream定义后端服务器集群，集群名称任意(如webserver)
	#使用server定义集群中的具体服务器和端口
		upstream webserver {
			server 192.168.2.100:80;
			server 192.168.2.200:80;
			...
		}
	#通过proxy_pass将用户请求转发给webserver集群
	server {
		location / {
			proxy_pass http://webserver;
		}
	}
	3>重起Nginx,客户端验证
  3.配置upstream服务器集群池属性	
	-weight设置服务器权重值，默认值为1
	-max_fails设置最大失败次数
	-fail_timeout设置失败超时时间，单位为秒
	-down标记服务器已关机，不参与集群调度
  4.配置upstream服务器群集的调度算法
    #通过ip_hash设置调度规则为：相同客户端访问相同服务器
     通过md5sum对客户端IP前几位地址生成十六进制数，取余后分配给后端服务器
	ip_hash
二、Nginx的TCP/UDP调度器（1.9版本之后才支持）
  1.需要模块--with-stream开启4层
  	stream {
	  upstream 名称 {
		server IP地址：端口；
		...
		}
	  server {
		listen 找个不用的端口；
		proxy_pass 名称；	//转发给后端	
		proxy_connect_timeout 1s; 	//连接超时时间
		proxy_timeout 3s;		//发送数据超时时间	
		}
	}
  2.改配置,起服务，验证
三、Nginx优化处理
  1.自定义返回给客户端的404错误页面（可以针对各种报错403...）
  	修改配置文件error_page 404 /404.html
		    charset utf-8(万国编码，否则会出现乱码)
   	  常见http状态码
	200		一切正常
	301		网站被永久重定向
	302		网站被临时重定向
	401		用户名或密码错误
	403		禁止访问（客户端IP地址被拒绝）
	404		文件不存在
	414		请求URI头部过长
	500		服务器内部错误
	502		Bad Geteway（集群错）
  2.查看服务器状态信息(非常重要的功能)
	1)安装模版--with-http_stub_status_module
	2)修改配置文件
		server {
			location /访问页面跟的名称 {
			  stub_status on;
			  allow ip地址；	//允许访问的ip
			  deny ip地址；	//拒绝访问的ip
			}
		}
	Active connections：当前活动的连接数量。
	Accepts：已经接受客户端的连接总数量。TCP
	Handled：已经处理客户端的连接总数量。TCP
	（一般与accepts一致，除非服务器限制了连接数量）。
	Requests：客户端发送的请求数量。
	Reading：当前服务器正在读取客户端请求头的数量。
	Writing：当前服务器正在写响应信息的数量。
	Waiting：当前多少客户端在等待服务器的响应。
  3.优化Nginx并发量
	1)测试：模拟 -n（总次数）-c（人数）网址
		ab -n 2000 -c 2000 http://192.168.4.5/
  	2)修改Nginx配置文件，增加并发量
		worker_processes 1;	 	//与CPU核心数一致
		worker_connections 65535;	//每个worker最大并发连接数	
	3)优化Linux内核参数（最大文件数量 默认值1024）
		 ulimit -a                  //查看所有属性值
 		 ulimit -Hn 100000          //设置硬限制（临时规则）
 		 ulimit -Sn 100000          //设置软限制（临时规则）
     	4)永久设置,修改配置文件/etc/security/limits.conf
	  用户或组    硬限制或软限制    需要限制的项目   限制的值
	   *		soft(软)	  nofile	   10000
	   *		hard(硬)	  nofile	   10000
		nofile=number of file (文件数量)
  4.优化Nginx数据包头缓存(414报错,优化此项)
  client_header_buffer_size    1k;        //默认请求包头信息的缓存    
  large_client_header_buffers  4 4k;     //大请求包头部信息的缓存个数与容量
  5.浏览器本地缓存静态数据
 	浏览器的缓存最好对多媒体文件:mp3,mp4,jpg...
	文字不适合缓存
	about:cached(查看缓存记录)
	location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
	expires        30d;            //定义客户端缓存时间为30天
	}
  6.日志切割/usr/local/nginx/logs/
	-access.log:默认访问日志
	-error.log:报错日志
	-nginx.pid:PID进程号
	1)手动切割kill -l(查看kill选项)
	  mv access.log access-`date +%F`.log
	  kill -USR1 $(cat nginx.pid)  #生成新的access.log文件
	2)自动完成
	  编写脚本,书写周期性计划任务
  7.对页面进行压缩处理
	http {
	.. ..
	gzip on;                    //开启压缩
	gzip_min_length 1000;       //小文件不压缩(单位字节)
	gzip_comp_level 4;          //压缩比率(1-9)
	gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
	//对特定文件压缩，类型参考mime.types(不建议对多媒体文件压缩,花费时间太常)
	.. ..
	}
  8.服务器内存缓存
	http { 
	open_file_cache          max=2000  inactive=20s;
		open_file_cache_valid    60s;
		open_file_cache_min_uses 5;
		open_file_cache_errors   off; //缓存不要报错
	//设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
	//文件句柄的有效时间是60秒，60秒后过期
	//只有访问次数超过5次会被缓存
	} 
#######################################################################

Day04
一、构建memcached服务
  memcached服务是将数据库信息缓存在内存中，加快用户读取速度
  1.装包memcached
    	/usr/lib/systemd/system：存放所有服务的目录
	配置文件memcached.server
	/etc/sysconfig/memcached:存放ExecStart的各种属性
	ExecStart:可以设定启动服务
		PORT：端口号
		USER：用户
		MAXCONN：最大并发数
		CACHESIZE：内存大小（M）
		OPTIONS:选项
  2.使用telnet访问
	装包telnet
	进入数据库：telnet ip地址 memcached端口

二、客户信息缓存记录
1>session(服务器记录客户登陆信息)、cookie(客户端的缓存)
第一次访问服务器，服务器和客户端会记录保存一段时间，方便第二次访问
client -----------------> server
				[user,pass]
				生成session文件[文件名：内容]
				uuid：用户名：已登陆
	<--------------------------------返回页面，包头cookie:uuid
第二次访问------------------------------>cookie:uuid,找到对应的文件
				  打开内容:用户名,已登陆
2>共享session信息：1.ip_hash(弊端，宕机后还要重新生成)
		   2.nfs共享文件(一般不用，太简单)
		    3.搭建memcached(生产环境应用)
三、连接php与memcached数据库（使集群数据相同）
  1.装包php-pecl-memcache
  2.修改配置文件/etc/php-fpm.d/www.conf
    php_value[session.save_handler] = memcache
    php_value[session.save_path] = "tcp://192.168.2.5:11211"
  3.重起服务验证
##################################################################

Day05
一、安装部署Tomcat服务器
  httpd、nginx配合PHP、Python
  Tomcat配合Java
  1.安装JDK（openjdk）迷你版JRE
	yum -y install  java-1.8.0-openjdk                //安装JDK
 	yum -y install java-1.8.0-openjdk-headless        //安装JDK
	java -version                                    //查看JAVA版本
  2.安装tomcat
	tar -xf  apache-tomcat-8.0.30.tar.gz
	mv apache-tomcat-8.0.30  /usr/local/tomcat
	ls /usr/local/tomcat
	bin/                      //主程序目录
	lib/                      //库文件目录
	logs/                     //日志目录  
	temp/                  	 //临时目录
	work/                     //自动编译目录jsp代码转换servlet
	conf/                     //配置文件目录
	webapps/                  //页面目录
  3.起服务：/usr/local/tomcat/bin/startup.sh
    关服务：/usr/local/tomcat/bin/shutdown.sh
  4.netstat -nutlp |grep java        //查看java监听的端口
	8005端口启动时会取随机数，random产生随机数可用urandom代替
	mv /dev/random  /dev/random.bak
	ln -s /dev/urandom  /dev/random
  5.测试时加8080端口号验证
二、使用Tomcat部署虚拟主机
  1.配置文件结构
  <Server>
    <Service>
	#Connector指定端口号
	<Connector port=8080 />
	<Connector prot=8009 />
     #Engine指定域名
    <Engine defaulthost=默认域名>
	#根目录下需有ROOT目录存放页面文件
	<Host name=域名 appBase=根目录>
	#docBase修改根目录为base，其根目录默认在ROOT下
	#reloadble重新加载，可有可无
	<Context path="" docBase="base" reloadable="true"/> 
	</Host>
	<Host name=域名2 appBase=根目录>
	#path实现跳转，域名2后跟/test将跳转到/var/www/html目录下
	<Context path="/test" docBase="/var/www/html" reloadable="true"/>
	</Host>
	...
    </Engine>
    </Service>    
  </Server>
  2.修改配置文件
  3.创建网页文件
  4.重起服务
  5.访问测试
三、Tomcat加密网站部署
  1.创建密钥keytool --help
	//-genkeypair     生成密钥对
	//-alias tomcat   密钥别名
	//-keyalg RSA     定义密钥算法为RSA算法
	//-keystore       定义密钥文件存储在:/usr/local/tomcat/keystore
  2.修改配置文件
	在<Connector port="8443"...中添加
	keystoreFile="/usr/local/tomcat/keystore" keystorePass="123456" />
  3.重起服务，验证
四、使用Varnish加速Web
  1.代理服务器，有缓存功能，nginx不会自动缓存
    	不是为了实现负载均衡，而是实现Web加速
   CND Content Delivery Network
   	CDN的关键技术主要有内容存储和分发技术，使用户就近获取所需内容
   DNS分离解析
  2.安装varnish
	gcc pcre-devel readline-devel ncurses-devel
	python-docutils-0.11-0.2.20130715svn7687.el7.noarch.rpm
 	源码安装varnish-5.2.1.tar.gz
  3.复制启动脚本及配置文件
	 cp  etc/example.vcl /usr/local/etc/default.vcl #此处名称无所谓
  4.修改代理配置文件
	backend default {------------>此处default可以变更
     .host = "192.168.2.100";
     .port = "80";
	 }
  5.起服务，验证
 	1）varnishd -f /usr/local/etc/default.vcl
 	服务起后将缓存内容，变更后台页面暂时不会对客户端产生影响
  	2）//varnishd –s malloc,128M       
	   定义varnish使用内存作为缓存，空间为128M
	3）//varnishd –s file,/var/lib/varnish_storage.bin,1G
	   定义varnish使用文件作为缓存
  6.查看日志
  	varnishlog            //varnish日志（详细）
	varnishncsa           //访问日志（简单）
  7.更新缓存数据
	varnishadm  
	varnish > ban req.url ~ .* ------>可以更新指定页面
	//清空缓存数据，支持正则表达式
#####################################################################
Day06
一、Subversion（SVN）简介
  1.版本控制系统，管理文件和目录，备份和恢复各个版本，允许和别人共同修改文档
    方便文档的管理，可以供多人使用，记录每一次改变（特点）
  2.架构
	客户端：命令行，图形
	通信方式：本地访问，SVN服务器，Web服务
  3.版本模型1：多人访问会将数据覆盖
    版本模型2（锁定-修改-解锁）：管理不方便，串行开发，忘记解锁等
    版本模型3（拷贝-修改-合并）：方便用户并性工作，自动拷贝老文件
二、部署SVN
服务端：
  1.装包：subversion
  2.创建仓库：svnadmin create /var/svn/project
  3.导入数据： cd 到目录
	  	svn import . file：///var/svn/project -m "注释"
  4.修改配置文件，创建账户与密码
	所有配置文件，要求顶头写，开头不要有空格。
    1)/var/svn/project/conf/svnserver.conf
	 anon-access = none	//19行，匿名无任何权限 
	 auth-access = write	//20行，有效账户可写  
	 password-db = passwd	//27行，密码文件
	 authz-db = authz	//34行，ACL访问控制列表文件
    2)/var/svn/project/conf/passwd 
	harry = 123456	//用户名和密码
	tom = 123456	//用户名和密码
    3)/var/svn/project/conf/authz
	[文件目录]------------------->未声明的默认/的权限
	harry = rw        //用户对项目根路径可读可写
	tom = rw
	* =			//表示所有用户无任何权限
     4)起服务
	svnserve -d  -r /var/svn/project
	-d放入后台	-r文件库地址
	客户端访问：svn://服务器IP地址
     备注：启动服务也可以使用svnserve -d启动，
     但客户端访问时需要指定绝对路径（svn://服务器IP/var/svn/project）
	若用svnserve -d起服务
	客户端访问：svn://服务端IP/var/svn/project
客户端：
  1.将服务器上的代码下载到本地
    yum -y install subversion
    cd /tmp 	//切换到临时目录
    svn --usrename harry --password 123456 co svn://192.168.2.100 code  
    //co表示下载，code表示下载到此目录下（若无则创建）
  2.修改后提交代码
    svn ci -m "备注"  	//自动上传修改的文件
  3.svn操作命令格式
    svn update           //将服务器上新的数据同步到本地
    svn info svn://192.168.2.100    //查看版本仓库基本信息
    svn log svn://192.168.2.100     //查看版本仓库的日志
    svn add test.sh                 //将文件或目录加入版本控制
    svn add test.sh                 //将文件或目录加入版本控
    svn mkdir subdir                //创建子目录
    svn rm timers.target            //使用svn删除文件
    svn diff                        //查看所有文件的差异
    svn cat svn://192.168.2.100/reboot.target    //查看服务器文件的内容
    sed -i 'd' tmp.mount		//删除文件所有内容，但未提交
    svn revert tmp.mount		//还原tmp.mount文件
    svn merge -r7:2 tuned.service 	//将文件从版本7还原到版本2
    svn co -r1 svn://192.168.2.100 abc 	//重新下载1版本
  4.svn命令列表
	add		添加文件
 	commit(ci)	提交更新
	checkout(co)	检出代码（下载）
	cat		查看代码文件内容
	del		删除文件
	diff		文件对比
	import	导入代码
	info		查看版本信息
	list		查看文件列表
	log		查看版本历史（日志）
	update	更新
	mkdir		创建目录
三、使用Subversion协同工作
  1.不同用户修改不同文件
    上传后数据库的信息会更新,互不受影响
    需svn update更新其他用户更改的数据
  2.不同用户修改相同文件的不同行
    第二个用户需先svn update更新数据，再上传数据版本
    更新数据时，会将本地修改数据自动合并
  3.不同用户修改相同文件的相同行
    后提交的用户svn update时会提示冲突
   (p) postpone		推迟，暂不解决
   (df) diff-full		显示全部差异
   (e) edit			编辑
   (mc) mine-conflict 	我的版本
   (tc) theirs-conflict  他的版本
   (s) show all   	显示全部选项
   选择P后，会生成.mine(自己修改的文件)
   		   .r13(未修改的文件)
   		   .r14(他人修改的文件)
		    原文件内容会显示差异
  4.备份所有版本库的数据
    备份:svnadmin dump /var/svn/project > /root/svn.bak
    新建仓库:svnadmin create /var/svn/project1
    还原:svnadmin load /var/svn/project1 < /root/svn.bak
  5.版本控制软件
    CVS，SVN（用的最多）,Git(linus编写的，较新)
  [root@pc001 ~]# yum -y install git
  [root@pc001 ~]# git clone https://github.com/账户名称/仓库名称
  #clone指令用于将服务器仓库中的资料打包下载到本地
  [root@pc001 ~]# cd 仓库名称
  [root@pc001 ~]# 任意修改文件，或新建文件
  [root@pc001 ~]# git add .
  #add添加新文件
  [root@pc001 ~]# git commit -m "test"
  [root@pc001 ~]# git push
  #commit和push实现提交代码的功能
  [root@pc001 ~]# git pull
  #pull更新，类似于svn update
四、制作nginx的RPM包
  1.安装rpm-build
  2.生成rpmbuild目录结构
 	rpmbuild -ba nginx.spec 	#会报错，生成rpmbuild目录
	ls /root/rpmbuild
	SOURCES:放源码包
	RPMS：结果会放此目录
	SPECS：书写各种参数，核心工作 
		License(协议):GPL(开源)
		%post:运行脚本后执行
	SRPMS:放源码包和spec文件
  3.生成rpm包：rpmbuild -ba nginx.spec
  4.在RPMS中生成rpm包，可以createrepo做成yum仓库
########################################################################
Day07
一、VPN服务
  1.概述:Vritual Private Network(虚拟专用网络)
    -在公用网络上建立专用私有网络，进行通讯加密
    -多用于集团为各地子公司建立连接
    -偶尔可以用于翻墙
    -目前主流VPN技术(GRE,PPTP,L2TP+IPSec,SSL)
  2.GRE VPN（linux内核支持的）
    简单，windows不支持，只能一对一
    1)给两台linux配置IP
    2)激活gre：modprobe ip_gre
    3)创建隧道:ip tunnel add tun0 mode gre remote 对方IP local 本机IP
    4)启动隧道:ip link set tun0 up
    5)给隧道配IP:ip addr add 本地IP/掩码 peer 对方IP/掩码 dev tun0
    显示模块列表：lsmod
    查看模块信息：modinfo ip_gre
    查看配置隧道：ip link show
    查看隧道IP：ip a s
    删除隧道：ip tunnel del tun0(隧道名)
  3.PPTP VPN
    windows支持，多对多，未做加密
    1)给windows配置IP,关闭防火墙，ping
    2)装包（linux上）pptpd
    3)修改配置文件
      1>/etc/pptpd.conf
	      localip 本机IP	//服务器本地IP
	      remoteip 隧道网段	//分配给客户端的IP池
      2>/etc/ppp/options.pptpd
      	require-mppe-128      //使用MPPE加密数据
		ms-dns 8.8.8.8             //DNS服务器
			114.114.114.114	   //通用谷歌DNS地址
 	3>/etc/ppp/chap-secrets	  //修改账户配置文件
 		//用户名    服务器标记    密码    客户端
 		*服务器标记必须与/etc/ppp/options.pptpd中的name值相同
  	4>echo "1" > /proc/sys/net/ipv4/ip_forward    
  	  //开启路由转发(翻墙时需改此配置)
    4)起服务：systemctl start pptpd
    5)翻墙设置（测试不用）
       iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
       -j SNAT --to-source 201.1.2.5
  4.L2TP+IPSec VPN
    做加密，安全性高
  IPSec
    1)装包libreswan
    2)主配置文件/etc/ipsec.conf
      include /etc/ipsec.d/*.conf  //加载该目录下所有配置文件
      在/etc/ipsec.d/下新建.conf配置文件
      tar包中模版lnmp_soft/vpn/myipsec.conf
      man ipsec.conf(有所有的加密算法)
    3)创建预共享密钥
      主配置文件/etc/ipsec.secrets
        include /etc/ipsec.d/*.secrets  //同上
      在/etc/ipsec.d/下新建.secrets文件
        格式：服务器IP 客户端（%any:） PSK(pre share key) "密钥"
    4)起服务systemctl start ipsec
	查服务netstat -ntulp |grep pluto
   XL2TP
     1)装包xl2tpd
     2)修改配置文件
       1>/etc/xl2tpd/xl2tpd.conf	 //修改主配置文件
         ip range = 192.168.3.128-192.168.3.254    //分配给客户端的IP池
	   local ip = 201.1.2.10                     //VPN服务器的IP地址
	 2>/etc/ppp/options.xl2tpd 	 //认证配置
	   require-mschap-v2      //添加一行，强制要求认证
 	   crtscts                //注释或删除该行(过期命令)
	   lock                   //注释或删除该行(过期命令)
	 3>/etc/ppp/chap-secrets		 //修改密码文件
	   格式://账户名称   服务器标记   密码   客户端IP
     3)起服务systemctl start xl2tpd
     4)路由转发和翻墙同pptp
二、NTP时间同步
  1.装包chrony
  2.修改配置文件/etc/chrony.conf
	rpm -qc 软件名		//查询安装的软件配置文件
	allow ip/掩码		 //允许那个IP或网络访问NTP
	deny ip/掩码			 //拒绝那个IP或网络访问NTP
	local stratum 15(最大)	 //设置NTP服务器的层数量
  3.重起服务
  4.客户端装包,配置同步时间服务器
  *当有润秒时(59 60 00),需关闭NTP时间同步,国际组织不定时调整
三、PSSH远程工具
 安装软件包pssh
	/usr/bin/pnuke
	/usr/bin/prsync
	/usr/bin/pscp.pssh
	/usr/bin/pslurp
	/usr/bin/pssh
  修改文件/etc/hosts(非必做项)
 	添加:IP 名称	//方便后续远程
  新建vim /root/host.txt
	添加:root@node1
	    (用户@)node2
	    (不加默认root@)node3
  以下所有命令可man帮助查看用法
  1.pssh(批量远程)语法格式
	-A                使用密码远程其他主机（默认使用密钥）
	-i                将输出显示在屏幕
	-H                设置需要连接的主机
	-h                设置主机列表文件
	-p                设置并发数量
	-t                设置超时时间
	-o dir            设置标准输出信息保存的目录
	-e dir            设置错误输出信息保存的目录
	-x                传递参数给ssh
    非交互生成密钥:
	ssh-keygen -N '' -f /root/.ssh/id_rsa
		-N '' 表示密钥不用再加密
		-f .. 表示密钥存放路径
  2.pscp.pssh(批量拷贝)语法格式
	pscp.pssh -h host.txt 本地文档 目标目录
	-r    递归拷贝目录
	其他选项基本与pssh一致
  3.pslurp(批量下载)
	pslurp -h host.txt 远程文件 /文件名(默认在当前目录创建目录)
	下载后的文件路径:当前目录/主机名/文件名
	-L 	指定下载目录
  4.pnuke(批量杀死进程),
 	pnuke -h host.txt 进程名(模糊匹配,包含即可)

CLUSTER

Day01
DAS:本地直连(不能扩容)
NAS:网络存储,文件系统存储,nfs,samba
SAN:网络存储,块存储,iscsi,需搭配光纤设备
SSD(固态盘):intel 三星(只有这两厂商)

一、ISCSI部署
  略
  iscsi允许多客户挂载和读，但不能同时写
  nfs允许同时多客户读写
  非交互式GPT分区：
 	parted /dev/sda mklabel gpt
	parted /dev/sda mkpart primary 1 100%(主分区 1 全分)
  ftp共享时需设置可以解锁上传权限/etc/vsftpd/vsftpd.conf
	#anon_upload_enable=YES
	#anon_mkdir_write_enable=YES
  备份：电源2，网卡2，磁盘raid，4路CPU(16核 至强),
	内存条(16根32根 每根16G 支持ECC)...
二、部署Multipath多路径环境
  1.装包device-mapper-multipath
  2.生成配置文件
	cd /usr/share/doc/device-mapper-multipath-0.4.9/
 	cp multipath.conf  /etc/multipath.conf
  3.获取2个磁盘的wwid
	/usr/lib/udev/scsi_id --whitelisted --device=/dev/sda
  4.修改配置文件/etc/multipath.conf
	defaults {
		user_friendly_names yes
	find_multipaths yes
	}
	multipaths {	//声明做多路径，可以做N个
	    multipath {
		wwid    "360014059e8ba68638854e9093f3ba3a0"
		alias   mpatha	//起个别名
   	 }
	}
  5.重起服务，验证
	在/dev/mapper/下出现mpatha
	以后直接运用mpatha即可
  6.分区,格式化,挂载
  6.查看挂载后多路径连接磁盘状态multipath -rr
三、编写UDEV设备规则
  静态管理(2.6版本以前)：所有设备都要存放在/dev下,/dev/下设定的东西都是临时的
  动态管理(2.6版本以后)：/sys目录，内核动态识别硬件(存放硬件信息)
  流程：  内核读取硬件信息--保存信息到/sys，并通知udev程序
	  udev动态的把设备写入到/dev
	  1./dev/新建文件(名称、权限、所有者、所属组)
	  2.可以触发动作(命令)
  原理作用：从内核受到添加/移除硬件事件时，udev会分析：
	  -/sys目录下信息
        -/etc/udev/rules.d目录中的规则
  	  基于分析结果，udev会：
	  -处理设备命名
	  -决定要创建哪些设备文件或链接
	  -决定如何设置属性
	  -决定触发哪些事件
  udev应用
  时时查看事件监控:
	udevadm monitor --property
		action=add/remove(插入/拔除U盘)
  查看已经存在的设备信息:
	udevadm info --query=path --name=/dev/sdb
		--qurey（查讯）	
		/devices/pci0000:00/0000:00:14.0/usb1/1-8/1-8:1.0/host6/target6:0:0/6:0:0:0/block/sdb
  用前一条命令的路径/block/sdb查详细信息:
	udevadm info --query=property --path=/block/sdb
  查所有属性:
	udevadm info --query=all --attribute-walk --path=/block/sdb
  查分区:
	udevadm info --query=property --path=/block/sdb/sdb1
  在所有终端广播信息
	wall "xxx"
  新建/etc/udev/rules.d/*.rules文件或/usr/lib/udev/rules.d/*.rules
	SUBSYSTEMS=="usb",	//插入系统类型
	EVN{VENDOR}/ATTRS{manufacturer}=="TOSHIBA",	//厂商
	ATTRS{serial}=="60A44CB4665EEE4133500001",	//序列号
	RUN+="/usr/bin/wall udisk plugged in"  //插入后执行命令(绝对路径)
	...
  常见指令操作符:
	==	匹配
	!=	不匹配
	=	赋值
	+=	添加新值
	:=	指定值，且不允许被覆盖
	NAME=""	定义设备名
	SYMLINK+=""	设置连接，别名(分区才做连接)
	WONER=""	定义设备所有者
	MODE=""	定义设备权限
	KERNEL==""	判断设备的内核名称
	RUN+=程序	指定
  udev常用替代变量:
	%k：内核所识别出来的设备名，如sdb1
	%n：设备的内核编号，如sda3中的3
	%p：设备路径，如/sys/block/sdb/sdb1
	%%：%符号本身

1.查询U盘信息
2.在/etc/udev/rules.d/下创建.rules文件，设定条件和命令
  条件属性用udevadm查询,设定NAME,SYMLINK,WONER,GROUP,MODE
3.验证查询结果

四、NFS共享
  注意点:nfs共享文件客户端访问时会默认降级，
	修改配置文件时添加no_root_squash，不限制root权限
#################################################################
Day02

集群
概念：任务调度是集群系统的核心技术
作用：提高性能，降低成本，提高可扩展性，增强可靠性
分类：  高性能(HPC),解决复杂的科学问题
	负载均衡(LB),客户端负载计算机集群中尽可能平均分摊(企业用的较多)
	高可用(HA)，避免单点故障

LVS集群（Linux内核自带）
工作在OSI第四层tcp/ip层
组成：前端（调度器），中间（web服务器，带PHP，JAVA等），后端（数据库）
术语： Director Server，调度器
	Real Server,真实服务器
	VIP，虚拟IP地址（公网的给用户访问的虚拟IP地址）
	RIP，真实IP地址（集群节点上使用的IP地址）
	DIP,调度器连接后端服务器的IP地址
工作模式：NAT模式（类似nginx做调度，地址转换功能，大并发时调度器性能成为瓶颈）
	  TUN模式（隧道模型，调度器和集群不在一个地区，很少用）
	  DR模式（直连路由模式，集群直接将结果返回给客户，不过调度器，减轻调度器压力）
LVS目前实现了10种调度算法
常用的调度算法有4种：
	轮询(Round Robin)，加权轮询(Weighted Round Robin)，
	最少连接(Least Connections)，加权最少连接(Weighted Least Connections)，
	源地址散列（类似ip_hash）
其他算法（不常用）：基于局部性的最少连接，带复制的基于局部性最少连接，目标地址散列，最短的期望延迟，最少队列调度

部署LVS-NAT集群
1.装包ipvsadm
  man ipvsadm
  命令选项：-A	添加虚拟服务器
	-E	修改虚拟服务器
	-D	删除虚拟服务器
	-C	清空所有
	-a	添加真实服务器
	-e	修改真实服务器
	-d	删除真实服务器
	-Ln	查看规则列表
	-s[rr|wrr|lc|wlc]	指定算法
	-t	tcp协议+IP地址
	-u	udp协议+IP地址
	-r	rip的ip地址
	-g	DR模式
	-i	隧道模式
	-m	NAT模式
	-w	设置权重
永久保存所有规则：ipvsadm-save -n > /etc/sysconfig/ipvsadm
查看网关：route -n/ip route
调度器需开路由转发功能：
	临时：/proc/sys/net/ipv4/ip_forward 调整为1
	永久：echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf
总结：
  注:此方法后端集群主机不能和客户端直接通信
  1)ipvsadm -A创建集群调度,-t|u协议,-s算法
  2)ipvsadm -a添加集群rip，模式，权重
  3)开启路由转发echo 1 > /proc/sys/net/ipv4/ip_forward
	永久：echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf
  4)客户端配置web服务，将网关配置为调度IP地址
客户端--->调度器---->地址转换将包---->后端集群
部署LVS-DR集群
  1)设置Proxy代理服务器的VIP和DIP
  注意：为了防止冲突，VIP必须要配置在网卡的虚拟接口！！！
  2)设置后端服务器网络参数
  	DEVICE=lo:0			//设备
	NAME=lo:0			//名字
	ONBOOT=yes			//开机启动
	IPADDR=192.168.4.15	//IP地址
	NETMASK=255.255.255.255	//子网掩码
	NETWORK=192.168.4.15	//网络ID
	BROADCAST=192.168.4.15	//广播地址
  3)防止地址冲突的问题：
    这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
    sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，
     只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
    	net.ipv4.conf.all.arp_ignore = 1	//忽略所有物理网卡回应arp广播
	net.ipv4.conf.lo.arp_ignore = 1	//忽略所有lo回应arp广播
	net.ipv4.conf.lo.arp_announce = 2	//所有lo不对外宣告自己回环地址
	net.ipv4.conf.all.arp_announce = 2 	//所有物理网卡不对外宣告自己回环地址
  4)sysctl -p 使上述文件内容生效
  	#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
	#本机不要向外宣告自己的lo回环地址是192.168.4.15
  5)重起network服务
  6)此服务不带健康检查,不会发现后端服务器是否宕机,需脚本检测
    #!/bin/bash
    rip=192.168.4
    vip=192.168.4.15
    while :
    do
       for i in 100 200
         do
           curl http://$rip.$i &> /dev/null
           if [ $? -eq 0 ];then
             ipvsadm -Ln | grep $rip.$i || ipvsadm -a -t $vip:80 -r $rip.$i
           else
             ipvsadm -Ln | grep $rip.$i && ipvsadm -d -t $vip:80 -r $rip.$i
           fi
         done
     done &
##########################################################################
Day03

Keepalived高可用集群
两个主要功能:
	  1.浮动IP
	  2.自动配置LVS
一、部署keepalived高可用服务
  1.安装软件包keepalived
  2.修改配置文件/etc/keepalived/keepalived.conf
    global_defs{设置报警收件人，发件人，邮件服务器，路由IP（主机名）}
    vrrp_instance VI_1{服务器初始主次(master，backup)，网络接口，虚拟id组号要相同
   ，优先级，间隔时间(默认1秒)，密码，浮动IP(可以多个)}
  3.重起服务
    查看配置效果:ip a s 网卡
  4.清空防火墙规则
    iptables -F
二、部署keepalived+LVS服务
  1.装包keepalived
  2.修改配置文件/etc/keepalived/keepalived.conf
    global_defs{同上}
    vrrp_instance VI_1{同上}
    virtual_server 集群vip地址 端口号 {
      -s算法，-g,-m,-i模式,协议
      real_server 后端RIP地址 端口号 {
          权重
          TCP_CHECK {  	//健康检查
            connect_timeout 3  	//连接超时时间3秒
	      nb_get_retry 3		//连续发送3次请求
	      delay_before_retry 3	//延迟3秒再次连接
            }
        }
    }
  3.重起服务
  4.清空防火墙规则
三、HAProxy负载平衡集群
  LVS[性能最好，在内核中，功能少,不支持正则]
  	keepalived+LVS绝配
    访问模式与以下两个不同，调度器做了nat地址转化，数据包未发生变化
  HAProxy[性能适中，但正则支持性差]
  Nginx[性能比以上两个稍差，web，调度器，正则]
    访问模式：客户访问调度器，调度器以客户身份访问后端集群，生成两个数据包

  部署HAProxy环境
    1.打开路由转发,安装haproxy软件包
    2.修改配置文件/etc/haproxy/haproxy.cfg
      main以下定义集群
      格式:listen *:80	//监听所有来访IP的80端口
        balance roundrobin	//集群算法
        server web1 192.168.2.100:80	可以加权重 	//集群地址
        server web2 192.168.2.200:80 check inter(健康检查时间) 2000(毫秒) rise(试几次算好) 2 fall(试几次算坏了) 5	
       以下供了解:
       global
	 log 127.0.0.1 local2   ###[err warning info debug]
	 chroot /usr/local/haproxy
	 pidfile /var/run/haproxy.pid ###haproxy的pid存放路径
	 maxconn 4000     ###最大连接数，默认4000
	 user haproxy
	 group haproxy
	 daemon       ###创建1个进程进入deamon模式运行
	defaults
	 mode http    ###默认的模式mode { tcp|http|health } log global   ###采用全局定义的日志
	 option dontlognull  ###不记录健康检查的日志信息
	 option httpclose  ###每次请求完毕后主动关闭http通道
	 option httplog   ###日志类别http日志格式
	 option forwardfor  ###后端服务器可以从Http Header中获得客户端ip
	 option redispatch  ###serverid服务器挂掉后强制定向到其他健康服务器
	 timeout connect 10000 #如果backend没有指定，默认为10s
	 timeout client 300000 ###客户端连接超时
	 timeout server 300000 ###服务器连接超时
	 maxconn  60000  ###最大连接数
	 retries  3   ###3次连接失败就认为服务不可用，也可以通过后面设置
    帮助文件在/usr/share/doc/haproxy-1.5.18/configuration.txt
    3.重起服务验证systemctl restart haproxy
    4.检测状态监控页面
      listen *:端口号
        stats uri /stats 	//统计页面
        stats refresh 10s	//统计页面自动刷新时间
        stats realm xxx		//统计页面密码框提示
        stats auth admin:admin	//统计页面用户不名和密码设置
        stats hide-version 	//隐藏统计页面HAProxy版本信息
      Queue队列数据的信息（当前队列数量，最大值，队列限制数量）；
	Session rate每秒会话率（当前值，最大值，限制数量）；
	Sessions总会话量（当前值，最大值，总量，Lbtot: total number of times a server was selected选中一台服务器所用的总时间）；
	Bytes（入站、出站流量）；
	Denied（拒绝请求、拒绝回应）；
	Errors（错误请求、错误连接、错误回应）；
	Warnings（重新尝试警告retry、重新连接redispatches）；
	Server(状态、最后检查的时间（多久前执行的最后一次检查）、权重、备份服务器数量、down机服务器数量、down机时长)。

Nginx分析
优点:
  -工作在7层,可以针对http做分流策略
  -正则表达式比HAProxy强大
  -安装,配置,测试简单,通过日志可以解决多数问题
  -并发量可以达到几万次
  -Nginx还可以作为Web服务器使用
缺点:
  -仅支持http,https,mail协议,应用面小
  -监控检查仅通过端口,无法使用url检查
LVS分析
优点:
  -负载能力强,工作在4层,对内存,CPU消耗低
  -配置性低,没有太多可配置性,减少人为错误
  -应用面广,几乎可以为所有应用提供负载均衡
缺点:
  -不支持正则表达式,不能实现动静分离
  -如果网站架构庞大,LVS0-DR配置比较繁琐
HAProxy分析
优点:
  -支持session、cookie功能
  -可以通过url进行健康检查
  -效率、负载均衡速度，高于Nginx，低于LVS
  -HAProxy支持TCP，可以对MySQL进行负载均衡
  -调度算法丰富
缺点:
  -正则弱于Nginx
  -日志依赖于syslogd，不支持apache日志

###########################################################################
Day04

传统存储:
  NAS:文件系统共享[nfs,samba,http...]
  SAN:块存储[FC,iscsi...]
分布是存储:
  Ceph(文件系统,块,对象存储)都支持
  Lustre
  Hadoop
  FastDFS
  GlusterFS
Ceph组件:
  OSD-存储设备(存东西的)
  Monitor-集群监控组件
  MDS-存放文件系统的元数据(描述数据)
  Client-客户端需装ceph-common
数据恢复软件:finaldata(了解) 
一、环境准备
  配置IP,主机名
  /etc/hosts
  ntp时间同步
  设置免密
  添加磁盘
二、部署ceph集群
  1.部署软件
   	yum -y install ceph-deploy
   	ceph-deploy --help	
    创建目录(以后所有ceph-deploy命令都在此目录下进行)
  2.部署集群
    1）创建集群配置
    	ceph-deploy new node1 node2 node3 ...
	创建出Ceph集群配置文件ceph.conf
    2)给所有节点安装软件包
     	ceph-deploy install node1 node2 node3 ...
	安装ceph所需的基本软件包
    3)初始化所有节点mon服务（主机名解析必须对）
    	ceph-deploy mon create-initial
    	实际运行：cp * /etc/ceph
    	yum -y install ceph-mon
    	systemctl start ceph-mon@node1.server
     ceph -s 	//查看ceph状态
   常见错误：文件/目录不存在
   解决方法： vim ceph.conf      #文件最后追加以下内容
	public_network = 192.168.4.0/24
  	ceph-deploy --overwrite-conf config push node1 node2 node3
  3.创建OSD
    实际生产中，有一块磁盘为ssd固态盘（加速用），其他为磁盘
    1)分2个分区，为两个磁盘做缓冲
     	parted /dev/vdb mklabel gpt
     	parted /dev/vdb mkpart primary 1 50%
     	parted /dev/vdb mkpart primary 50% 100%
   	chown ceph.ceph /dev/vdb1
    	chown ceph.ceph /dev/vdb2
     修改2个分区所有者和所属组，设为永久/etc/udev/rules.d/*.rules
     查找判断条件udevadm info --query=property --path=/block/vdb/vdb1
    2)初始化清空磁盘数据
    	ceph-deploy disk zap node1:vdc node1:vdd
    rpm -qf /usr/sbin/ceph-disk	//查看此程序的软件包
    3)创建OSD存储空间
     	ceph-deploy osd create node1:vdc:/dev/vdb1 node1:vdd:/dev/vdb2
	实际运行:yum -y install ceph-osd
		systemctl start ceph-osd@0.server
     	创建osd存储盘，node1的vdc用vdb1做缓存盘...
    ceph-deploy purgedata	//清空所有数据

    ceph -s:中的osd不够，权限不对，ceph-osd服务未起来
    ps aux | grep osd :中可以手动起ceph-osd服务
三、创建Ceph块存储
  1.创建镜像
    1）查看存储池:ceph osd lspools
    2)创建，查看镜像
	rbd create [池名(不写默认rbd池)]/[镜像名] --image-feature(添加功能) layering --size 10G
	查看：rbd info 镜像名
  2.调整镜像大小
	减小:rbd resize --size 7G image(镜像名) --allow-shrink
	增加:rbd resize --size 15G image(镜像名)
  3.通过KRBD访问(K内核)
    1)集群内将镜像映射为本地磁盘
	rbd map 镜像名(运行一遍会多一块磁盘)
	rbd unmap 镜像名	//删除镜像
    2)通过KRBD访问
	-在客户端需安装ceph-common软件包
	-将集群中配置文件拷贝到客户端(可以找到群集在哪里)
	  scp IP:/etc/ceph/ceph.conf 客户端IP://etc/ceph
	-将集群中的密钥拷贝到客户端(否则无连接权限)
	  scp IP:/etc/ceph/ceph.client.admin.keyring 客户端IP:/etc/ceph
	-在客户端生成本的磁盘
	  rbd map 镜像名	//生成磁盘
	  rbd unmap 镜像名	//取消磁盘
	-查看磁盘对应的镜像名
	  rbd showmapped
    3)格式化，挂载分区
  4.创建镜像快照
    原理:COW(copy on write)写时复制
    1)查看镜像快照
    	rbd snap ls 镜像
    2)创建镜像快照
      rbd snap create 镜像 --snap 快照名
    3)删除镜像快照
      rbd snap remove/rm 镜像 --snap 快照名
    4)还原快照
      rbd snap rollback 镜像 --snap 快照名
  5.创建快照克隆
    1)克隆快照
      克隆快照时为防止过程中快照丢失，需提前保护
      rbd snap protect 镜像名 --snap 快照名
      rbd clone 镜像 --snap 快照 克隆镜像名 --image-feature layering
    2)查看克隆镜像与父镜像快照关系
      rbd info 镜像名
      隐藏克隆镜像的关系信息
      rbd flatten 镜像名
###########################################################################
Day05

虚拟机：
  本质就是文件
  1.磁盘文件(/var/lib/libvirt/images/)   
  2.xml描述文件(/etc/libvirt/qemu/)  
一、ceph的应用
  1.创建磁盘镜像
    rbd create 镜像名 --image-feature layering --size 10G
    rbd list 	//查看
  2.Ceph认证账户
    默认开启认证
  3.部署客户端环境
    安装ceph-common软件包
    Ceph上发送配置文件ceph.conf和用户名密码文件ceph.client.admin.keyring给客户端
  4.创建KVM虚拟机
  5.配置libvirt secret
  新建yyy.xml文件，内容如下	//声明用户名
  <secret ephemeral='no' private='no'>
        <usage type='ceph'>
                <name>client.admin secret</name>
        </usage>
  </secret>
   virsh secret-define --file yyy.xml 	//使用上述文件创建uuid
   virsh secret-list	//查看结果
   virsh secret-set-value \	//将用户名密码连接
   --secret 用户UUID --base64 用户密码(ceph.client.admin.keyring文件中)
  6.修改虚拟机xml配置文件
  vim /etc/libvirt/qemu/xxx.xml	//不推荐此方法
  virsh edit 虚拟机名	//推荐此方法修改
  <disk type='network' ...>	//磁盘为网络类型
    <driver ... type='raw' />	//新建空磁盘
    <auth username='admin'>
    <secret type='ceph' uuid='xxx' />
    </auth>
  <source protocol='rbd' name='rbd/镜像'> 
  <host name='ceph主机IP地址' port='ceph-mon服务端口' />
  </source>
二、Ceph文件系统(一个ceph只能做一个文件系统)
  1.安装软件包ceph-mds
  2.在部署ceph机台的目录下
    ceph-deploy mds create node3	//给node3拷贝配置文件，启动mds服务
  3.同步配置文件和key
    ceph-deploy admin node3
  4.创建存储池，对应128PG
    ceph osd pool create cephfs_data 128 	//数据池
    ceph osd pool create cephfs_metadata 128 	//描述信息池
    ceph mds stat	//查看mds状态
  5.创建ceph文件系统
    ceph fs new 文件系统名字 池子1 池子2	//创建文件系统
    ceph fs ls	//查看文件系统状态
  6.客户端挂载使用
    mount -t ceph IP:端口:/ 挂载点 -o name='用户名',secret='密码'
    -t:文件类型	-o:选项
丁大神总结：
  1.需要软件包ceph-mon ceph-osd ceph-mds
  2.ceph osd create 数据池子
  3.ceph osd create 描述信息的池子
  4.ceph fs create 文件系统
  5.mount -t ceph ip:端口:/ /挂载目录 
  -o name=admin,secret=密码(ceph.client.admin.keyring)
三、对象存储服务
  1.前提：IP，主机名，yum源，ntf，免密，域名解析都要部署OK
  2.部署RGW软件包和配置文件及密钥
    在ceph部署服务器的特定目录下运行下列命令
	ceph-deploy install --rgw 主机名
 	ceph-deploy admin 主机名
  3.启动rgw服务
	ceph-deploy rgw create 主机名
  4.rgw服务器查看结果
	ps aux | grep radosgw
	systemctl status ceph-radosgw@\*


PV:page view 点击量
UV:user view 用户量

第三阶段
Day01

搭建数据库服务器
数据库服务的基本使用
mysql数据类型(难点，重点)

1.关系性数据库软件
需要先设计存储结构，才能存储数据
Oracle  	甲骨文公司(跨平台，不开源)
DB2		IBM(跨平台，不开源)
SQL server 	微软(不开源，不跨平台，仅使用windowns)
MySQL  	甲骨文公司(暂时，开源，跨平台)
2.非关系性数据库软件Nosql
key values模式
redis MongoDB memcached	(开源，跨平台)

MySQL数据库
主配置文件:/etc/my.cnf
日志文件:/var/log/mysqld.log
端口号:3306
进程名:mysqld
传输协议:TCP
一、部署数据库
  1.装包(方式:官网下载，操作系统自带的)
    rpm -U(升级安装，覆盖低版本)
    mysql-community-server-5.7.17-1.e	//服务端的主包
    mysql-community-client-5.7.17-1.e	//客户端提供一些命令等的包
  2.配置
    ss、systemctl、ps	//查看进程服务和端口
    ps -C 服务名	//单独查看某一服务是否运行
  3.起服务
二、数据库基本管理
  1.数据库连接方式
    1)查找登陆密码，在日志文件中
    2)命令行连接、软件连接、web页面连接
    mysql -h登陆方式 -u用户名 -p'密码'	//登陆格式
    3)修改初始密码才可以操作数据库
    alter user root@"localhost" identified by "新密码(8位以上且符合4/4原则)"；
  2.设置密码策略
    1)查找密码策略:
	%表示通配
	show global variables like "%password%";
    2)修改密码策略
	validate_password_policy等级
	0 or LOW		//只验证长度
	1 or MEDIUM(默认)	//长度;数字;大小写;特殊字符
	2 or STRONG		//长度;数字;大小写;特殊字符;字典文件
	validate_password_length=密码长度
	配置文件中添加表示永久改，set只能临时修改
  3.管理环境
    基本注意事项：
	-操作指令不区分大小写（密码，变量除外）
	-每条SQL指令以；结尾
	-不支持Tab键
	-\c不执行当前指令
    常用的SQL操作指令：
      -DDL数据定义语言(create、alter、drop)
      -DML数据操作语言(insert、update、delete)
      -DCL数据控制语言(grant、revoke)
      -DTL数据事物语言(commit、rollback、savepoint)
三、基本操作
  1.库管理命令
    1)库 类似文件夹
    -show databases;	//显示已有的库
    -use 库名；		//切换库
    -select database();	//显示当前所在的库
    -create database 库名;	//创建新库
    -show tables;		//显示已有的表
    -drop database 库名;	//删除库
    2)数据库命名规则
      -可以使用数字/字母/下划线，但不能纯数字
      -区分大小写，具有唯一性
      -不可使用指令关键字、特殊字符
  2.表管理命令
    1)新建表
    -create table 库名.表名(字段名1 字段类型(宽度) 约束条件,....)
    2)表 类似文件
    -desc 表名;	//查看表结构
    -select * from 表名;	//查看表记录
    -drop table 表名;	//删除表
    3)记录 类似文件里的行
    -insert into 表名 values(值列表);	//插入表记录
    -update 表名 set 字段=值;	//修改表记录，加条件用where
    -delete from 表名;		//删除表记录
  3.注意事项
  -MySQL数据库默认不支持中文，需修改default charset=utf8;
四、MySQL数据类型
  1.数值类型
   1)整数型:默认使用有符号类型，加unsigned使用无符号类型
   2)浮点型
   	-定义格式:float(总宽度，小数位数)
   	-当字段值与类型不匹配时，字段值作为0处理
   	-数值不在范围，仅保存最大/最小值
  2.字符类型
  定长：char(字符数)
    -最大长度255字符
    -不够指定字符数时在右边用空格补齐
    -字符数段超出时，无法写入数据
  变长：varchar(字符数)
    -按数据实际大小分配存储空间
    -字符数段超出时，无法写入数据
  大文本类型：text/blob
    -字符数大于65535存储时使用
  3.日期时间类型
  日期时间，datetime(未赋值时，默认NULL)
    -占用8个字节
    -范围：1000-01-01 00:00:00.000000
    	   ~9999-12-31 23:59:59.999999
  日期时间，timestamp(未赋值时，默认当前系统时间)
    -占用4个字节
    -范围：1970-01-01 00:00:00.000000
    	   ~2038-01-19 03:14:07.999999
  日期，date
    -占用4个字节
    -范围：0001-01-01~9999-12-31
  年份，year(输入2位时,01-69默认2001-2069)
    -占用1个字节
    -范围：1901~2155
  时间，time
    -占用3个字节
    -格式：HH:MM:SS
  4.枚举类型
   从给定值集合中选择单个值，enum
     -格式：enum(值1，值2，值N)
   从给定值集合中选择一个或多个值，set
     -格式：set(值1，值2，值N)
  5.时间函数
    now()	//获取系统当前日期和时间
    date()	//获取指定时间中的日期
    year()	//获取指定时间中的年份
    month()	//获取指定时间中的月份
    day()	//获取指定时间中的天
    time()	//获取指定时间中的时刻
    sleep(N)	//休眠N秒
    curdate()	//获取当前系统日期
    curtime()	//获取当前系统时刻 
#########################################################################
Day02

一、约束条件(如何给子段赋值的)
  -Null	//允许为空，默认设置
  -NOT NULL	//不允许为空
  -Key	//索引类型
  -Default	//设置默认值，缼省为NULL
  -Extra	//额外设置
  -null空表示为空(没有数据)，""表示0个字符，小心区分
二、修改表结构
   alter table 表名 执行动作(add,modify,change,drop,rename)
    -add 字段名 类型 约束条件 //添加新字段
       可加after 字段名;	//添加到xx之后
       或者first 字段名;	//添加到第一列
    -modify 修改字段类型，位置...
    -change 修改字段名，类型，位置...
      change 源字段名 新字段名 类型，约束条件
    -drop 字段名	//删除字段
    -rename 新表名	//修改表名
三、MySQL键值(重点)
  1.MySQL索引(类型Btree、B+tree、hash)
  索引：类似书的目录，对字段数据进行排序
    -优点：加快数据检索速度
    -缺点：占用物理空间，降低数据维护速度（增删该）
  2.键值类型
    -index	//普通索引 * 
    -unique	//唯一索引
    -fulltext	//全文索引
    -primary key	//主键 *
    -foreign key	//外键 *
  3.键值类型详解
   1)普通索引index
    使用说明
      一个表中可以有多个索引，经常查询的字段设为索引，
      标志在KEY下显示MUL,字段的值可以重复，且可以赋NULL值
    建表时指定索引
      index(字段);
    在已有的表中添加索引
      create index 索引名 on 表名(字段名);
    查看表中索引
      show index from 表名;
    删除指定索引
      drop index 索引名 on 表名;
   2)主键primary key
    注意事项：
     一个表中只能有一个primary key字段，对应的字段值不允许重复，且不能赋NULL值
     若有多个字段作为primary key，称为复合主键，必须一起创建，
     主建字段KEY标志PRI，通常与auto_increment连用(此时可以赋null,会自增)
     经常把表中的唯一标识记录的字段设置为主键字段[记录编号字段]
    建表的时候指定主建
      primary key(字段名)
    在已有的表中设置primary key
      alter table 表名 add primary key(字段名);
    删除表中primary key
      alter table 表名 drop primary key;(若有自增属性，必须先去掉)
   查看表的索引:
	show create table 表名;
   3)外键foreign key
    概念:让当前表字段的值在另一个表中字段值的范围内选择
    使用外键的条件
	-表存储引擎必须是innodb
	-字段类型要一致
	-被参照字段必须是索引类型的一种(一般是primary key)
    基本用法
    	foreign key(表A的字段名) references 表B(字段名) 
    	on update cascade on delete cascade
    实例:
    create table t1(
      id int primary key auto_increment,
      name char(5)
      )engine=innodb;
    create table t2(
      id int,
      pay float(7,2),
      foreign key(id) references t1(id) on update cascade on delete cascade
    )engine=innodb;
    删除外键
      show create table gzinfo;	//查看外键名
      alter table gzinfo drop foreign key 外键名 
    在已有表中添加外键(表1字段记录不可比表2字段记录多)
      alter table 表1 add foreign key(表1字段) references 表2(表2字段) on update cascade on delete cascade;
########################################################################
Day03

一、MySQL存储引擎
 1.MySQL体系结构：
    管理工具:各种命令的管理
    连接池:检测用户输入的信息和库中信息是否匹配，匹配进入
   SQL接口:数据库中的命令通过此接口交给mysqld去执行
    分析器:分析输入的命令是否有误
    优化器:对执行的命令进行优化
    查询缓存:空间是从系统的物理内存获取，用来存储查找过的数据
    存储引擎:服务软件自带的功能程序，处理表的处理器，不同存储引擎有不同的功能和数据存储方式
        默认存储引擎：MySQL 5.0/5.1 ----> myisam
                  MySQL 5.5/5.6 -----> innodb
    文件系统:硬盘
  2.查看存储引擎类型
    show engines;
  3.修改表的存储引擎
    修改配置文件添加:default-storage-engine=存储引擎名称
  4.存储引擎特点
  1)myisam存储引擎(查询操作多的表使用此引擎)
    表级锁：给整张表加锁
    行级锁：只给被访问的行加锁
     主要特点：-支持表级锁
     		-不支持事务、事务回滚、外键
     相关表文件：.frm(存表结构)、.MYI(存存放索引信息)、.MYD(存表中的数据)
  2)innodb存储引擎()
     事务回滚：在事务执行过程中，任何一步操作没有正确，恢复之前所有操作
     事务日志文件：记录对innodb存储引擎的表执行的操作
     主要特点：-支持行级锁
     		-支持事务、事务回滚、外键
     相关表文件：.frm(存表结构)、.ibd(存索引和数据)、ibdata1、
     		ib_logfile0、ib_logfile1
  3)MySQL锁机制
    锁粒度
      -表级锁：一次直接对整张表进行加锁
      -行级锁：只锁定某一行
      -页级锁：对整个页面(MySQL管理数据的基本存储单位)进行加锁
    锁类型
      -读锁(共享锁)：支持并发读
      -写锁(互斥锁、排他锁)：独占锁，上锁期间其他线程不能读写
    查看当前锁状态
      show status like "%lock%";	//lock锁
   4)事务特性(ACID)
    Atomic：原子性
    	-事务的整个操作是一个整体，不可分割
    Consistency：一致性
    	-事务操作前后，表中的记录没有变化
    Isolation：隔离性
    	-事务操作是相互隔离不受影响的
    Durability：持久性
    	-数据一旦提交，不可改变，永久改变表数据
   5)将自动提交改为手动提交，可以数据回滚
     show variables like "autocommit";	//查看提交状态(默认自动)
     set autocommit=off;		//关闭自动提交
     rollback;		//回滚数据
     commit;		//提交数据
   6)查询操作多的表使用myisam存储引擎，节省资源
     写操作多的表使用innodb存储引擎，并发访问量大
二、数据导入导出(默认检索目录/var/lib/mysql-files/下)
  show variables like "secure_file_priv";	//查询默认检索目录
  永久修改检索目录：
	  vim /etc/my.cnf
	  secure_file_priv="目录名"
	  mkdir 目录
	  chown mysql 目录名
        systemctl restart mysqld
  1)数据导入
   * 数据库中执行系统命令加system即可 *
   基本用法
     -load data infile "目录名/文件名"
     into table 表名
     fields terminated by "分隔符"
     lines terminated by "\n";
   注意事项
     -字段分隔符要与文件内一致
     -指定导入文件的绝对路径
     -导入数据的表字段类型要与文件字段匹配
     -禁用Selinux保护机制
  2)数据导出
   基本用法
     -SQL查询(select...limit限制行数) into outfile "目录名/文件名" 
     fields terminated by "分隔符"
     lines terminated by "\n";	//默认\n
   注意事项
     -导出的内容由SQL查询语句决定
     -导出的是表中的记录，不包括字段名
     -禁用SElinux  
三、管理表记录
  1.增加记录
    格式1:添加1条记录,给所有字段赋值
      insert into 表名 values(字段值列表);
    格式2:添加N条记录,给所有字段赋值
      insert into 表名 values(字段值列表),()(),...;
    格式3:添加1条记录,给指定字段赋值
      insert into 表名(字段名列表) values(字段值列表);
    格式4:添加N条记录,给指定字段赋值
      insert into 表名(字段名列表) values(字段值列表),(),(),...;
    注意事项:
      -字段值要与字段类型相匹配
      -对于字符类型的字段,要用双或单引号括起来
      -依次给出所有字段赋值时,字段名可以省略
      -只给一部分字段赋值时,必须明确写出对应的字段名称
  2.查询记录
    格式1:select 字段1,...,字段N from 表名;
    格式2:select *(所有) from 表名 where 条件表达式;
    注意事项:指定表名时,可以用库名.表名的形式
  3.更新记录
    格式1,更新表内字段的所有记录
      update 表名 set 字段1=字段1值,.....;
    格式2,只更新符合条件对应的部分记录
      update 表名 set 字段1=字段1值,.... where 条件表达式;
    注意事项:
      -字段值要与字段类型相匹配
      -对于字符类型的字段,要用双或单引号括起来
      -若不使用where限定条件,会更新所有记录
      -限定条件时,只更新匹配条件的记录
  4.删除记录
    格式1,仅删除符合条件的记录
      delete from 表名 where 条件表达式;
    格式2,删除所有记录
      delete from 表名;
四、匹配条件
  1.基本匹配条件
    1)数值:=,!=,>,>=,<,<=
    2)字符:=,!=,is null(匹配空),is not null(非空)
    3)逻辑:or,and,!(逻辑非),()(提高优先级)
    4)范围:in (值列表)	//在...里...
    	  not in (值列表)	//不在...里...
    	  between 数字1 and 数字2 	//在...之间...
    	  distinct 字段名	//去重显示.
    	  特别点:select distinct 字段名 from 表名;
  2.高级匹配条件
    1)模糊查询
     -where 字段名 like '通配符'
       -_匹配单个字符,%匹配多个字符
    2)正则表达式
     -where 字段名 regexp '正则表达式'
       -正则元字符^,$,.,[],*,|
    3)四则运算(字段必须是数值类型)
       +,-,*,/,%
       例:select uid,gid,uid+gid (as可省略) xxx[将uid+gid字段名改为xxx] from 表名 [where ...];
  3.操作查询结果
    1)聚集函数
     -avg(字段名)	//统计字段平均值
     -sum(字段名)	//统计字段之和
     -min(字段名)	//统计字段最小值
     -max(字段名)	//统计字段最大值
     -count(字段名)	//统计字段值个数
   2)查询结果排序
     -SQL查询
     order by 字段名(通常是数值类型字段);	//后跟asc升序,跟desc降序排列
   3)查询结果分组
    -SQL查询
    group by 字段名(通常是字符类型字段);
   4)查询结果过滤
    -SQL查询 having 条件表达式;
    -SQL查询 where 条件 having 条件表达式;
    -SQL查询 group by 字段名 having 条件表达式;
   5)限制查询结果限制行数
    -SQL查询 limit N;	//显示查询结果前N条记录
    -SQL查询 limit N,M;	//显示指定范围内的查询记录,从N开始显示M行
    -SQL查询 where 条件查询 limit 3;	//显示查询结果前3条记录
    -SQL查询 where 条件查询 limit 3,3;	//从第四条开始,共显示3条
###################################################################
Day04

一、多表查询
  1.复制表(备份、快速建立新表)
   将源表复制为新表
    create table 新表名 select * from 源表名;
    *注意：复制的新表不会带索引过去，查询条件可以再加
    	   将查询结果调整为空，仅复制表字段
  2.多表查询
   1)多表查询，也称连接查询
     -将2个或2个以上的表按某个条件连接起来，从中选取需要的数据
     -当多表中存在相同意义的字段(字段名可以不同)时，可以通过该字段连接多表
   2)方法1：
      -以下格式查询结果叫笛卡尔集
       查询结果的的总条目数=(表a的记录数 X 表b的记录数)
     select 字段名列表 from 表a,表b;
     -格式
     select 字段名列表 from 表a,表b where 条件;
   3)方法2：where子查询
     -把内层查询结果作为外层查询的条件
     -格式
     select 字段名列表 from 表名
     where 条件
     (select 字段名列表 from 表名 where 条件);
   4)方法3：查询两个表中相同或不同记录使用
    -左连接查询(以表a为主查询)
     表a记录<表b记录
     格式:select 字段名列表 from 表a left join 表b on 条件表达式;
    -右连接查询(以表b为主，条件不成立时用null显示出来)
     表a记录<表b记录
     格式:格式:select 字段名列表 from 表a right join 表b on 条件表达式;
二、MySQL管理工具
  1.常见的mysql管理工具
   Mysql			命令行	跨平台		Mysql官方bundle包自带
   Mysql-Workbench	图形	跨平台		Mysql官方提供
   Mysql-Front		图形	Windows 	开源，轻量级客户端软件
   PhpMyAdmin		浏览器	跨平台		开源，需lamp平台
   Navicat			图形	Windows	专业，功能强大，商业版
  2.部署PhpMyAdmin
    1)部署LAMP环境
    2)安装phpmyadmin
    3)修改文件所有者和所属组	//安全
    3)修改配置文件config.inc.php
    4)客户端访问
三、用户授权及撤销
  1.密码恢复和设置(系统管理员才有权限)
    1)停止mysqld服务
    2)修改配置文件跳过授权登陆skip-grant-tables
    3)登陆mysql重置密码user表中authentication_string
    4)保存退出flush privileges;
  设置修改密码:
    -mysqladm -uroot -p旧密码 password '新密码'	//命令行修改
    -alter user 用户@"登陆地址" identified by '新密码';	//数据库中修改
    -update mysql.user set authentication_string=password(新密码) where 条件;
  重设用户密码
     //授权用户连接后自己修改密码
    set password = password("新密码");
     //管理员重置授权用户连接密码
    set password for 用户名@'客户端地址'=password("新密码");
  2.创建授权(在数据服务器上添加可以连接数据库服务器的用户并设置访问权限及密码)
    1)命令格式
     grant 权限列表(all所有权限,usage无权限) on 数据库.表(*所有) to 用户@"客户端地址" identified by '新密码';	
     //加with grant option表示此用户有授权权限
     //权限列表可以指定字段
  2)mysql授权库和表信息
     -user表,存储授权用户的访问权限
     -db表,存储授权用户对数据库的访问权限
     -tables_priv表,存储授权用户对表的访问权限
     -columns_priv表,存储授权用户对字段的访问权限
   查看权限
     select * from mysql.user;	//从中查看用户及权限
     show grants for 用户@"登陆地址";	//查询用户授权的权限
     show grants;	//查询当前用户的权限
     select user();	//查看当前登陆用户和登陆地址
  3.撤销授权
    revoke 权限列表 on 库名.表名 from 用户名@"客户端地址";
  4.删除授权用户
   1)删除表记录
     delete from mysql.user where user="用户名";
     flush privileges;	//使删除生效
   2)命令删除
     drop user 用户名@"客户端地址";
#########################################################################
Day05

数据备份的方式
  -物理备份：冷备 cp  tar ...
  -逻辑备份：mysqldump  mysql
数据备份策略
  -完全备份：备份所有数据
  -增量备份：备份上次备份后，所有新产生的数据
  -差异备份：备份完全备份后，所有新产生的数据
数据备份需考虑因素
  -数据备份频率
  -备份时间
  
innodb数据会有自己的日志文件，备份时需一同备份
myisam则没有

一、完全备份
  1.物理备份
    cp -rp /var/lib/mysql /备份目录
    tar -zcf xxx.tar.gz /var/lib/mysql
    物理恢复
    cp -rp /备份目录 /var/lib/mysql
    tar -xf xxx.tar.gz -C /var/lib/mysql
  2.逻辑备份
    mysqldump -uroot -p密码 库名 > /备份路径/xxx.sql
    逻辑恢复
    mysql -uroot -p密码 库名 < /备份路径/xxx.sql
    库名表示方式
    *--all-databases或-A		所有库
     *数据库名				单个库
     *数据库名 表名			单张表
    *-B 数据库1 数据库2		多个库
     注意事项：无论备份或恢复，都要验证用户权限
     	       备份所有库和多个库时可以不写库名
  3.缺点：
    	-备份，恢复时会锁表
    	-两次备份之间的数据无记录   	       
二、数据增量备份
 1.binlog日志(二进制日志)：记录所有更改数据的操作
   配置:log_bin[=目录/文件名]
      server_id=数字
      max_binlog_size=数字m(默认500m)
  2.使用binlog日志
    1)启用binlog日志
    	配置文件中添加/etc/my.cnf
   	log_bin[=目录/文件名]	//自定义日志文件目录和名字，需创建并修改权限
      server_id=数字(1-255)
      max_binlog_size=数字m(默认500m)
    好处:-记录除查询之外的所有SQL命令
         -可用于数据恢复
         -配置mysql主从同步的必要条件
   2)binlog相关文件
     -主机名-bin.index	//记录已有日志文件名
     -主机名-bin.000001	//第一个二进制日志
     -......
    显示当前数据库服务器正在使用的bin_log正在使用的日志文件名:show master status;
    手动生成新的日志文件方法
      -重起mysql服务
      -执行SQL操作flush logs
    -mysqldump ... --flush-logs 库 > 路径
    -mysql -uroot -p密码 -e 'flush logs'
    3)清理binlog日志
      -purge master logs to "binlog文件名";	//删除指定编号之前的文件
      -reset master;	//删除所有日志,重新创建新日志(用于完全备份以后)
    4)分析binlog日志
      日志的三种记录格式
      配置文件添加binlog_format=xxx
        -statement:每一条修改数据的sql命令都会记录在日志中
        -row:不记录sql语句上下文相关信息,仅保存哪条记录被修改
        -mixed:以上两种格式的混合使用
      使用mysqlbinlog工具(按时间点和偏移量记录)
        格式:mysqlbinlog [选项] 日志文件名
        常见选项:
        	--start/stop-datetime="yyyy-mm-dd hh:mm:ss"  //指定起始时间
        	--start/stop-position=数字	//指定起始偏移量
    5)利用binlog恢复数据
      使用mysqlbinlog查询时间点和偏移量
      管道给mysql去执行命令恢复数据
三、innobackupex备份/恢复
 1.mysql备份工具
   *物理备份缺点
     -跨平台性差
     -备份时间长、冗余备份、浪费存储空间
  *mysqldump逻辑备份缺点
     -效率低,备份和还原速度慢
     -备份过程中，数据插入和更新操作会被挂起
  *binlog日志备份
     -恢复需人工寻找节点，不方便
  *XtraBackup工具（一款强大的在线热备份工具）
     -备份过程中不锁表，适合生产环境
     -由专业组织percona提供
     主要组件包括
     	-xtrabackup：c程序，支持innodb/xtradb
     	-innobackupex：以perl脚本封装xtrabackup，支持myisam
  2.安装percona，用法
    备份格式：innobackupex [选项] /目录(自动创建)
 3.innobackupex选项
 	--host	主机名
 	--user	用户名
 	--port	端口号
 	--password	密码
 	--databases	数据库名
 		="库名"	单个库
 		="库1 库2"	多个库
 		=库.表"	单个表
 	--no-timestamp	不用系统时间做子目录名
 4.innobk应用	
    *数据的完全备份
     innobackupex --user=root --password=123456 /allbak --no-timestamp
    *数据的完全恢复(要求数据库目录必须为空，此软件特性)
     systemctl stop mysqld
     rm -rf /var/lib/mysql/*
     innobackupex --apply-log /allbak	//回滚日志
     innobackupex --copy-back /allbak	//恢复数据
     chown -R mysql.mysql /var/lib/mysql
    *数据的增量备份
     innobackupex --user=root --password=123456 --incremental /新目录
     --incremental-basedir=/上次备份目录 --no-timestamp
    *数据的增量恢复
   -lsn:事务日志序列号
      1)准备恢复数据
      innobackupex --apply-log --redo-only /fullbak
      2)合并日志
      innobackupex --apply-log --redo-only /fullbak --incremental-dir=/增量备份1
      innobackupex --apply-log --redo-only /fullbak --incremental-dir=/增量备份2
     3)拷贝备份数据到数据库目录下
      innobackupex --copy-back /fullbak
      4)修改数据库目录文件的所有者和组mysql
      chown -R mysql.mysql /var/lib/mysql
      5)启动数据库服务
      systemctl restart mysqld
      6)查看数据
    *恢复完全备份中的某张表
    alter table 表名 discard tablespace;	//删除原表空间文件(.ibd)
    innobackupex --user=root --password=123456 --apply-log --export /备份目录	//导出表日志文件
    cp /备份目录/库/文件 /var/lib/mysql/库	//拷贝表信息文件
    修改所有者
    alter table 表名 import tablespace;	//导入表空间
 
Day1-5
搭建数据库服务器mysql
服务的基本使用
mysql数据类型  约束条件  修改表结构
mysql键值 index  primary key  foreign key
mysql存储引擎 myisam innodb  事务  事务的特性  锁类型  锁粒度
管理表记录  select insert update delete  匹配条件
批量处理数据  数据导入/导出
用户授权  grant  权限撤销  revoke   授权库mysql
数据的备份与恢复  
完全备份 mysqldump(备份锁表) innobackupex(热备锁行)  
增量备份 innobackupex binlog

Day01

一、MySQL主从同步(生产中一定会用)
  1.基本思路
    确保数据相同
	-从库必须要有主库上的数据
    配置主服务器
      	-启用binlog日志	 log_bin=日志名，server_id=id值,binlog_format=mixed
        -授权用户  grant replication slave on *.* to ...	
        -查看当前正在使用的日志 
    配置从服务器
    	-设置server_id=不和主库id相同即可
    	-指定主库信息
    	 change master to
    	 master_host="主库IP地址",
    	 master_user="主库授权的用户",
    	 master_password="授权时的密码",
    	 master_log_file="当前使用日志文件名",
    	 master_log_pos=偏移量;
    	 start/stop slave;	//启动/停止从服务
    测试配置
        -给客户端授权访问主库
    	-客户端连接主库写入数据，在从库上也能查询到
    	-生产环境中需提前建好库和表
  2. 查看当前服务器是不是从服务器2种方法：
      show slave status;
      cat /var/lib/mysql/master.info
  3.从服务器相关文件
    	master.info			主库信息
    	relay-log.info		中继日志信息
    	主机名-relay-bin.xxx	中继日志
    	主机名-relay-bin.index	索引文件
  4.主从同步常用配置选项
    主库配置选项(对所有从库生效)
    	binlog_do_db=库名		//设置主库对哪些库记日志
    	binlog_ignore_db=库名	//设置主库对哪些库不记日志
    从库配置选项(对自己有效)
    	log_slave_updates		//记录从库更新，允许链式复制
    	relay_log=名字		//指定中继日志文件名
    	replicate_do_db=库名	//仅复制指定库
    	replicate_ignore_db=库名	//不复制指定库
二、MySQL主从同步模式
  1.主从同步结构
    一主一从
    一主多从
    互为主从
    主从从：需配置log_slave_updates(允许链式复制)***
  2.主从复制模式(主库从库需同时开启)
   1)异步复制(默认模式)
     主库执行完事务，不管从库是否同步，直接回复客户端结果，效率高，数据一致性不保证
   2)全同步复制(也称组同步复制)
     主库执行完事务，等待全部从库同步数据后才回复客户端，保证数据一致，效率低，不常用
   3)半同步复制
     主库执行完事务，保证一台从库同步数据后，即可回复客户端，介于以上两种之间，工作中常用模式
   3.半同步复制模式配置
     1)查看是否允许动态加载模块(若不支持，在配置文件中更改)
     show variables like "have_dynamic_loading";
     2)查看是否有此模块，没有命令行加载插件
     select plugin_name,plugin_status from information_schema.plugins where plugin_name like '%semi%';
      主库安装插件
      install plugin rpl_semi_sync_master soname 'semisync_master.so';
      从库安装插件
      install plugin rpl_semi_sync_slave soname 'semisync_slave.so';
     3)启用半同步复制
      set global rpl_semi_sync_master_enabled = 1;	//主库
      set global rpl_semi_sync_slave_enabled = 1;		//从库
     4)永久启用更改配置文件
       主库配置
       plugin-load=rpl_semi_sync_master=semisync_master.so
       rpl_semi_sync_master_enabled=1
       从库配置
       plugin-load=rpl_semi_sync_slave=semisync_slave.so
       rpl_semi_sync_slave_enabled=1
######################################################################
Day02

一、mysql数据读写分离
  1.原理
   由代理服务器面向客户，根据客户读写需求进行过滤分离，给后端服务器处理
  2.部署maxscale服务
    1)安装maxscale软件
    2)修改配置文件/etc/maxscale.cnf
     threads=auto	//服务器进程数设为自动
     [server1]			//第一台服务器
	type=server			//类型
	address=数据库IP地址	//数据库IP地址
	port=端口号			//端口
	protocol=MySQLBackend	//协议(后端数据库服务器)
     [server2]
       ...
     [MySQL Monitor]	//监视数据库
	type=monitor	
	module=mysqlmon
	servers=server1，server2	//监视的服务器列表	
	user=myuser			//监视时使用的用户名
	passwd=mypwd		//监视时使用的密码
	monitor_interval=10000
     #[Read-Only Service]		//未设置，需注释
        ...
     [Read-Write Service]	//读写分离服务设定
	type=service
	router=readwritesplit
	servers=server1,server2	//服务器
	user=myuser		//路由用户，查看用户输入的用户名密码是否存在
	passwd=mypwd	//密码，只需授权select权限在mysql库，安全
	max_slave_connections=100%
     [MaxAdmin Service]		//软件管理服务
	type=service
	router=cli
     #[Read-Only Listener]	//不定义只读服务端口，需注释
        ...
     [Read-Write Listener]	//读写服务端口
	type=listener
	service=Read-Write Service
	protocol=MySQLClient
	port=4006
     [MaxAdmin Listener]		//软件管理端口
	type=listener
	service=MaxAdmin Service
	protocol=maxscaled
	socket=default
	port=未被占用的端口号即可
    3)部署授权用户
      监控用户权限: ... replication slave,replication client on *.* ...
      路由用户权限: ... select on mysql.* ...
    4)启动数据读写分离服务
     maxscale -f /etc/maxscale.cnf
    5)测试配置
     maxadmin -uadmin -pmariadb -P端口
   6)读写分离测试
     写入后查看主库和从库是否都有数据，有表示从主库写入
     读入测试可以在从库加入主库不存在的数据，进行查询
二、mysql多实例
  1.在一个物理机上运行多个数据库服务
  2.部署多实例
   1)装包mysql-5.7.20
   2)新建修改主配置文件/etc/my.cnf
    [mysqld_multi]	//启用多实例
    mysqld=/usr/local/mysql/bin/mysqld_safe	//指定进程文件路径
    mysqladmin=/usr/local/mysql/bin/mysqladmin	//指定管理命令路径
    user=root		//指定进程用户
    
    [mysqld1]		//实例进程名称
    port=端口		//端口号(不要重复)
    datadir=/目录		//数据库目录(自己指定)
    socket=/目录/名字.sock	//指定sock文件路径和名字
    pid-file=/目录/名字.pid	//进程pid号文件位置
    log-error=/目录/名字.err	//错误日志位置
    [mysqld2]
     ...
   3)初始化多实例数据库
    ./mysqld --user=mysql --basedir=软件安装目录 --datadir=数据库目录 --initialize	//手动初始化
    /usr/local/mysql/bin/mysqld_multi start 实例编号	//启动服务
    /usr/local/mysql/bin/mysqld_multi --user=用户 --password=密码 stop 1	//停止服务
   4)连接数据库
    /usr/local/mysql/bin/mysql -uroot -p初始密码 -S sock文件
########################################################################
Day03

MHA简介
  针对数据库的高可用集群软件,可以快速(0-30s)故障自动切换,保证数据的一致型(日本开发)
MHA组成
  MHA Manager(管理节点)
    -可以单独部署在一台独立的机器上,管理其他节点
    -也可以部署在一台slave节点上
  MHA Node(数据节点)
    -运行在每台MySQL服务器上
MHA工作过程
  1.从宕机崩溃的master保存二进制日志事件
  2.时别含有最新更新的slave
  3.应用差异的中继日志(relay log)到其他的slave
  4.应用从master保存的二进制日志事件
  5.提升一个slave为新的master
  6.使其他的slave连接新的master进行复制
MHA部署
  1.准备环境
    1.1装包perl-*,node包(数据库服务器与管理服务器需要),manager包(管理服务器需要)
    1.2所有节点授权root@"%"用户权限监控
    1.3实现所有数据库服务器之间ssh免密登陆
    1.4实现数据库服务器与管理主机ssh免密登陆
  2.配置MHA集群
    2.1配置一主多从服务器集群,配置半同步复制
     主库/备用主库/etc/my.cnf配置
        server_id=
        log_bin=路径和名字
        binlog_format=模式
        plugin_load=主从模式		
        rpl_semi_sync_master_enabled=1	//主库半同步模式开启
        rpl_semi_sync_slave_enabled=1	//从库半同步模式开启
        relay_log_purge=off		//不自动删除中继日志文件
      从库
        server_id=
       >change master to
        master_host=主机IP地址
        master_user=主从用户
        master_password=主从密码
        master_log_file=日志文件
        master_log_pos=偏移量
    2.2授权replication slave权限用户
      grant replication slave on *.* to 用户@"%" identified by "密码";
    2.3配置管理主机
      2.3.1修改配置文件
	master_ip_failover_script=自动切换VIP脚本
 	manager_workdir=配置文件路径
	manager_log=日志路径
	repl_password=123456	//主从用户密码
	repl_user=repluser	//主从用户
	ssh_port=22			//远程端口
	ssh_user=root		//远程使用用户
	password=123456		//监控数据库密码	
	user=root			//监控数据库用户
	[server1]
	hostname=		//IP地址
	candidate_master	//主备
	....
	no_master=1		//不做主备
     2.3.2根据配置文件设置对应配置
     	监控用户授权
     	grant all on *.* to root@"%" identified by "123qqq...A"; 
     	修改脚本文件VIP地址
     	my $vip = '192.168.4.100/24';
     	给脚本文件执行权限
     	chmod  755 /etc/mha/master_ip_failover
     	在主库配置VIP
     	ifconfig  eth0:1 192.168.4.100/24
    2.4在管理主机检测所有配置
      2.4.1检测免密配置
       masterha_check_ssh --conf=/etc/mha/app1.cnf
      2.4.2检测主从同步配置
       masterha_check_repl --conf=/etc/mha/app1.cnf
      2.4.3启动管理服务
       masterha_manager --conf=/etc/mha/app1.cnf \
       --remove_dead_master_conf  --ignore_last_failover
    2.5维护MHA集群,把坏掉的添加到集群
       2.5.1重新启动故障机器,配置为当前主库的从库
       2.5.2修改管理主机配置文件
########################################################################
Day04

一、MySQL视图 view
  只有.frm文件时,视图表 
                   表的存储引擎是memory(数据存储在内存,重起会丢失)
1.视图概述
  1.1什么是视图
    -虚拟表
    -内容与真实表相似，有字段有记录
    -视图并不在数据库中以存储的数据形式存在                  
    -行和列的数据来自定义视图时查询所引用的基表，并且在具体引用视图时动态生成
    -更新视图的数据，就是更新基表的数据
    -更新基表数据，视图的数据也会跟着改变
  1.2视图的优点
    简单
      -用户不许关心视图中的数据如何查询获得
      -视图中的数据已经是过滤好的符合条件的结果集
    安全
      -用户只能看到视图中的数据
    数据独立
      一旦视图结构确定，可以屏蔽表结构对用户的影响
  1.3视图使用限制(了解)
    -不能在视图上创建索引
    -在视图的from子句中不能使用子查询
    -以下情形中的视图不可更新的
      关键字、常量视图/JOIN/FROM一个不能更新的视图、使用了临时表、where子句的子查询引用了from子句中的表
2.视图的基本使用
  2.1创建视图
   create view 视图名称 as SQL查询;
   create view 视图名称(自定义字段名) as SQL查询;    
  2.2查看视图
   show table status;
   show table status where comment="view"\G;
   show create view 视图名;	//查看创建视图具体命令
3.视图进阶
  3.1设置字段别名
    -创建视图时的字段名不可以重复，所以要定义别名
   create view 视图名 as select 表名.字段名 as 字段别名 from 表名 表别名 left join 表名 表别名 on 条件；
  3.2重要选项  
    -覆盖or replace         
    create or replace view 视图名 as select 查询;	//若视图存在会覆盖已有视图
    -算法algorithm
     undefined //未定义时，默认merge替换方式，直接查询视图表
     temptable //具体化方式:会先执行创建视图时的查询命令存放起来，再去查询    
     create algorithm=算法 view ...          
    -检查范围
     local		//仅满足当前视图的限制
     cascaded	//同时满足基表的限制(默认)
     create view 视图名 SQL查询 with 检查范围 check option;
     
二、MySQL存储过程 procedure
1.存储过程介绍
  1.1存储过程，相当于时MySQL语句组成的脚本
    -指的时数据库中保存的一系列SQL命令的集合
    -可以在存储过程中使用变量、条件判断、流程控制等
  1.2优点
    -提高性能
    -可以减轻网络负担
    -可以防止对表的直接访问
    -避免重复编写SQL操作
2.创建存储过程
  格式: delimiter //		//改变命令结尾符号,保证存储过程SQL命令遇到;不执行
      create procedure 名称()
  	begin
  	  select * from user;
  	  代码
  	  ...
  	  ...
  	end
  	//
  	delimiter;
3.调用存储过程
  call 名称();		//()中没有参数时可以省略
4.查看存储过程
  4.1方法一
    show procedure status;
  4.2方法二
    select db,name,type,body from mysql.proc where name="存储过程名";
5.删除存储过程
  drop procedure 存储过程名;
6.变量类型
  6.1会话变量
   show session variables like "%%";	//查看会话变量
   set session ...;	//设置会话变量
  6.2全局变量
   show global variables like "%";	//查看全局变量
   set global ...; 	//设置全局变量
  6.3用户变量
    select max(uid) into @变量名 from user;	//使用sql命令查询结果赋值
    set @变量=5;	//自定义变量
    select @变量;	//查询变量
  6.4局部变量declare
    -多个变量时需提前定义declare，顺序赋值
    delimiter //
    create procedure db9.p1()
    begin 
    declare j int;
    declare k char(5);
    set j=5,k="lxf";
    select j,k;
    end
     //
    delimiter ;
7.参数类型  
  in类型:给存储过程传递数据
    	delimiter //
	create procedure db9.p1(in x char(20))
	begin
	select name from db9.user where name=x;
	end
	//
	delimiter ;
	call db9.p1("root");
  out类型:接受从存储过程输出的数据
   	delimiter //
	create procedure db9.p1(in x char(20),out y int)
	begin
	select count(name) into y from db9.user where shell=x;
	select y;
	end
	//
	delimiter ;
	call db9.p1("root",@x);	//out类型需要用变量占位	
  inout类型:前2者结合
    	delimiter //
    	create procedure db9.p1(inout x char(30))
    	begin
    	select name,shell from db9.user where shell=x;
    	select count(*) into x from db9.user;
    	select x;
    	end
    	//
    	delimiter ;
    	set @x="/sbin/nologin";
    	call db9.p1(@x);
8.算术运算
  +、-、*、/、%、DIV(整除运算)
三、流程控制
1.条件测试
  1.1数值比较
    ==、>、>=、<、<=、!=、between .. and ..
  1.2逻辑比较、范围、空、非空、模糊、正则
    or、and、!
    in ..、not in ..
    is null、is not null
    like
    regexp
2.选择结构
  2.1单分支
   if 条件测试 then
       代码;
   end if;
  2.2双分支
   if 条件测试 then
        代码;
   else
      	代码;
   end if;
  2.3条件循环while(先判断再执行,条件不成立时结束循环)
   while 条件测试
   do
      	代码;
   end while;
  2.4死循化loop
   loop
     	代码;
   end loop;
  2.5条件式循环repeat(先执行再判断，条件成立时结束循环)
   repeat
    	代码;
   	until 条件判断
   end repeat;
3.控制循环的执行
  -leave 标签名	//跳出循环
  -iterate 标签名	//放弃本次循环，执行下一次循环
##########################################################################
Day05
一、分库分表
1.分库分表概念
  将存放在一个数据库(主机)中的数据，按照特定方式进行拆分，分散存放到多个数据库(主机)中，以达到分散单台设备负载的效果
2.垂直分割
  -将单个表，拆分成多个表，分散到不同的数据库
  -将单个数据库的多个表进行分类，按业务类别分散到不同数据库上
3.水平分割
  -按照表中某个字段的某种规则，把表中的许多记录按行切分，分散到多个数据库中
4.mycat简介
  4.1是基于java的分布式数据库系统中间层，为高并发环境分布式访问提供解决方案
    -支持JDBC形式连接
    -支持MySQL、Oracle、Sqlserver、Mongodb等
    -提供数据读写分离服务
    -可以实现数据库服务器的高可用
    -提供数据分片服务
    -基于阿里巴巴Cobar进行研发的开源软件
    -适合数据大量写入的存储需求
  4.2分片规则
    -枚举法 sharding-by-intfile
    -固定分片 rule1
    -范围约定 auto-sharding-long
    -求模法 mod-long
    -日期列分区法 sharding-by-date
    -通配取模 sharding-by-pattern
   -ASCII码求模通配 sharding-by-prefixpattern
    -编程指定 sharding-by-substring
    -字符串拆分hash解析 sharding-by-stringhash
    -一致性hash sharding-by-murmur
  4.3工作过程
    -先解析这个sql查找涉及到的表
    -然后看此表的定义，如果有分片规则，则获取sql里分片字段的值，并匹配分片函数，获得分片列表
    -然后将sql发往这些分片去执行
    -最后收集和处理所有分片结果数据，并返回到客户端
5.配置mycat(端口号8066)
  5.1装包java环境包，mycat
  5.2配置文件
    5.2.1目录结构说明
     -bin		//mycat命令
     -catlet	//扩展功能
     -conf		//配置文件
     -lib		//系统运行时使用的jar文件
     -log		//mycat启动日志和运行日志
     -wrapper.log	//mycat服务启动日志
     -mycat.log	//记录sql脚本执行后的报错内容
    5.2.2重要配置文件说明
     -server.xml	//设置连mycat的帐号信息
     -schema.xml	//配置mycat的真实库表
     -rule.xml	//定义mycat分片规则
    5.2.3配置标签说明
     -<user>...</user>		//定义连mycat用户信息
     -<datanode>...</datanode>	//指定数据节点
     -<datahost>...</datahost>	//指定数据库地址机用户信息
    5.2.4修改配置文件server.xml
     <user name="test">		//连接mycat用户名test
        <property name="password">test</property>	//连接密码test
        <property name="schemas">TESTDB</property>  //客户端显示的库名TESTDB
     </user>
    5.2.5修改配置文件schema.xml
      <schema name="TESTDB" ...>	//对应server.xml中库名
      <table ... dataNode="dn1,dn2" rule="auto-sharding-long" />  //设置数据库名称dn1,dn2... 和算法
      <dataNode name="dn1" dataHost="localhost1" database="db1" />  //定义分片使用的库
      <writeHost host="hostM1" url="192.168.4.54:3306" user="root" password="123456">	//指定数据库的地址和登陆密码
      </writeHost>
6.数据库机台授权登陆用户
  grant all on *.* to root@"%" identified by "密码"
7.修该数据库配置不区分表名大小写
  lower_case_table_names=1
8.启动服务
  mycat start
  ss -antulp | grep 8066	//查看服务是否启动
  ps -C java
9.测试服务
  9.1在客户端连接分片服务器
    mysql -u用户名 -p密码 -hIP地址 -P端口号
  9.2创建表，分片字段需查询相应的算法
二、MySQL优化
1.调优思路
  升级硬件		CPU、内存、硬盘
  加大网络带宽		付费加大带宽
  调整mysql服务运行参数	并发连接数、连接超时时间、重复使用的进程数...
  调整与查询相关的参数	查询缓存、索引缓存...
  启用慢查询日志	slow-query-log
  网络架构不合理	调整网络架构
2.性能调优
  2.1硬件
   uptime查看CPU使用情况
   free查看内存使用情况
   top第三行wa表示等待速度，反映硬盘速度
  2.2带宽
  2.3并发及连接控制
   -max_connections	允许的最大并发连接数
    show variables like "%conn%";	//查看与连接有关的变量
    show global status like "%conn%";	//查看与连接有关全局状态
     最大连接数计算公式：
    Max_used_connections(最大并发连接数)/max_connections=85%
    flush status;	//刷新当前状态
    
   -connect_timeout	等待连接超时，默认10秒，仅登陆时有效
    show variables like "%timeout%";	//查看与超时相关的变量
    innodb_lock_wait_timeout 	//死锁等待超时时间
    
   -wait_timeout		等待关闭连接的不活动超时秒数，默认28800秒(8小时)
   	 防止大量写入中断开连接
  2.4缓存参数控制(默认8M，从物理内存中划分)
   key_buffer_size	//用于myisam引擎的关键索引缓存大小(单位为字节)，加快查询
   sort_buffer_size	//为每个要排序的线程分配此大小的缓存空间，加快查询速度
   read_buffer_size	//为顺序读取表记录保留的缓存大小，加快查询速度
   thread_cache_size	//允许保存在缓存中被重用的线程数量，加快处理速度
   table_open_cache	//为所有线程缓存的打开的表数量，加快处理速度
3.查询优化 
  3.1常见日志种类
    tail -f 文件名	//时时查看文件消息
     -错误日志  记录启动/运行/停止过程中的错误消息	log-error=[自定义名称]
     -查询日志  记录客户端连接和增删改查操作	
      general-log(默认名:主机名.log) 
      general-log-file=名称
     -慢查询日志  记录耗时较长或不使用索引的查询操作  
      slow-query-log(默认名:主机名-slow.log)
      slow-query-log-file=名称
      long-query-time=超时时间(默认10s)
     统计慢查询日志信息:mysqldumpslow 日志文件
  3.2查询缓存(默认1M，从物理内存划分):缓存曾经查找过的记录
   show variables like "query_cache%";	//查询缓存信息
   query_cache_size	//查询缓存大小
   query_cache_type	//查询缓存开关，默认off
   show global status like "qcache%";	//查看当前查询缓存统计
   Qcache_hits		//在查询缓存中找到的次数
   Qcache_inserts		//接受到查询的总次数

Day01-05
总结:
部署mysql主从同步:
配置master
配置slave
主从同步工作原理: IO线程  SQL线程
主从同步结构模式: 一主一从  一主多从  主从从  主主结构
主从同步常用配置参数: log_slave_updates允许链式复制(主从从结构)
主从同步复制模式: 异步(默认)  全同步  半同步

数据读写分离  [maxscale  mysqlproxy  mycat]  mysql中间件

MHA软件部署mysql高可用集群  [MHA软件 + Mysql一主多从]

数据分片  mycat软件

mysql多实例     mysql性能优化   mysql视图   mysql存储过程
#######################################################################
Day01

关系性数据库管理系统   RDBMS (MySQL/Oracle/DB2/SQL Server...)
非关系性数据库管理系统 NoSQL (Redis/MongoDB/Memcached/CouchDB/Neo4j/FlockDB...)
NoSQL
  -意思是"不仅仅是SQL"
  -泛指非关系性数据库
  -不需要预先定义数据存储结构
  -表的每条记录都可以有不同的类型和结构
  
一、部署Redis服务
  1.介绍
   -远程字典服务器Remote Dictionary Server
   -是一款高性能的(Key/Values)分布式内存数据库
   -支持数据持久化，可以把内存里的数据保存到硬盘中
   -也支持list、hash、set、zset数据类型
   -支持master-slave模式数据备份
   -中文网站www.redis.cn
  2.安装redis软件包
  3.初始化配置文件
   ./utils/install_server.sh
   -Port           : 6379
   -Config file    : /etc/redis/6379.conf
   -Log file       : /var/log/redis_6379.log
   -Data dir       : /var/lib/redis/6379
   -Executable     : /usr/local/bin/redis-server
   -Cli Executable : /usr/local/bin/redis-cli
    -默认端口
    -默认主配置文件
    -默认日志文件
    -默认数据库目录
    -默认服务启动程序
    -默认命令行连接命令
  4.启动/停止/当前状态服务
   /etc/init.d/redis_6379 start/stop/status	
  5.查看服务是否启动
    ss -antulp | grep 6379
    ps -C redis-server
  6.本机连接
    redis-cli
  7.常用操作指令
   -set 变量名 值 	//存储数据
   -get 变量名	//查看变量值
   -select 0-15	//默认16个库，切换库
   -keys *		//查看当前库所有数据
   -keys ??		//查看当前库2个字符的数据
   -exists 变量名	//测试变量是否存在，返回1表示存在，0表示不存在
   -ttl 变量名	//查看变量生存时间
   -type 变量名	//查看变量类型
   -move 变量名 目标库号	//移动变量到其他库
   -expire 变量名 时间	//设置变量有效时间(单位秒)
   -del 变量名	//删除变量
   -flushdb		//只删除当前库的所有数据
   -flushall	//删除所有库的所有数据
   -save 		//马上保存所有变量，在/var/lib/redis/6379/dump.rdb中
   -shutdown	//关闭redis服务
  8.配置文件解析/etc/redis/6379.conf
   8.1数据单位
     1k => 1000 bytes
     1kb => 1024 bytes
     1m => 1000000 bytes
     1mb => 1024*1024 bytes
     1g => 1000000000 bytes
     1gb => 1024*1024*1024 bytes
   8.2常用配置选项
    -port 6379		//端口
    -bind 127.0.0.1 ...	//IP地址
    -tcp-backlog 511	//tcp已经连接和正在连接的总数511
    -timeout 0		//连接超时时间0秒
    -tcp-keepalive 300	//长连接时间300秒，查看连接是否还在
    -daemonize yes	//守护进程方式运行(保持内存中有一个进程运行此服务)
    -databases 16		//数据库的个数
    -logfile /var/log/redis_6379.log	//pid日志文件
    -maxclients 10000	//并发连接数量
    -dir /var/lib/redis/6379	//数据库目录
   8.3内存管理MEMORY MANAGEMENT
    8.3.1内存清除策略
     -volatile-lru 	//最近最少使用(针对设置了ttl的变量有效)
     -allkeys-lru		//删除最少使用的变量(所有key)
     -volatile-random	//在设置了ttl的key里随机移除
     -allkeys-random	//随即移除key
     -volatile-ttl (minor ttl)	//移除最近过期的key
     -noeviction		//不删除，写满时报错
    8.3.2默认设置
      -maxmemory <bytes>	//最大内存
      -maxmemory-policy noeviction 	//定义使用策略：不删除
      -maxmemory-samples 5	//选取模版数据的个数(针对lru和ttl策略)
  9.设置连接访问
    bind		//连接地址
    port		//指定端口,修改端口后上述脚本无法停止服务
    requirepass	//连接密码
    redis-cli -h 连接IP地址 -p 端口号 -a 密码 [shutdown]  //连接数据库格式[关机]
     修改脚本/etc/init.d/redis_6379   //也可以关机
     若未输入密码，进入数据库后需输入:auth 密码
二、部署LNMP+Redis
  1.部署Nginx，修改配置文件使其支持PHP
  2.部署Mysql
  3.部署Php服务
  4.启动服务
  5.部署Redis
  6.配置php支持Redis
    php -m	//查看php支持的模块
     安装php-redis,依赖包:autoconf,automake,php-devel
    phpize	//检查php安装环境
    php-config	//检查php配置信息脚本
    ./configure --with-php-config=/usr/bin/php-config
    make && make install
     修改php配置文件/etc/php.ini
     extension_dir = "模块路径"
     extension = "模块.so文件"
     重起php-fpm服务
  7.测试
   编写php文件连接数据库
  <?php
   $redis=new redis();
   $redis->connect("127.0.0.1","6379");
   $redis->set("school","tarena");
   echo $redis->get(school);
  ?>
######################################################################
Day02

一、创建Redis集群
1.部署Redis
2.启用集群模式
  2.1所有集群修改配置文件/etc/redis/xxx.conf
    cluster-enabled yes		//启用集群
    cluster-config-file xxx	//指定集群信息存放文件
    cluster-node-timeout 5000	//请求超时5秒
  2.2查看集群信息(进入数据库中查看)
    cluster info		//查看本机在集群中的信息
      cluster_state:fail  //未连接时失败状态
    cluster nodes		//查看集群信息
      myself,master - 0 0 0	//默认自己是master,0表示正常,否则配置文件错
3.选一台做管理主机
  3.1部署ruby脚本运行环境(此脚本用ruby语言编写的)
   安装ruby，rubygems，ruby-devel
  gem install redis-3.2.1.gem	//管理软件
  3.2创建集群
   在redis-4.0.8/src下寻找redis-trib.rb脚本
   mkdir /root/bin	//当前环境变量中的一个
   cp redis-trib.rb /root/bin/		//方便使用，类似快捷方式
   //创建的是高可用集群，需3台主库起
   redis-trib.rb create --replicas 1 host:port host:port ...	
   --replicas 数字 //给每一个主库设置几个从库
4.所有机台查看集群信息
  cluster info
  cluster nodes
  info replication	//在数据库中查看是否是从库
5.客户端测试集群
  redis-cli -c -h ip地址 -p 端口		//加-c才可以连接集群
6.检查集群情况
  redis-trib check 管理主机ip:端口
报错排查！！！
创建集群时提示槽信息对不上，nodes文件的问题
注意：连接到集群，写和查需在主库上进行，集群会分布式存储数据，所有服务器都可以查到数据
      但实际每台服务器的数据都不相同
7.原理
 变量通过crc16做哈希运算得出的值与16384取余得出的值和主库的哈希槽对比，在范围内就储存
8.高可用性：主库宕机，从库会自动继承主库，修好后会自动成为从库并同步现在主库的信息

二、管理集群
redis-trib.rb 选项 参数
常用选项：
  -add-node		//添加master主机
  -check		//检测集群
  -reshard		//重新分片
  -add-node --slave	//添加slave主机
  -del-node		//删除主机
1.向集群中添加新的Redis服务器
 1.1添加master角色的Redis服务器
  把主机添加到集群里
    redis-trib.rb add-node 新主机IP:端口好 集群任意主库IP:端口
  分配hash slots
    redis-trib.rb reshard 192.168.4.51:6351	//重新分配哈希槽
    指定移除hash槽个数，指定接受hash槽主机ID，移除hash槽主机ID
 1.2添加slave角色的Redis服务器
   redis-trib.rb add-node --slave [--master-id id值](不指定默认分配给从库最少的主机) ip地址:端口 集群任意主库IP:端口
2.从集群删除Redis服务器
 2.1移除slave主机
   redis-trib.rb del-node 集群主库IP:端口 移除主机ID
 2.2移除master主机
   重新分片释放占用的hash槽
    redis-trib.rb reshard 192.168.4.57:6357	
   指定移除hash槽个数，指定接受hash槽主机ID，指定移除hash槽主机ID
    redis-trib.rb del-node 集群主库IP:端口 移除主机ID
3.把修复的Redis服务器重新添加到集群中
  3.1清空其他集群信息cluster reset
  3.2重置/var/lib/redis/6379/node-xxx.conf文件内容
  3.3添加即可
三、集群使用总结
  功能:实现数据分布式存储的高可用集群
##########################################################################
Day03

一、Redis主从同步  
  1.结构模式
    一主一从、一主多从、主从从
  2.工作原理
   2.1从库向主库发送sync请求
   2.2主库开新进程收集修改数据的命令
   2.3将收集数据的文件传送给从库
   2.4从库接收后，加载到内存中完成首次完全同步
   2.5后续产生新数据时，将新数据陆续传给从库，完成增量同步
  3.主从复制缺点
    -网络繁忙，同步数据会有延时问题
    -系统繁忙，同步数据会有延时问题
  4.主从同步配置
    4.1临时配置
      info replication	//查看主从配置信息
      slaveof 主库IP地址  端口号	//数据库下配置主从同步命令
      取消临时配置
      -slaveof no one	//数据库命令行下，还原为主库，临时有效
        -重起服务
        -修改配置文件，重起服务
    4.2永久配置/etc/redis/xxx.conf
      slaveof 主库IP地址  端口号 	//修改此配置，重起服务
  5.配置用户认证的主从同步
    主库开启用户认证
     requirepass 密码	
    修改从库配置文件
     masterauth 主库密码
  6.配置哨兵模式(主库宕机后，从库会自动升级为主库,再次将原先主库加入后会自动成为当前主库的从库并同步数据)
    创建配置文件/etc/sentinel.conf
    bind 监控地址(0.0.0.0代表本机所有网卡地址)
    sentinel monitor 自定义名字 主库IP 主库端口 票数
    sentinel auth-pass 与监控名字相同 密码
    启动服务
     redis-sentinel /etc/sentinel.confs
二、持久化之RDB
 1.Redis数据库文件，全称Redis DataBase
   -数据持久化方式之一
   -按照指定时间间隔，将内存中的数据集快照写入硬盘
   -术语叫Snapshot快照
   -回复时，将快照文件直接读入内存
  2.相关配置参数
   2.1文件名
    -dbfilename "dump.rdb"  	//文件名
    -save ""	//禁用RDB
   2.2数据从内存保存到硬盘的频率
     -save 900 1		//900秒内且有1次数据修改
   2.3手动立刻存盘
    -save	//阻塞写存盘(保存时不允许修改)
    -bgsave	//不阻塞写存盘(系统默认存盘方式)
   2.4压缩(消耗CPU)
     rdbcompression yes|no	//默认开启
     在存储快照后，使用crc16算法做数据校验
      rdbchecksum yes|no		//默认开启
    bgsave出错时停止写操作
      stop-writes-on-bgsave-error yes|no	//默认开启
  3.使用RDB文件恢复数据
    3.1备份数据
      拷贝dump.rdb文件即可
    3.2恢复数据
      清空数据库后停止服务时，redis会将内存中清空的数据读入硬盘
      需先停止服务后
      将dump.rdb文件拷贝回原目录/var/lib/redis/6379/
      再重起服务即可
 4.RDB优点/缺点
   优点:
     -高性能的持久化实现:创建一个子进程来执行持久化，先将数据写入临时文件，持久化过程结束后，再用这个临时文件替代上次持久化好的文件；过程中主进程不做任何I/O操作
     -比较适合大规模数据恢复，且对数据完整性要求不是非常高的场合
   缺点:
     -意外宕机时，最后一次持久化的数据会丢失
     -访问量大的情况下，性能会降低
三、持久化之AOF
  1.只做追加操作的文件，Append Only File
    -记录redis服务所有写操作
    -不断的将新的写操作，追加到文件的末尾
    -使用cat命令可以查看文件内容
  2.相关配置参数
    2.1文件名
     -appendfilename "appendonly.aof"	//指定文件名
     -appendonly yes	//启用aof，默认no
    注意：当AOF和RDB同时开启时，系统会优先读取AOF文件内容
   2.2AOF文件记录写操作的方式 
     -appendfsync always	//有新写操作立即记录(将命令记录aof文件同时给rdb一份)
     -appendfsync everysec  //每秒记录一次(默认方式)(将命令记录aof文件同时给rdb一份)
     -appendfsync no	//从不记录(命令只记录在aof文件中)
    2.3日志文件过大，日志重写
     -redis会记录上次重写时AOF文件的大小
       -默认配置当aof文件是上次rewrite后大小的1倍且文件大于64M时触发
      auto-aof-rewrite-percentage 100	//重写比例100%(64mb的1倍)
      auto-aof-rewrite-min-size 64mb	//aof文件64mb后触发日志重写
    2.4把文件恢复到最后一次正确操作
      redis-check-aof --fix appendonly.aof
  3.使用AOF文件恢复数据同RDB相同
  4.AOF优点/缺点
    优点:
      -可以灵活设置持久化方式，同步持久化appendfsync always或异步持久化appendfsync everysec
      -出现意外宕机时，仅可能丢失1秒的数据
    缺点:
      -持久化文件的体积通常会大于RDB方式  
      -执行fsync策略时的速度可能会比RDB方式慢
四、数据类型
 1.String字符串
   1.1字符串操作
    *set key value [ex seconds][px milliseconds][nx|xx]
     -ex单位为秒(变量过期时间)，px单位为毫秒，nx表示变量不存在才赋值，xx存在也赋值
    *setrange key offset value
       -从偏移量开始更改key特定位的值
      -set a "hellow world"
      -setrange a 6 redis	//改为hello redis
    *strlen key 统计子串长度
    *append key value
       -存在则追加，不存在则创建key及value，返回key长度
    *setbit key offset value
       -对key所存储字串，设置或清除特点偏移量上的位(bit)
     -value值可以为1或0，offset为0～2^32之间
     -key不存在，则创建新key
    *bitcount key
       -统计字串中被设置为1的比特位数量
    *decr key
       -将key中的值减1，key不存在则先初始化为0，再减1
    *decrby key decrement
       -将key中的值，减去decrement
       -只能做整数运算
    *get key
       -返回key存储的字符串值，若不存在则返回null
       -若key值不是字串，则返回错误，get只能处理字串
    *getrange key start end
       -返回字串值中的子字串，截取范围为start和end
       -负数偏移量表示从末尾开始计数，-1表示最后一个字符，-2表示倒数第二个字符
       -从0开始计数
    *incr key
       -将key中的值加1，key不存在则先初始化为0，再加1
       -主要应用为计数器
    *incrby key increment
       -将key中的值，加increment
       -只能做整数运算
    *incrbyfloat key increment
       -为key中所储存的值加上小数increment
    *mget key [key...]
       -可以获取多个key值，空格分隔，具有原子性
    *mset key value [key value ...]
       -设置多个key和值，空格分离，具有原子性
小结:set/setrange/strlen/append/setbit/bitcount/decr/decrby/get/getrange/incr/incrby/incrbyfloat/mget/mset
 2.List列表
   2.1列表简介
   -Redis的list时一个字符队列
     -先进后出
     -一个key可以有多个值
  2.2List列表操作
    *lpush key value [value...]
       -将一个或多个值value插入到列表key的表头
       -变量存在则追加写入，不存在则创建变量
    *lrange key start stop
       -从开始位置读取key的值到stop结束
    *lpop key
       -移除并返回列表头元素数据,key不存在则返回nil
    *llen key
       -返回列表key的长度
    *lindex key index
       -返回列表中的第index个值
    *lset key index value
       -将列表中的index位置的值修改为value
    *rpush key value[value...]
       -将value插入到key的末尾
    *rpop key
       -删除并返回key末尾的值
    *lrem key count value
       -删除列表中count个值为value的元素
     -count=0删除所有,count>0从左到右删,count<0从右到左删
    *linert key before | after pivot value
       -在列表中的pivot之前或之后插入value值
小结:lpush/lrange/lpop/rpop/lset/llen/lindex/rpush/lrem/linsert
 3.Hash表
   3.1简介
     -是一个string类型的field和value的映射表
     -一个key可对应多个field,一个field对应一个value
     -将一个对象存储为hash类型,较于每个字段都存储成string类型更能节省内存
   3.2基本操作
    *hset key field value
       -将hash表field值设置为value
    *hget key field
       -获取hash表中field的值
    *hmset key field value [field value ...]
       -同时给hash表中的多个field赋值
    *hmget key field [field...]
       -返回hash表中多个field的值
    *hkeys key
       -返回hash表中所有field名称
    *hgetall key
       -返回hash表中所有key名和对应的值列表
    *hvals key
       -返回hash表中所有key的值
    *hdel key field [field...]
       -删除hash表中多个field的值,不存在则忽略
小结:hset/hget/hmset/hmget/hgetall/hkeys/hvals/hdel

Day01-03  Redis服务使用
部署Redis数据库服务器
LNMP+Redis
数据库常用管理命令 set get keys ttl type del expire...
配置文件解析 
Redis集群
Redis服务主从同步
哨兵服务
Redis服务数据持久化方式 AOF RDB  数据备份与恢复
Redis数据类型  string list hash...
##########################################################################
Day04

一、部署MongoDB服务
  1.概述
    -介于关系数据库和非关系数据库之间的产品
    -一款基于分布式文件存储的数据库，只在为web应用提供可扩展的高性能数据存储解决反感
    -将数据存储为一个文档(类似于Mysql的记录)，数据结构由键值(key=>value)对组成
    -支持丰富的查询表达，可以设置任何属性的索引
    -支持副本集，分片
  2.搭建MDB服务
   2.1装包
     解压mongodb-linux-x86_64-rhel70-3.6.3.tgz
    mkdir /usr/local/mongodb
    cp -r mongodb-linux-x86_64-rhel70-3.6.3/bin /usr/local/mongodb
   2.2配置
     创建目录etc(配置文件)  log(日志文件)  data/db(存放数据)
    mongod --help	//查看帮助信息
     创建主配置文件vim /usr/local/mongodb/etc/mongodb.conf
     logpath=/usr/local/mongodb/log/xxx.log	//日志文件路径
     logappend=true	//以追加方式记录日志信息	
     dbpath=/usr/local/mongodb/data/db	//数据库名录
     fork=true	//守护进程方式运行
   2.3起服务
    ../mongod -f /usr/local/mongodb/etc/mongodb.conf [--shutdown停止服务]
     服务名:mongod
     端口号:27017
     默认IP地址:lo环回地址
   2.4客户端连接
    /usr/local/mongodb/bin/mongo	//连接本地服务器
  3.设定服务IP地址和端口号
   3.1停止原服务
   3.2配置文件中添加
     port=端口
     bind_ip=IP地址
   3.3启动服务
      命令同上
   3.4连接服务
    /usr/local/mongodb/bin/mongo --host IP地址 --port 端口号
二、MongoDB基本使用
  1.常用管理命令
   1.1数据库管理
    -show dbs	//查看已有的库
    -db	//显示当前所在的库
    -use 库名 	//切换库，若不存在延时创建库(不马上创建库)
    -show collections 或 show tables	//查看库下已有集合
    -db.dropDatabase()	//删除当前所在的库(严格区分大小写)
   库命名规范
    -不能是空字符串("")
    -不得含有''(空格)、.、$、/、\和\0(空字符)
    -应全部小写
    -最多64字节
   1.2集合管理
     -db.集合名.drop()	//删除集合，返回值true/fales
     -db.集合名.save({文档名:值,...})	//创建集合
    集合命名规范
     -不能是空字符串("")
     -不能含有\0字符(空字符)，此字符表示集合的结尾
     -不能以"system."开头，这是为系统集合保留的前缀
     -用户创建的集合名字不能含有保留字符
   1.3文档管理
     -db.集合名.find()	//显示集合中的所有
     -db.集合名.count()	//统计集合条目数量
     -db.集合名.insert({文档名:值,...})	//插入文档
     -db.集合名.find({条件})	//条件查找
     -db.集合名.findOne()		//查看第一条文档
     -db.集合名.remove({条件})	//删除匹配文档
     -db.集合名.remove({})	//删除所有文档
  2.基本数据类型
    2.1字符string/布尔bool/空null
     字符串string
      -UTF-8字符串都可以表示为字符串类型的数据
     布尔bool
       -布尔类型只有两个值true和fales
     空null
       -用于表示空值或者不存在的字段
    2.2数值/数组array
     数值
      -shell默认使用64位浮点型数值
      -NumberInt(4字节整数) {x:NumberInt(数字)} //若存小数，默认舍取小数位
      -NumberLong(8字节整数) //不能存小数
     数组array
       -数据列表或数据集可以表示为数组 {x:["a","b","c"]}
    2.3代码/日期/对象
     代码
       -查询和文档中可以包括任何JavaScript代码{x:function(){/*代码*/}}
     日期
       -日期被存储为自新纪元(1970-01-01)以来经过的毫秒数，不含时区{x:new Date()}
     对象
       -对象id是一个12字节的字符串，是文档的唯一标识{x:ObjectId()}
    2.4内嵌/正则表达式
     内嵌
       -文档可以嵌套其他文档，被嵌套的文档作为值来处理{x:{a:xx,...}}
     正则表达式
       -查询时，使用正则表达式作为限定条件{x:/正则表达式/}
  3.数据导入导出
    3.1导出
     mongoexport [--host IP地址 --port 端口] \
     -d 库名 -c 集合名 [-q '{条件}']-f 字段名1，字段名2 \
     --type=文件类型 > /目录/文件.xxx
     注意：csv格式必须指定字段名列表!!!
    3.2导入
     mongoimport --host IP地址 --port 端口 \
     -d 库名 -c 集合名 --type=文件类型 [--headerline] [--drop] 导入文件
     注意：1.导入数据时，若库和集合不存在，则系统先创建库和集合后再导入数据;
           2.若库和集合已存在，则已追加的方式导入数据到集合里;
           3.使用--drop选项可以删除原数据后导入新数据，--headerline 忽略标题(csv格式)
  4.数据备份与恢复
  admin	//用户授权信息
  config	//数据库分片信息(默认不会备份)
  local	//本地配置文件(默认不会备份)
   备份
    mongodump [--host IP地址 --port 端口]	//备份所有库到当前目录
    -d 数据库名 -c 集合名 -o 目录	//指定备份的库/集合到指定目录
     查看备份文件bson文件内容
      bsondump xxx.bson
   恢复
    mongorestore --host IP地址 --port 端口 [-d 数据库名 -c 集合名] 备份目录名
#########################################################################
Day05

一、MongoDB副本集(高可用集群)
 1.环境准备
  1.1副本集介绍(也称MongoDB复制)
    -指在多个服务器上存储数据副本，并实现数据同步
    -提高数据可用性、安全性、方便数据故障恢复
  1.2复制原理
    -至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余是从节点，负责复制主节点数据
    -常见搭配:一主一从、一主多从
    -主节点记录所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致
  1.3实现方式
   1.3.1主从复制模式
    1)主从复制
      -启动一台服务器时加上"-master"参数，作为主节点
      -启动其他服务器时加上"-slave"和"-source"参数，作为从节点
    2)主从复制优点
      -从节点可以提供数据查询，降低主节点的访问压力
      -由从节点执行备份，避免锁定主节点数据
  1.3.2Replica Sets副本集
     -从1.6版本开始支持，优于之前的replication
     -支持故障自动切换、自动修复成员节点，降低运维成本
    -Replica Sets副本集的结构类似高可用集群
 2.配置Replica Sets
   1)启用副本集模式并定义名称repliSet=rs1
    2)配置副本集节点列表(在副本集中随便连接一台主机数据库)
      config(自定义名称)={
        _id:"rs1(与副本集定义名称相同)"，
        members:[
          {_id:0,host:"IP地址:端口"},	//可以设定优先级priority,越小越优先
          {_id:1,host:"IP地址:端口"},
          {_id:2,host:"IP地址:端口"},
          ...
          ]
        }
      默认都是从库，从库上不可以做任何操作
      若输入错误，需注释配置文件repliSet，进入数据库删除local库，重起服务(还原)，
      然后从头再配置，注意此方法需所有副本集都要做！！！
      rs.help()	//副本集帮助
      rs.conf()	//查看副本集配置信息
    3)初始化副本集rs.initiate(config(自定义的名字))
    4)查看副本集信息
    rs.status()	//查看副本集状态信息
    rs.isMaster()	//查看当前主机是否时master库
    5)客户端验证
    db.getMongo().setSlaveOk()	//允许从库查询数据库信息
    rs.slaveOk()	//初步测试，效果同上
     宕机的主库再加入到副本集会自动同步数据当前主库上的数据
    高可用:主库宕机后从库自动切换为主库
      切换过程：1.确认主库宕机
      	        2.查看自己是否有资格成为主库
      	        3.谁的数据与主库最接近才可以竞选主库
      	        4.以上满足后30秒后才可以切换成为主库
  3.将副本集还原为独立的机器
    3.1停止服务
    3.2配置文件删除副本集信息
    3.3启动服务，连接数据库，删除local库
    3.4重起服务
二、文档管理
  1.插入文档
    db.集合名.save({key:value,...})
      -集合不存在时创建集合，然后再插入记录
     -_id字段值存在时，修改文档字段值
     -_id字段值不存在时，插入文档
      -一次只能插入一条记录
    db.集合名.insert({key:value,...})
      -集合不存在时创建集合，然后再插入记录
     -_id字段值存在时，放弃插入
     -_id字段值不存在时，插入文档
      -一次只能插入一条记录
    db.集合名.insertMany([{key:value,...},{key:value,...},...])
      -一次可以插入多条记录
      -其他用法同insert相同
  2.查询文档
    db.集合名.find()	//显示所有行,默认输出20行，超出输入it显示
    db.集合名.findOne()	//显示第一行
    db.集合名.find({条件},{key:0/1})
     //按条件显示，0表示不显示，1表示要显示，.pretty()水平输出,.count()统计个数
    db.userdb.find({shell:"/bin/bash"}	//满足条件所有字段都显示
    db.userdb.find({shell:"/bin/bash"},{_id:0})	//除_id字段都显示
    db.userdb.find({shell:"/bin/bash"},{_id:0,name:1,shell:1}) //只显示满足条件的name，shell字段
    db.userdb.find({},{name:1,uid:1})	//显示name，uid所有内容
     
    db.集合名.find().limit(数字)  //显示前几行
    db.集合名.find().skip(数字)	//跳过前几行
    db.集合名.find().sort({字段名:1/-1})	//1升序，-1降序
  3.更新文档
   db.集合名.update({条件},{修改的key})
    //默认将与条件匹配的第一行修改，且删除第一行其余未声明的字段
   db.集合名.update({条件},{$set:{修改的key}},false,true)
    //$set定义只修改字段的值，false,true表示与条件匹配的全部更改
      $unset删除与条件匹配的文档字段
   db.集合名.update({条件},{$inc:{key:数字}})  //字段值自增(正数)，自减(负数)
   db.集合名.update({条件},{$push:{数组名:值}})  //向数组中添加新元素，可以重复添加
   db.集合名.update({条件},{$addToSet:{数组名:值}}) //向数组添加新元素，不可重复
   db.集合名.update({条件},{$pop:{数组名:数字}})  //数字1删除数组尾部元素，-1删头部
   db.集合名.update({条件},{$pull:{数组名:值}})  //删除指定元素
  4.删除文档
    db.集合名.drop()	//删除集合的同时删除索引
    db.集合名.remove({})	//删除文档时不删除索引(可以加条件)
  5.匹配条件
    简单条件：db.集合名.find({key:value,...})  //一个做相等比较，多个表示逻辑与
    范围比较：-$in	在..里
           db.user.find({key:{$in:[value,...]}})
    	     -$nin 	不在...里
    	     db.user.find({key:{$nin:[value,...]}})
    	     -$or	或
    	     db.user.find({$or:[{key:value},{},...]})
    正则匹配：db.user.find({key:/正则/})
    数值比较：$lt、$lte、$gt、$gte、$ne
           db.集合名.find({uid:{$gte:10,$lte:20}},{_id:0})
    匹配null：db.集合名.find({key:null})
三、LNMP+MongoDB
  1.部署LNMP环境
  2.安装MongoDB
  3.安装php支持mongodb的模块
    源码编译:phpize
          which php-config
          ./configure  --with-php-config=路径
          make && make install
  4.指定模块路径和模块名
       vim /etc/php.ini
  5.重起php服务
  6.编写php脚本测试
  
LNMP+Mysql
1.访问数据库主机部署环境和支持模块
2.mysql数据库主机上提前建库建表,给访问主机授权用户 
3.书写php文件连接mysql数据库
  
Day01

一、Linux基本防护(系统管理部分知识的应用)
 用户账号安全
 cal	//查看日历
 1.设置账号有效期
   chage工具
     -d 0 用户	//强制修改密码
     -E yyyy-mm-dd 用户	//设置用户失效日期(-1取消)
 2.账号的锁定/解锁
   passwd命令
     -l	//锁定用户
     -u	//解锁
     -S	//查看用户状态
 3.强制定期修改密码
   配置文件/etc/login.defs
     -对新建的用户有效
   用户家目录
   .bash_logout	//用户退出时进行的操作
   .bash_history	//用户操作的所有记录
   .bashrc		//别名文件
   .bash_profile	//环境变量
    将所需的软件包放入/etc/skel/目录下，后续新增的用户家目录都会有此包
 4.伪装登陆提示
   配置文件/etc/issue、/etc/issue.net
     -分别适用本地、远程登陆
     -默认会提示系统版本、内核等信息
 文件系统安全
   1.程序和服务控制
     系统服务工具：systemctl(红帽7版本)、chkconfig(红帽6版本)
     chkconfig httpd off/on	//开机不启/自启
   2.锁定/解锁保护文件
     exit3/ext4的文件属性控制
        -命令：chattr、lsattr
      +、-、=控制方式
        -属性i：不可变(immutable)
        -属性a：仅可追加(append only)
二、用户切换与提权(su 与 sudo)
 1.su切换用户身份
   -快速切换用户身份
   -普通用户执行时，需要目标用户的口令
  -root执行时，不需要口令 
   su 用户	//切换用户时，环境变量不会变,umask=002(目录),umask=113(文件)
   su - 用户	//切换用户时，环境变量会一起变,umask=022(目录),umask=133(文件)
   su		//直接切换到root用户
   su - 用户 -c 命令 	//切换到用户时，执行命令
 2.sudo提升执行权限
   2.1提权的基本用法
     -只有操作系统管理员root有提权权限
     -提权是让系统的普通用户有执行root用户命令的权限
   2.2命令格式
     -用法1:sudo 特权命令		//执行自己的特权命令
     -用法2:sudu -u 目标用户 特权命令  //执行目标用户有的特权命令
   2.3查看自己的sudo授权
    -sudo -l
   2.4配置sudo授权
     修改方法:
       -visudo
       -vim /etc/sudoers
     文件记录格式
       (加%表示用户组)用户	主机列表=(省略时表示root身份)命令列表
       tom  localhost(回环地址名字),mysql-50(hostname名字)=\
       /usr/bin/systemctl * httpd(*表示所有),\
       /usr/bin/vim /etc/httpd/conf/httpd.conf,...
       %admgrp  xxx=命令, nopasswd:all	//提权用户不用输入密码
       !/usr/bin/命令	//表示取反,此命令不可用
  3.记录提权用户的时用情况
     Defaults logfile="/var/log/sudo" //配置文件/etc/sudoers中添加
  4.别名设置
    -提高可重用性,易读性
    -简化配置,时用记录更有条理
    -配置文件中有模版,可直接修改,别名必须大写
    -用户、主机名、命令...都可以设置别名
    rpm -e --nodeps 软件包	//卸载时不卸载依赖包
三、SSH访问控制(服务常用配置项目 加深密钥对认证登陆的使用)
  1.配置文件/etc/ssh/sshd_config
  *man 5 sshd_config	//帮助,详细解释
    -Port 5156	//改用非标准端口
    -Protocol 2	//启用ssh V2版本
    -ListenAddress IP地址	//只允许指定IP连接
    -PermitRootLogin no	//禁止root登陆
    -UseDNS no	//不解析客户机地址
    -LoginGraceTime 1m	//登陆限时(密码错误后限时)
    -MaxAuthTries 3	//每次连接最多认证次数(密码)
  2.黑/白名单配置/etc/ssh/sshd_config
    -AllowUsers 用户@网段/具体IP 用户(不跟IP表示所有) //设置用户白名单
    -AllowGroups	组名	//设置组白名单
    -DenyUsers ...	//设置用户黑名单
    -DenyGroups ...	//设置组黑名单
  3.口令认证登陆(用户名 登陆系统密码)默认方式
    PasswordAuthentication yes
    密钥对认证登陆
    PubkeyAuthentication yes
    AuthorizedKeysFile      .ssh/authorized_keys(公钥文件)
    将私钥传给其他主机也可以免密登陆,注意私钥权限755,公钥的影响
    ssh-add //密钥未生成成功时
四、SELinux安全防护
 1.1什么是SELinux
   Security-Enhanced Linux
      -一套强化Linux安全的扩展模块
      -美国国家安全局主导开发
    SELinux的运作机制
      -集成到Linux内核(2.6及以上)
      -操作系统提供可定制的策略、管理工具
  1.2.红帽的SELinux策略集
    SELINUXTYPE=targeted		//保护常用的服务，默认状态
    sestatus	//查看当前selinux状态
  1.3.模式控制
    1.3.1修改kernel启动参数
      -添加selinux=0 禁用
      -添加enforcing=0设置为允许模式
    1.3.2修改文件/etc/selinux/config
      -设置SELINUX=disable 禁用
      -设置SELINUX=permissive 宽松模式
      -设置SELINUX=enforcing 强制模式
    1.3.3临时修改(不可修改disabled状态)
     setenforce = 1	//强制模式
     setenforce = 0	//宽松模式
     getenforce		//查看
 2.SELinux策略设置
    2.1查看安全上下文
       -为文件/目录/设备标记访问控制属性
       -属性构成
         用户:角色:访问类型:选项...
    ls -Z	//查看文件/目录上下文属性
    ps -Z 	//查看服务上下文属性
    2.2修改安全上下文
      一般操作规律
        -移动的文件，原有的上下文属性不变
        -复制的文件，自动继承目标位置的上下文
        -新建的文档，自动继承父目录的访问类型
      修改访问类型
       chcon -t 访问类型 文件路径	//指定访问类型
       chcon -R -t 访问类型 目录	//递归修改
      重置安全上下文
        使用restorecon工具
           -恢复为所在位置的默认上下文属性
        -R 目录  	//递归修改
     2.3调整SELinux布尔值
       使用getsebool查看
       getsebool -a	//可列出所有布尔值
       使用setsebool设置
       setsebool -P ...	//永久更改
    2.4查看selinux报错信息(里面有解决办法)
     grep -i 'setroubleshoot' /var/log/messages | taile -1
 3.ftp命令行操作
    yum -y install ftp
    ftp 目标IP 	//进入ftp命令模式
    ls	//查看ftp目录下文件
    cd 目录	//切换ftp目录
    lcd 目录	//切换当前目录
    get 文件	//下载文件
    put 文件	//上传文件
  -SELinux以下两相布尔值会影响ftp下载上传
    allow_ftpd_anon_write 
    allow_ftpd_full_access
##########################################################################
Day02

一、GPG数据加密与解密 和 数字签名
 1.加密和解密
   发送方：明文->密文(加密的)
   接收方：密文->明文(解密的)
   1.1加密的目的及方式
     确保数据的机密性
      -对称加密：加密/解密用同一个密钥
      -非对称加密：加密/解密用不同的密钥(公钥，私钥)
     保护信息的完整性
      -信息摘要：基于输入的信息生成长度较短、位数固定的散列值
   1.2常见的加密算法
     对称加密：DES、AES
     非对称加密：RSA、DSA
    Hash散列技术，用于信息摘要：MDB、SHA(完整性校验)
  1.3GPG对称加密/解密
    gpg --help	//帮助
      -加密操作：gpg -c 文件
      -解密操作：gpg -d 文件
  1.4GPG非对称加密
    userb接收方：
      -创建密钥对：gpg --gen-key
      -导出公钥：gpg --export -a > /tmp/userb.pub 
      -使用私钥解密文件：gpg -d 加密文件 > 文件	//需输入创建密钥时的密码
    usera发送方：
      -导入公钥：gpg --import 公钥文件
      -使用公钥加密文件： gpg -e -r 创建公钥时真实用户名 文件
  1.5GPG做数字签名
    userb用户使用私钥做数字签名
      gpg -b 文件 	//给文件签名，生成.sig文件，需要私钥密码
       将原文件和.sig文件一起传给对方
    usera用户使用导入的公钥验证签名
      gpg --verify 文件.sig	//若原文件被改变，会提示文件损坏  
二、AIDE入侵检测系统
 1.装包aide
 2.修改配置文件/etc/aide.conf
   @@define DBDIR /var/lib/aide         //检测信息目录
   @@define LOGDIR /var/log/aide        //日志目录
   database=file:@@{DBDIR}/aide.db.gz	//用于对比的文件
   database_out=file:@@{DBDIR}/aide.db.new.gz  //检测到数据的存储文件名
   //一下内容为可以检查的项目（权限，用户，组，大小，哈希值等）
   #p:      permissions
   #i:      inode:
   #n:      number of links
   #u:      user
   #g:      group
   #s:      size
   #md5:    md5 checksum
   #sha1:   sha1 checksum
   #sha256:        sha256 checksum  
   FIPSR =  p+n+u+g+s+acl+selinux+xattrs+sha256 //别名,存储一系列命令
    !表示不检测此目录
    实验:注释99-312行,添加检测目录和方法/root/ FIPSR
 3.初始化检查
    aide --init	//检测信息放入/var/lib/aide/aide.db.new.gz
    vim命令存储文件/root/.viminfo
     历史命令存储文件/root/.bash_history
 4.备份初始检测信息
    mv /var/lib/aide/aide.db.new.gz /tmp
    cp /tmp/aide.db.new.gz /var/lib/aide/aide.db.gz  //拷贝回来重命名,用于对比
 5.执行入侵检测
    aide --check	//与初始aide.db.gz文件做对比,显示增,删,改的变化
三、扫描与抓包
 1.安全分析概述
   1.1以获取一些公开/非公开信息为目的
     -检测潜在的风险
     -查找可攻击的目标
     -收集设备/主机/系统/软件信息
     -发现可利用的安全漏洞
   1.2扫描方式
     -Scan,主动探测
     -Sniff,被动监听/嗅探
     -Capture,数据包捕获(抓包)
   1.3常见的工具
     -扫描器:NMAP
     -协议分析:tcpdump、WireShark
 2.NMAP扫描(man nmap帮助)
   2.1装包nmap
   2.2支持多种探测技术
    -ping扫描
      -多端口扫描
    -TCP/IP指纹校验
   2.3基本用法
     -nmap [扫描类型] [选项] <扫描目标。。。>
     2.3.1常用扫描类型
      -sS,TCP SYN扫描(半开)	//三次握手只进行2次，最后一次不进行
      -sT,TCP 连接扫描(全开)	//正常进行三次握手
      -sU,UDP扫描
      -sP,ICMP扫描	//可以ping多台或者网段
      -A,目标系统全面分析
     2.3.2选项
       -p	//指定端口
       -n	//不做DNS解析
    nfs传输数据服务rpcbind
作业：编写脚本要求：检查任意主机，任意服务是否运行
/root/bin/check_ser.sh  192.168.4.52 80
 3.网络抓包工具
  3.1tcpdump抓包命令(man tcpdump)
    一款提前tcp数据包的命令行工具
    基本用法：tcpdump [选项] [过滤条件]
    常见监控选项
     - -i,指定监控的网络接口(网卡)	
     - -c,指定抓包个数
     - -A,转换为ACSII码，以方便阅读
     - -w,将数据包信息保存到指定文件
     - -r,从指定文件读取数据包信息
   tcpdump的过滤条件
      -类型:host(主机IP)、net(网段)、port(端口)、portrange(端口范围)
      -方向:src(源地址)、dst(目标地址)
      -协议:tcp、udp、ip、wlan、arp、...(指定一个其他不会再抓)
      -多个条件组合:and、or、not
    默认只抓取eth0接口的包:tcpdump -i 网卡名称(修改抓取网卡接口)
   3.2测试抓取ftp服务包
     部署vsftpd服务，创建用户及密码，客户机利用ftp连接操作，看抓取效果
   3.3测试抓取发邮件服务包
     安装postfix软件包(发邮件)
     启动服务
     创建用户，接收邮件
     安装telnet
    helo pc254 定义主机名
    mail from:root@localhost  发件人
    rcpt to:xxx@localhost  收件人
    data  写邮件正文
     .   提交邮件
    quit 断开连接
   3.4测试抓取收邮件服务包
     安装dovecot
     启动服务，查看服务端口110
     修改配置文件:
     /etc/postfix/main.cf
       home_mailbox = Maildir/
     /etc/dovecot/conf.d/10-auth.conf
     	disable_plaintext_auth = no
     /etc/dovecot/conf.d/10-mail.conf
     	mail_location = maildir:~/Maildir
     重起postfix、dovecot服务	 
     使用telnet连接访问
    user 用户
    pass 密码
    list	//邮件列表
    retr 1	//查看邮件内容
 4.WireShark协议分析器(图形界面)
   一款与tcpdump类似的抓包工具
  软件包wireshark、wireshark-gnome
  显示OSI4层协议中每层的信息
#######################################################################
Day04

一、系统审计
  1.审计
    1.1什么是审计
     基于事先配置的规则生成日志，记录可能发生再系统上的事件
     审计不会为系统提供额外的安全保护，但她会发现并记录违反安全策略的人及其对应的行为
     审计能够记录的日志内容：
       -日期与事件、事件结果
       -触发事件的用户
       -所有认证机制的使用都可以被记录，如ssh等
       -对关键数据文件的修改行为等
    1.2审计的案例
      -监控文件访问
      -监控系统调用
      -记录用户运行的命令
      -审计可以监控网络访问行为
    -ausearch工具，可以根据条件过滤审计日志
    -aureport工具，可以生成审计报告
  2.部署audit
    2.1装包audit，起服务auditd
    2.2主配置文件/etc/audit/auditd.conf
        日志文件/var/log/audit/audit.log
    2.3命令auditctl
     auditctl -h	//命令帮助
     auditctl -s	//查询审计状态
     auditctl -l	//查看审计规则
     auditctl -D 	//删除所有审计规则
      2.3.1定义临时规则
      auditctl -w path -p permission -k key_name	//命令格式
       -path为需要审计的文件或目录
       -permission权限可以是r,w,x,a(文件或目录的属性发生变化)
       -key_name为可选项，方便识别哪些规则生成特定的日志项
      ausearch -k key_name -i 	//根据key搜索日志，-i为交互式操作
      2.3.2定义永久规则
        将auditctl -l查看到的规则，写入配置文件/etc/audit/rules.d/audit.rules
      echo `auditctl -l` >> /etc/audit/rules.d/audit.rules
  3.审计日志
    /usr/share/doc/audit-版本号/rules/*.rules	//存放各种规则模版
    /usr/include	//软件的头文件和库文件存放处
    日志详解
    -type为类型
    -msg为(time_stamp:ID),时间是date+%s
    -arch=c000003e，代表x86_64(16进制)
    -success=yes/no,事件是否成功
    -a0-a3是程序调用时前4个参数，16进制编码了
    -ppid父进程ID，如bash，pid进程ID，如cat命令
    -auid是审核用户的id，su - test，依然可以追踪su前的账户
    -uid，gid用户与组
    -tty：从哪个终端执行的命令
    -comm="cat"	用户在命令执行的指令
    -exe="/bin/cat"  实际程序的路径
    -key="sshd_config"  管理员定义的策略关键字key
    -type=CWD   用来记录当前工作目录
      -cwd="/home/username"
    -type=PATH
      -ouid(owner's user id)  对象所有者id
      -guid(owner's groupid)  对象所有组id
二、服务安全
 1.Nginx安全
   1.1删除不需要的模块
    --with...	//添加模块
    --without...	//移除模块	
    nginx -t 	//检测配置文件语法格式是否有误
     自动索引功能(autoindex)：当访问时首页不存在时，会显示目录下所有文件
    --without-autoindex-module	//移除不需要模块
   1.2隐藏和修改版本号
    server_tokens off;	//配置文件中添加，隐藏服务软件版本信息
    curl --help
    curl -I xxx	//显示版本信息
    curl -i xxx	//显示http头部信息
    curl -X 请求方式	
   1.3限制并发(限制某1台客户端同时访问的请求个数)
     ngx_http_limit_req_module	//默认模块，可以降低DDos攻击风险
     配置功能：
      -语法：http{limit_req_zone $binary-remote_addr zone=one:10m rate=1r/s;}
     	    server{limit_req zone=one burst=5;}
      -获取客户端IP地址$binary-remote_addr
      -将客户端IP信息存储名称定义为one，空间10M
    -1M可以存储8千个IP信息，10M存8万个主机IP信息
    -rate表示每秒处理几个请求，多余的放入漏斗
    -burst设置漏斗个数，超出会报错
   1.4拒绝非法请求
     常见的http请求方法(一般只需要get和post)
       请求方法	功能描述
       GET		请求指定的页面信息，并返回实体主体
       HEAD		类似get请求，只不过返回的响应中没有具体的内容，用于获取报头
       POST		向指定自源提交数据进行处理请求(例如提交表单或上传文件)
       DELETE	请求服务器删除指定的页面
       PUT		向服务特定位置上传资料
         ...	
      禁用其他方法，仅允许(get|post)
     server{
          if ($request_method !~ ^(GET|POST)$){
           	return 444;
          }
        }  
      测试curl -i -X 请求方法 http://.../
   1.5防止buffer溢出
   http{
     client_body_buffer_size 1K;	//缓冲区最小空间
     client_header_buffer_size 1K;	//头部信息最小空间
     client_max_body_size 16K;		//缓冲区最大空间
     large_client_header_buffers 4 4K;	//头部信息最大存储空间
     }
 2.mariadb安全
   2.1初始化安全脚本
    mysql_secure_installation	//初始化安全脚本
     -输入旧密码，配置新root密码
     -删除匿名账户
     -禁止root远程登陆
     -删除测试数据库
     -刷新权限
   2.2密码安全(明文方式保存在历史记录中)
     修改密码：命令行mysqladmin、数据库set/alter/修改表
     清空历史记录文件：/root/.bash_history、/root/.mysql_history
   2.3数据的备份和恢复
     mysqldump -uroot -p123456 库名 [表名] > 备份文件
     mysqldump -uroot -p123456 库名 [表名] < 备份文件
   2.4数据安全(默认数据是明文传输)
     -创建可以远程登陆的账户
     -使用tcpdump抓包
      tcpdump -w log -i eth0 src or dst port 3306
     -客户端远程登陆数据库，查看抓包数据
     解决办法：使用SSL或SSH加密数据传输,mysql数据加密服务(自行学习)
 3.Tomcat安全  
   3.1隐藏版本信息
     影响浏览器显示信息,修改tomcat主配置文件，隐藏版本信息
    -yum -y install java-1.8.0-openjdk-devel.x86_64  //装包
    -jar -xf /usr/local/tomcat/lib/catalina.jar  //解包
    -cd /usr/local/tomcat/lib
    -vim org/apache/catalina/util/ServerInfo.properties //修改文件
      server.info=软件名
      server.number=软件版本号
     影响命令行显示信息,修改配置文件
    curl -I localhost:8080	//会显示头部信息
    vim /usr/local/tomcat/conf/server.xml
       <Connector ... server="虚假信息" />	//隐藏头部版本信息
   3.2降权启动
     默认root用户启动tomcat服务,不安全
     useradd tomcat  //创建普通用户
     chown -R tomcat.tomcat /usr/local/tomcat  //修改文档所有者和所属组
     su - tomcat -c "/usr/local/tomcat/bin/startup.sh"  //使用tomcat启动
     设置开机自启方法
      chmod +x /etc/rc.local
      echo 'su - tomcat -c "/usr/local/tomcat/bin/startup.sh"' >> /etc/rc.local
   3.3删除默认测试页面
三、Linux安全之打补丁
 1.创建补丁文件diff
  diff制作补丁文件的原理：告诉我们怎么修改第一个文件后能得到第二个文件。
  diff命令常用选项：
	-u  输出统一内容的头部信息（打补丁使用），计算机知道是哪个文件需要修改
	-r  递归对比目录中的所有资源（可以对比目录）
	-a  所有文件视为文本（包括二进制程序）
	-N  无文件视为空文件（空文件怎么变成第二个文件）
	-N选项备注说明：
	A目录下没有txt文件，B目录下有txt文件
	diff比较两个目录时，默认会提示txt仅在B目录有（无法对比差异，修复文件）
	diff比较时使用N选项，则diff会拿B下的txt与A下的空文件对比，补丁信息会明确说明如何从空文件修改后变成txt文件，打补丁即可成功
   1.1给单个文件创建补丁文件
     使用patch命令对单文件代码打补丁
     yum -y install patch
     patch -p0 < 生成的补丁文件  //-p0(p表示路径0表示打包路径和补丁文件层级)
     patch -RE < 补丁文件	//恢复补丁前文件
   1.2给目录创建补丁文件
     diff -uraN 目录1/ 目录2/ > 补丁文件
#####################################################################
Day04

一、iptables防火墙(保护、隔离)
 1.iptables的表、链结构(记)
    4张表(iptables服务功能分类)
     raw：状态跟踪表  PEROUTING、OUTPUT
     mangle:打标记表(记录所有访问)  5条链都有
     nat：地址转换表(源地址、目标地址)  PEROUTING、POSTROUTING、OUTPUT、INPUT
     filter：过滤表(不指定时默认调用此表)  INPUT、FORWARD、OUTPUT
    5条链(ip包传输的方向)
     INPUT：匹配进入防火墙本机的ip包
     OUTPUT：匹配从防火墙本机出去的ip包
     FORWARD：匹配经过防火墙主机的ip包
     POSTROUTING：路由后处理
     PREROUTING：路由前处理
    匹配流程：顺序比对，匹配即停止(LOG除外)
 2.iptables使用
   2.1命令格式
    iptables [-t表名] 选项 [链名] [条件] [-j 目标操作]
    target(处理动作):ACCEPT、REJECT
   2.2常用选项
     查看规则
       -L	//列出说有的规则条目
       -n	//以数字形式显示地址、端口等信息
       --line-numbers	//查看规则时，前面显示序号
     添加规则
       -A	//在链末尾追加一条规则
       -I	//在链开头或指定序号插入一条规则,-I INPUT 序号
     删除规则
       -D 	//删除链内指定序号或内容的一条规则
       -F	//清空所有规则，后面跟链名只清空此链规则
     设置默认规则
       -P	//修改默认规则
     iptables-save > /etc/sysconfig/iptables  //永久保存规则
   2.3条件
   2.4基本目标操作(target)
     ACCEPT:允许通过/放行
     DROP:直接丢弃，不给任何回应
     REJECT:拒绝通过，必要时回给出提示
     LOG:记录日志，然后传给下一条规则
二、filter表控制
  1.防护类型及条件
    1.1开启内核IP转发
      echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf
    或 echo 1 > /proc/sys/net/ipv4/ip_forward
    1.2基本匹配条件(!取反)
      通用匹配
         协议匹配：-p 协议名
         地址匹配：-s 源地址IP、-d 目标地址IP
         接口匹配：-i 收数据的网卡、-o 发数据的网卡
      隐含匹配(--help找帮助)
         端口匹配：--sport 源端口、--dport 目标端口
       ICMP类型匹配：--icmp-type ICMP类型(ping echo-request、pong echo-reply)
       iptables -I INPUT -p icmp --icmp-type echo-reply -j ACCEPT 
         //接收ping回应包pong
  2.扩展匹配
    基本用法
     -m 扩展模块 --扩展条件 条件值
    常见的扩展条件类型
      arp -n //显示ping过本机的mac地址
      MAC地址匹配：-m mac --mac-source MAC地址
       多端口匹配：-m multiport --sports 源端口列表
               -m multiport --dports 目标端口列表
     IP范围匹配：-m iprange --src-range IP1-IP2(完整的IP地址)
     		   -m iprange --dst-range IP1-IP2
    配置网关：systemctl stop NetworkManager
     	   route add default gw IP地址	//添加网关地址，删除用del
    52开启路由转发：sysctl -a 	//列出所有内核参数，必记
        echo "net.ipv4.ip_forward = 1" > /etc/sysctl.conf
三、nat表应用
  共享一个公网地址上网
  1.地址转换
    源地址转换(共享一个公网地址,企业常用)
    目标地址转化(发布私有网络服务)
   iptables -t nat -A POSTROUTING -s 局域网地址/24 -p tcp --dport 端口 \
   -j SNAT --to-source 网关地址	//nat源地址转换
#######################################################################
Day05

监控概述
 监控的目的
   报告系统运行状况
     -每一部分必须同时监控
     -内容包括吞吐量、反应时间、使用率等
   提前发现问题
     -进行服务器性能调整前，知道调整什么
     -找出系统的瓶颈在什么地方
 监控的资源类别
   公开数据
     -Web、FTP、SSH、数据库等应用服务
     -TCP或UDP端口
   私有数据
     -CPU、内存、磁盘、网卡流量等使用信息
     -用户、进程等运行信息
监控软件
  系统监控命令
    ps
    uptime
    free
    swapon -s
    df -h
    ifconfig
    netstat或ss
    ping
    traceroute 目标域名或IP	//路由监控，监控经过所有IP
    iostat	//查看当前系统盘读写速度
  自动化监控系统
    Cacti
       -基于SNMP协议的监控软件，强大的绘图能力
       -做报警和状态检查需手写脚本，绘图能力强大
       -插件少
    Nagios
       -基于Agent(代理程序)监控,强大的状态检查与报警机制
       -插件极多，自己写监控脚本插入到Nagios非常方便
       -支持邮件(默认)、威信、短信报警
       -没有绘图功能，配置时修改配置文件
    Zabbix
       -基于多中监控机制，支持分布式监控
Zabbix基础
  简介
   -Zabbix是一个高度集成的监控解决方案
    -可以实现企业级的开源分布式监控
   -Zabbix通过C/S模式采集监控数据
   -Zabbix通过B/S模式实现Web管理
  监控拓扑
    监控服务器(C/S模式中的S)
      -监控服务器可以通过SNMP或Agent采集数据
      -数据可以写入MySQL、Oracle等数据库中
      -服务器使用LNMP实现Web前端的管理
    被监控主机(C/S模式中的C)
      -被检控主机需要安装Agent
      -常见的网络设备一般支持SNMP
二、Zabbix监控服务
  1.部署运行环境LNMP
    安装源码nginx并运行服务
    安装mysql并运行服务
    安装php
    测试LNMP环境
  2.安装Zabbix软件
    yum -y install net-snmp-devel curl-devel libevent(自行下载安装依赖包)
    tar -xf zabbix
    ./configure --prefix=/usr/local/zabbix(不指定时，安装的命令、配置都会分开存放) --enable-server(zabbix服务程序) --enable-proxy(zabbix代理服务器) --enable-agent --with-mysql --with-net-snmp --with-libcurl(增加模块)
    make && make install
  3.初始化Zabbix
     3.1创建数据库与数据库账户
      create database zabbix character set utf8;
      grant all on zabbix.* to zabbix@"localhost" identified by 'zabbix';
      cd /root/lnmp_soft/zabbix-3.4.4/database/mysql/  //压缩包下
       需从后往前恢复,建立监控数据库
      mysql -uzabbix -pzabbix zabbix < schema.sql
      mysql -uzabbix -pzabbix zabbix < images.sql
      mysql -uzabbix -pzabbix zabbix < data.sql
     3.2创建zabbix php页面
      cd /root/lnmp_soft/zabbix-3.4.4/frontends
      cp -r php /usr/local/nginx/html/zabbix
     3.3做初始化相关配置(修改配置文件、安装依赖软件包)
      vim /etc/php.ini
         post_max_size = 16M
         max_execution_time = 300
         max_input_time = 300
         date.timezone = Asia/Shanghai
        修改后重起php-fpm
      vim /usr/local/nginx/conf/nginx.conf
       http{
        fastcgi_buffers 8 16k;  //缓存php生成的页面内容，8个16k
        fastcgi_buffer_size 32k;  //缓存php生产的头部信息
        fastcgi_connect_timeout 300;  //连接php超时时间
        fastcgi_send_timeout 300;  //发送请求的超时时间
        fastcgi_read_timeout 300;  //读取请求的超时时间
          }
        重起nginx
        安装依赖包，需自行下载
      rpm -ivh --nodeps php-bcmath-5.4.16-42.el7.x86_64.rpm php-mbstring-5.4.16-42.el7.x86_64.rpm
      yum -y install php-gd php-xml php-ldap
      systemctl restart php-fpm	//重起服务
      chmod 777 /usr/local/nginx/html/zabbix/conf  //修改配置文件权限
     3.4访问Web页面做初始化配置
       用户名：admin
       密码：zabbix
  访问管理页面
    1.修改管理员密码和语言
      界面右上交
    2.查看已有的监控模版
      配置-->模版
    3.查看已监控的主机
      配置-->主机
    4.查看监控信息
      监测中-->最新数据信息
三、运行Zabbix服务
     1.修改配置文件/usr/local/zabbix/etc/zabbix_server.conf
       LogFile=/tmp/zabbix_server.log  //日志文件
       DBName=zabbix  //库名
       DBUser=zabbix  //连接数据库的用户名
       DBPassword=zabbix  //连接数据库的密码，默认未开启
       DBHost=localhost  //默认使用本机数据库，未打开
     2.运行脚本启动服务
       cp misc/init.d/fedora/core/zabbix_server /etc/init.d/
       chmod +x /etc/init.d/zabbix_server
       sed -i '22s!/local!/local/zabbix!' /etc/init.d/zabbix_server  //修改运行命令的路径
       useradd zabbix	//创建用户
       /etc/init.d/zabbix_server start  //启动脚本
       ss -ntul | grep 10051  //zabbix_server服务端口10051
       若报错：
       vim /tmp/zabbix_server.log  //查看日志文件
       /etc/init.d/zabbix_server status  //查看状态信息
   监控远端网站服务器主机192.168.2.100
     1.配置被监控端：主机192.168.2.100
       运行zabbix_agent(10050)
       源码安装zabbix
      yum -y install gcc pcre-devel	//源码编译依赖包
      ./configure --prefix=/usr/local/zabbix --enable-agent  
      make install
      修改配置文件/usr/local/zabbix/etc/zabbix_agentd.conf
      LogFile=/tmp/zabbix_agentd.log  //日志文件
      Server=127.0.0.1,192.168.2.5  //允许访问本机服务的地址
      ServerActive=192.168.2.5：10051  //监控服务器的IP和端口
      启动服务
       cp misc/init.d/fedora/core/zabbix_agentd /etc/init.d/
       chmod +x /etc/init.d/zabbix_agentd
       sed -i '22s!/local!/local/zabbix!' /etc/init.d/zabbix_agentd  //修改运行命令的路径
       useradd zabbix	//创建用户
       /etc/init.d/zabbix_agentd start  //启动脚本
       ss -ntul | grep 10050  //zabbix_agentd服务端口10050
     2.配置监控主机：192.168.2.5
       登陆web页面
       创建监控主机：配置-->主机-->创建主机-->添加模版-->可用性zbx变绿表示已监控到
       查看监控主机：监测中-->最新数据-->主机群、主机、应用集-->显示具体监控项
四、自定义Zabbix监控项目(监控系统用户数量)
    1.配置被监控服务器
      1.1启用自定义监控项功能
        停止服务,修改配置文件/etc/init.d/zabbix_agentd stop
      Include=/usr/local/zabbix/etc/zabbix_agentd.conf.d/*.conf  //自定义监控文件路径
      UnsafeUserParameters=1  //启用自定义监控功能
      1.2定义监控命令
        vim /usr/local/zabbix/etc/zabbix_agentd.conf.d/test.conf
        UserParameter=<key>,<shell cmd>
        UserParameter=get,wc -l /etc/passwd | awk '{print $1}'
      启动服务 
      1.3查看命令输出结果
        /usr/local/zabbix/bin/zabbix_get -s IP地址 -p 10050(端口) -k get(上面定义的名字)
    2.配置监控服务器
      2.1在命令行下测试是否调用被监控的自定义命令
       /usr/local/zabbix/bin/zabbix_get -s IP地址 -p 10050(端口) -k get(定义的名字)
      2.2定义新监控模版-->创建应用集-->创建监控项目,并指定使用的监控命令
      创建名称，分组-->创建名称-->创建名称，键值(创建UserParameters时的名字)
      2.3监控主机192.168.2.100，添加自定义监控模版
      2.4查看监控信息


Day06
    
一、Zabbix报警机制
  1.概念
    自定义监控默认不会自动报警，首页也不会提示错误，需配置触发器与报警动作才可以
    1.1触发器(trigger)
      -表达式，如内存不足，用户超过多少等
      -当触发条件后，会导致一个触发事件
      -触发事件会执行某个动作    
    1.2动作(action)
      -触发器的条件被触发后行为
      -可以时发送邮件、也可以是重起某个服务等
  2.案例：
   2.1准备邮件服务和邮箱账号
     查看postfix是否安装，查看端口25
    echo 123 | mail -s 主题 收件人(zabbix)  //测试
   2.2创建触发器
     配置-->模版-->触发器-->创建触发器-->名称、严重性、表达式(监控项、功能(最新T值和N比较)、N)-->添加
     表达式
       -大多数函数使用秒作为参数，使用#代表不同含义
      -avg,count,last,min and max还数支持额外的第二个参数time_shift(时间偏移量)
       -允许从过去一段时间内引用数据
      sum(600)  //600秒内所有值的总和
      sum(#5)   //最后5个值的总和
      last(20)  //最后20秒的值
      last(#5)  //倒数第5个值
      avg(1h,1d) //一天前的一小时的平均值
   2.3创建动作
     配置-->动作-->创建动作-->名称-->操作(指定做什么)-->操作类型(发消息、执行命令)、发送用户-->添加
   2.4指定邮件服务器和收件人
     发件人：管理-->报警媒介类型-->Email-->SMTP(localhost)、端口(25)、HELO(发送邮件署名)、SMTP电邮(发件人的邮箱zabbix@localhost) -->更新
     收件人：管理-->用户-->Admin-->报警媒介-->添加(收件人邮箱)
   2.5测试配置
二、Zabbix进阶操作
  1.自动发现
    1.1概述
      -当Zabbix需要监控的蛇别越来越多，手动添加监控设备越来越有挑战
      -需要批量一次性添加一组监控主机
    1.2自动发现可以实现
      -自动发现、添加主机，自动添加主机到组
      -自动连接模版到主机，自动创建监控项目与图形等
    1.3流程
      1.3.1创建自动发现规则
       配置-->自动发现-->创建发现规则-->名称、IP范围、更新间隔、检查(类型、端口)-->添加
     IP范围：192.168.2.1-254
      1.3.2创建Action动作，说明发现主机后自动执行什么动作
       配置-->动作-->事件源：自动发现-->创建-->名称、新的触发条件(IP地址范围)-->操作-->操作细节(操作类型：添加主机到群组、与模版关联)-->添加
      1.3.3通过动作，执行添加主机，连接模版纳到主机等操作
      1.3.4架设网站服务
        -运行zabbix_agentd
        -运行httpd服务
      1.3.5查看是否监控了网站服务
  2.主被动监控
    2.1概述
      主动和被动都是对被监控端主机而言的
      默认zabbix采用的是被动监控
        -被动监控:Server向Agent发起连接，发送监控key，Agent接收请求，响应监控数据
        -主动监控:Agent向Server发起连接，Agent请求需要检测的监控项目列表，Server响应Agent发送一个items列表，Agent确认收到监控列表，TCP连接完成，会话关闭，Agent开始周期性的收集数据
      区别:Server不用每次需要数据都连接Agent，Agent会自己收集数据并处理数据，Server仅需要保存数据即可
      当监控主机达到一定量级后，Zabbix服务器会越来越慢，
      此时，可以考虑使用主动监控，释放服务器的压力
      另外，Zabbix也支持分布式监控，也是可以考虑的方案
    2.2配置客户端主动模式
      安装zabbix_agent
      修改配置文件
      vim /usr/local/zabbix/etc/zabbix_agentd.conf
        # Server=127.0.0.1	//注释，允许谁监控本机
        StartAgents=0	//禁用被动监控，不启用zabbix_agentd服务
        ServerActive=192.168.2.5  //允许监控的主机
        Hostname=ser77  //告诉监控服务器，是谁发的数据信息，一定要和zabbix服务器配置的监控主机名称一致
        RefreshActiveChecks=120  //默认120s检测一次
       启动主动监控服务
         useradd zabbix
         /usr/local/zabbix/sbin/zabbix_agentd
         ps -C zabbix_agentd  //查看进程，没有端口
         killall zabbix_agentd  //杀死进程
     2.3配置监控服务器主动模式
      2.3.1创建主动模式的监控模版
        克隆模版：配置-->模版-->Template os linux-->全克隆，修改名称
        修改监控模式：配置-->模版-->新克隆的监控项-->全选，批量更新-->更改类型为主动式,停用非主动式监控项
      2.3.2添加监控主机
        配置-->主机-->主机名称(与配置文件Hostname相同)、agented代理程序接口(IP0.0.0.0,端口0)-->添加模版
      2.4查看配置
  3.拓扑图与聚合图形 
三、监控案例(自己编写监控脚本，监控时调用监控脚本)
  1.监控Nginx
   1.1部署nginx
     yum -y install gcc pcre-devel openssl-devel zlib-devel
     ./configure --with-http_stub_status_module
     make && make install
   1.2修改配置文件/usr/local/nginx/conf/nginx.conf
     server { 
        location /status { stub_status on; }  //启用状态模块
      }
   1.3书写脚本(监控nginx状态)
     #!/bin/bash
	case $1 in
	active)
	  curl -s http://localhost/status | awk '/Active/{print $NF}';;
	waiting)
	  curl -s http://localhost/status | awk '/Waiting/{print $NF}';;
	accepts)
	  curl -s http://localhost/status | awk 'NR==3{print $2}';;
	esac
   1.4开启zabbix自定义监控
     vim /usr/local/zabbix/etc/zabbix_agentd.conf
       UnsafeUserParameters=1
       Include=/usr/local/zabbix/etc/zabbix_agentd.conf.d/*.conf
      创建自定义命令文件
       vim /usr/local/zabbix/etc/zabbix_agentd.conf.d/xxx.conf
       UserParameter=key[*],脚本 $1  //$1读取[*]里的值
   1.5测试自定义命令
     /usr/local/zabbix/bin/zabbix_get -s 127.0.0.1 -p 10050 -k key[参数]
   1.6配置监控服务器
     创建监控模版：配置-->模版-->创建模版(自定义名称)
     创建应用集(自定义名称)-->创建监控项目,并指定使用的监控命令-->创建名称，键值(创建UserParameters时的名字)、应用集


   




  


