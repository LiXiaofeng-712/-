ftp://176.121.0.120
帐号：python
密码：python
教学群：552320360
石博文：shibw@tedu.cn


Python1
Day01
python版本2/3不兼容
目前大部分系统默认安装的是python2，大部分已停止更新
教学环境是python3版本

终端输入python或python3进入python的不同版本
使用quit()或exit()或ctrl+D退出

python官网：www.python.org
pycharm激活：
1.运行/root/bin/crack
  选择License Server
  输入网址：http://127.0.0.1:1017

git
安装与使用
安装：yum -y install git
查看版本信息：git --version
配置用户信息 用户名/邮箱/默认编译器
git config --global user.name ""
git config --global user.email ""
git config --global core.editor vim
git config --list	//查看更改信息
查看文件是否更改
cat  ~/.gitconfig

git分为工作区、暂存区、版本库
创建仓库
mkdir devops
cd devops
git init
在工作区创建文件
cat << eof > hello.py
> print("Hello World!")
> eof
添加文件到暂存区
git add hello.py(文件名)
git status 	//查看暂存区的状态
git status -s 	//只显示暂存区文件的变化
确认至仓库
git commit -m "描述信息"
更改文件并提交到版本库
1.git add . --> git commit -m "描述信息"
2.git commit -am "描述信息" 	//只适用于修改文件，新文件不适用
删除文件
git ls-files	//查看版本库中的文件
git rm 文件名
git commit -m "描述信息"

搭建本地gitlab服务器
安装docker容器，并下载gitlab_zh.tar镜像文件，导入
docker load < gitlab_zh.tar 
修改真机ssh端口后，启动容器
docker run -d -h gitlab --name gitlab -p 443:443 -p 80:80 -p 22:22 --restart always -v /srv/gitlab/config:/etc/gitlab -v /srv/gitlab/logs:/var/log/gitlab -v /srv/gitlab/data  gitlab_zh:latest 
-d 后台运行
-h 设置虚拟机的主机名
--name 设置容器名
-p 真机端口:容器端口，映射端口到真机中
--restart always  出现问题时重新启动服务
-v 真机路径:容器路径，映射目录到容器中

启动后直接访问虚拟机IP访问(出现无法连接500/502等会再刷新)
默认用户root，直接修改密码（不低于8位）
登陆后创建项目、用户、组等

通过http方式连接远程仓库
git remote rename origin old-origin	//默认远程仓库origin，重复的话使用此命令改名
git remote add origin http://192.168.4.1/nsd1809/core_py.git  //连接远程仓库
git push -u origin --all   //将本地代码推送至远程仓库，-u仓库名，--all全部代码

git remote add	//添加远程仓库
git remote rename	//重命名远程仓库
git remote remove	//删除远程仓库

使用ssh方式免密钥登陆
真机生成密钥，将公钥部署到网页用户中
ssh-keygen -C 邮箱 -t rsa -N '' -f "/root/.ssh/id_rsa" -b 4096
ssh-agent	//密钥管理工具	
ssh-add	//添加到管理工具
如果遇到权限问题，将私钥权限改为600
删除已连接的远程仓库
git remote remove origin
连接远程仓库
git remote add origin git@192.168.4.1:nsd1809/core_py.git
######################################################################################################


Day02
以.py结尾的是python文件
1.通过解释器运行文件
python3 文件
2.在文件中声明解释器，赋予文件执行权限即可
书写python文件
cat << eof > hello.py
#!/usr/bin/env python3	//自动寻找python3解释器(要写env的绝对路径)，也可以书写python3绝对路径
print("hello world!")
eof
chmod +x hello.py

python语法结构
1.缩进
首行以关键字开始，以冒号结束，之后的每一行都要有4个空格的缩进，直到代码结束
2.注释/换行
#注释内容
\换行，注意换行符必须是最后一个字符
3.同行多个语句(不推荐使用)
使用；号
4.帮助信息
help(关键字)
help(print)	//查看输出的帮助信息
print(value,...,sep=' ',end'\n',file=sys.stdout,flush=False)
value:任意输出的值
sep:两个值之间的字符默认是一个空格
end:最后一个字符，默认换行
help(input)	//查看输入帮助
input(prompt=None,\)
prompt:提示字符串，提示用户输入信息，所有返回值默认是字符类型

变量
变量名称约定
  -第一个字符只能是大小写字母或下划线
  -后续字符只能是大小写字母或下划线
  -区分大小写
推荐变量名
  -变量名全部采用小写字母
  -常量名采用大写字母
  -简短，有意义
  -多个单词间用下划线分隔
  -变量名用名词，函数名用谓词(动词+名词)
  -类名采用驼峰形式
python中变量不需要声明数据类型，变量的值是什么类型变量就是什么类型
声明变量一定要赋值，否则不能声明变量
支持增量赋值
a += 1 相当于 a = a + 1
不支持a++

运算符
算术运算符
+ - * / //(整除，舍弃小数位) % **(幂运算)
整数与浮点数进行运算，结果为浮点数
比较运算符
< <= > >= == != <>
逻辑运算符
and not or
and运算只要有一个条件False，结果就为False
or运算只要有一个条件True，结果就为True
not运算条件为True结果为False，条件为False结果为True
1<2 and 2>3 
############################################################################################
数据类型
1.数字
  -int：有符号整数
  -bool：布尔值(首字母必须大写)
    True：1  条件成立，存在
    False：0  条件不成立，不存在
  -float：浮点数
  -complex：复数
    1+2j
    2+43J
python默认以十进制数显示
数字以0b或0B开头表示2进制
数字以0o或0O开头表示为8进制
数字以0x或0X开头表示16进制

2.字符串
  python中引号之间的字符称为字符串
  python不区分单双引号，意义相同
  支持三引号，连续的三个单引或双引，可以包含特殊字符
  python不区分字符和字符串
字符串切片
  使用索引运算符[]和切片运算符[:]可得到子字符串
  第一个字符的索引是0，最后一个是-1
  子字符串包含切片中的起始下标，但不包含结束下标
字符串连接
  使用+号可以将多个字符串拼接在一起
  使用*号可以将一个字符串重复多次
字符串比较大小根据ascii码
'a' < 'b'
'ab' < 'ac'
'abc' < 'ac'
字符串比较运算时，按顺序从第一位开始比较，相同比下一位，比出结果后停止

列表和元组
容器 可以存放任意类型的数据
列表的表示方式[value，value，...],可以为空，表示空列表
使用in/not in 查看列表中是否有某一元素
list = [1,2,'a']
向列表末尾追加内容：list.append(value)
元组是静态的列表，一旦定义，不能改变
tuple = (1,2,'b')

字典
字典是由键-值对构成的，通过键取值，不支持下标操作
dict = {'tel':13011112222}
dict['tel']

数据类型比较
按存储模型分类
  -标量类型：数值，字符串
  -容器类型：列表，元组，字典
存储模型分类
  -可变类型：列表，字典
  -不可变类型：数值，字符串，元组
按访问模型分类
  -直接访问：数值
  -顺序访问：列表，元组，字符串
  -映射访问：字典

if语句
语法结构
if expr:
    if_suite
else:
    else_suite
判断表达是expr的值非0或布尔值为True，执行if代码，否则执行else代码
expr可以是单独元素，也可以是条件表达式
单独元素值转换布尔值为False的：0,0.0,(0+0j),'',[],(),{}

三元运算符
x if expr else y	//如果expr条件成立，输出x，否则输出y

cat << eof > login2.py
#!/usr/bin/env python3
user=input('请输入用户名:')
passwd=input('请输入密码:')
if user == '' or passwd == '':
    print('请输入正确的用户和密码！')
    exit
elif user == 'bob' and passwd == '123456':
    print('Login successful')
else:
    print('Login inorrect')
eof
chmod +x login2.py
./login2.py


cat << eof > grade.py
#!/usr/bin/env python3
grade = int(input('请输入成绩：'))
if grade > 90:
    print('优秀！')
elif grade > 80:
    print('好！')
elif grade > 70:
    print('良！')
elif grade > 60:
    print('及格！')
else:
    print('你要努力了！')
eof
chmod +x grade.py
./grade.py

#剪刀石头布小游戏
import random	//导入随机模块
choice = ['剪刀','石头','布']
win = [['剪刀','布'],['石头','剪刀'],['布','石头']]
computer = random.choice(choice)
tmp = '''[0]剪刀
[1]石头
[2]布
请选择(0/1/2)：
'''
ind = int(input(tmp))
player = choice[ind]
print('computer choice:',computer,'player choice:',player)
if player == computer:
    print('平局！')
elif [player,computer] in win:
    print('You Win！')
else:
    print('You Lose！')

while循环
循环次数可以预知的情况下，建议采用for循环
循环次数未知的情况下，建议采用while循环
num = 2
print("%d"%num)

打印20以内的偶数
n = 1
while n <= 20:
    if n%2 == 0:
        print(n)
    n += 1

练习 要求用户输入用户名，如果用户名不是tom，则一直输入
方法一：
uname = input('请输入用户名')
while uname != 'tom':
    uname = input('请输入用户名')
方法二：
while 1:
    uname = input('请输入用户名')
    if uname == 'tom':
        break	//跳出当前循环，执行下条语句

break:跳出循环，执行下条语句
continue：跳过本次循环，进入下次循环
else：python中特有的，在循环结束后会执行else语句，break会跳过此处代码
while 1:
    代码
else:
    代码

总结：
语法结构
缩进：严格按4个空格缩进
注释：以#开头表示注释

变量
规则：开头由字母、下划线组成，后续由字母、下划线、数字组成

运算符
算术运算：+ - * / // % **
比较运算：> >= < <= == != <>
逻辑运算：and or not

数据类型
数字：int,bool,float,complex
字符串：str
列表：list
元组：tuple
字典：dict

判断语句
if 条件表达式:
    代码
elif 条件表达式:
    代码
else:
    代码

循环
while 条件表达式:
    代码
################################################################################################

Day03
for循环语法结构
for 变量 in 可迭代对象:
    代码
for循环将可迭代对象中的值按顺序遍历给变量执行代码，直到结束，若后面有else语句，结束后会执行else中的代码
for循环中的变量结束后还是会存在的，后续使用尽量不要重名
注意：若可迭代对象为空，则不会创建变量
range函数：提供循环条件，range(start,end,step=1)，包含开始不包含结束

#九九乘法表
#range函数，顾头不顾尾，结尾+1
for i in range(1,10):
    for j in range(1,i+1):
        print('%sx%s=%s\t'%(j,i,j*i),end=' ')
        #print(str(j)+'x'+str(i)+'='+str(j*i)+'\t',end=' ')
        #print('{0}x{1}={2}\t'.format(j,i,(i*j)),end=' ')
    print()

列表解析（列表推倒式）def md5(dir):
    

语法
[expr for 变量 in 可迭代对象]或	//expr可以和变量搭配使用
[expr for 变量 in 可迭代对象 if 条件表达式]
alist = [2+i for i in range(101) if i%2 == 0]

文件对象
文件打开的方法
open()方法
open(file,mode,buffering)打开指定文件
file：文件路径，mode：访问模式（默认以r模式访问），buffering：缓存（默认-1，使用系统默认缓存）
文件对象访问模式：
r：读 （文件不存在会报错）
w：写 （文件不存在会创建，文件存在会清空文件）
a：追加 （必要时创建文件）

r+：以读写模式打开（操作同r）
w+：以读写模式打开（操作同w）
a+：以读写模式打开（操作同a）

rb/wb/ab：以二进制模式打开

文件输入
read()读取文件内容
fobj = open('test.py','r')
data = fobj.read()	//不写默认读取全部内容，可以设置读取字节数read(5)
print(data)
当读取全部内容后，指针会指向文件末尾，再次读取文件则读不到任何数据
fobj.close()	//关闭文件对象

readline()读取文件光标开始到下一个换行之间的所有内容，即一行；也可以指定读取指定字节readline(5)
readlines()读取剩余所有行并把他们作为一个字符串列表返回

文件迭代
fobj = open('test.py')
for i in fobj:
    print(i)	//一行一行迭代

文件输出
write()
fobj.write('hello world\n')	//向文件写入内容，不会自动添加结束标志，需手工输入
fobj.writelines(['a\n','b\n'])	//支持字符串列表作为参数写入，也要手工输入结束符
fobj.flush()	//立即将缓存中的数据同步

操作文件
pycharm批量注释快捷键ctrl+/
with语句：简化代码
with open('test.py') as f(别名):
    对文件的操作代码
print(f.closed)	//检测文件是否关闭，关闭返回True，否则False

seek(offset[,whence])	//移动文件指针到不同的位置
f.seek(0,0)	//将指针移动到开头
offset是相对于某个位置的偏移量
whence的值，0表示文件开头，1表示当前位置，2表示文件结尾
tell()	//返回当前文件指针的位置

标准文件（了解即可）
标准输入：一般是键盘，使用sys.stdin
标准输出：一般是显示器缓冲输出，使用sys.stdout
标准错误：一般是显示器的非缓冲输出，使用sys.stderr
使用需导入sys模块
sys.stdout.write('hello')	//等同于print('hello')
sys.stdin.readline()	//等同于input()

模拟cp操作
#打开/bin/ls 作为源文件
f1 = open('/bin/ls','rb')
#打开/root/ls 作为目标文件
f2 = open('/root/ll','wb')
#重复的从源文件读取内容到目标文件，建议一点一点读
while True:
    data = f1.read(4096)	//每次读取4096字节
    #if data == '':
    if not data:	//判断数据为空，退出循环
        break
    f2.write(data)
#关闭文件
f1.close()
f2.close()
f1.closed	//检测文件是否关闭


函数
简化程序，点少代码的重复，通常代表某一种功能
函数语法
def func_name(arguments):
    '文档字符串'	//描述函数的功能及使用方式
    代码
def say():	//定义函数
    print('hello')
say()		//调用函数
#拷贝函数
def cp(src,dst):
    '''cp(src,dst)
    src 源文件路径
    dst 目标文件路径'''
    f1 = open(src,'rb')
    f2 = open(dst,'wb')
    while True:
        data = f1.read(4096)
        if not data:
            break
        f2.write(data)
    f1.close()
    f2.close()

函数参数
#在定义函数时的参数称为形参
def mysum(num1,num2):	
    return num1 + num2	//return指定函数返回结果
#调用函数，传递的参数称为实参
print(mysum(5,6))	

位置参数
需要使用sys模块的argv列表接收
import sys
print(sys.argv) #位置参数列表,将所有位置参数保存在列表中
print(sys.argv[1])	//打印列表中下标为1的参数

默认参数
def mysum(num=10):	//定义默认参数num=10
    print('*'*num)
mysum()	//没有实参时，使用默认参数10

#使用python书写拷贝功能函数
#!/usr/bin/env python3
import sys
def cp(src,dst):
    '''cp(src,dst)
    src 源文件路径
    dst 目标文件路径'''
    f1 = open(src,'rb')
    f2 = open(dst,'wb')
    while True:
        data = f1.read(4096)
        if not data:
            break
        f2.write(data)
    f1.close()
    f2.close()
cp(sys.argv[1],sys.argv[2])
#需要在终端运行
cp src dst

总结：
循环语句
while：循环次数未知
for：循环次数已知

列表解析
[expr for i in 迭代对象 if 条件表达式]

文件操作
open()
r,w,a,b

读取文件内容
read()/readline()/readlines()：前两个都可以接受字节数

向文件写入
write()/writelines()

操作文件内容
seek()：偏移量，位置（0开头，1当前，2结尾）  //移动指针，一般在二进制文件中移动
tell()：获取当前光标位置
with open() as 别名：简化代码
f.closed	//检测文件是否关闭

函数
自定义函数：将一些重复的代码放入一个函数中，简化代码，实现某一功能
文档字符串：描述函数的使用和功能

参数
形参和实参
def mysum(a,b):
    return a + b
mysum(10,20)

位置参数
import sys
sys.argv

默认参数
def p_star(num=20)
    print('*'*num)
p_star()
p_star(50)
###########################################################################################

模块
模块文件名字是去掉.py后的名字
导入模块：import 模块名
导入模块中的某一个功能：from 模块名 import 功能名字(使用时不用带模块名)
模块加载(load)：一个模块只能被加载一次

模块导入的特性
模块具有一个__name__特殊属性
当模块文件直接被执行时，__name__的值为__main__
当模块被另一个文件导入时，__name__的值就是该模块的名字

模块中的变量称为：属性
模块中的函数称为：方法

内置模块 python定义好的，可以直接导入使用
标准库模块 python标准库中的模块，可直接导入使用
第三方模块 需要自己下载安装才能使用
自定义模块 自己写的模块

string模块
string.ascii_letters:所有大小写字母
string.digits:所有数字

生成随机密码
from random import choice
from string import ascii_letters
from string import digits

all_choice = ascii_letters + digits + '_'

def pas(num=8):
    result = ''
    for i in range(num):
        tmp = choice(all_choice)
        result += tmp
    return result

if __name__ == '__main__':
    print(pas())
################################################################################################

Day04
shell相关模块：shutil
复制
#拷贝文件对象
with open('/etc/passwd','rb') as src_file:
    with open('/tmp/mima','wb') as dst_file:
        shutil.copyfileobj(src_file,dst_file)
#拷贝文件,只能拷贝文件
shutil.copyfile('/etc/passwd','/tmp/mima2')
#拷贝cpoy文件到文件或目录下，同时复制权限
shutil.copy('/etc/shadow','/tmp')
#与copy -p相同，但会尝试保留所有文件元数据
shutil.copy2()

移动
#递归地将文件或目录移动到另一个位置，并返回目标
shutil.move()

目录操作
#复制目录,如果目标目录存在会报错
shutil.copytree()
#删除目录
shutil.rmtree()

权限管理
#只复制权限
shutil.copymode(src,dst)
#复制元数据
shutil.copystat(src,dst)
更改给定路径的所有者或组
shutil.chown(path,user='',group='')

语法风格
变量赋值
x=y=1
x,y=1,2
a=10,b=20
a,b=b,a	//交换a，b的值

元组的()可以省略，逗号不可以省略
（1）不是元组
1，：是元组

合法表示符：主要针对起名（第一个必须时字母或下划线，剩下的可以时字母或下划线或数字，大小写敏感）
查看python中所有关键字
import keyword
print(keyword.kwlist)	//关键字列表
print(keyword.iskeyword('关键字'))	//检测是否为关键字

内建：内部已经写好的东西，有一些保留字如：True、False、None

模块结构及布局
#!/usr/bin/env python3		#起始行，声明解释器
"this is a test module"		#模块文档字符串
import sys				#导入模块
import os
debug = True			#定义全局变量
class FooClass(object):		#类定义
    'Foo class'
    pass
def test():				#函数定义
    "test function"
    foo = FooClass()
if __name__ == '__main__':	#程序主体
    test()

import os 
os.path.exists()	#判断文件是否存在，存在返回True

**************小练习*************
#!/usr/bin/env python3
#coding:utf-8
'''
编写一个程序，要求用户输入文件名
如果文件已存在，要求用户重新输入
提示用户输入数据，每行数据先写到列表中
将列表数据写入到用户输入的文件名中
'''
import os
#获取用户输入的文件名，并判断是否存在
def get_fname():
    while True:
        fname = input('Please input filename:')
        if not os.path.exists(fname):
            break
        print('file is exists! Please try again!')
    return fname
#获取用户输入的数据，并保存到列表
def get_data():
    print('请输入数据，输入end结束！')
    content = []
    while True:
        data = input('>>>')
        if data == 'end':
            break
        #content.append(data+'\n')
        content.append(data)
    return content
#将获取的数据写入文件中
def write_file(fname,data):
    with open(fname,'w') as f:
        f.writelines(data)
#习惯性在当前脚本中测试代码
if __name__ == '__main__':
    fname = get_fname()
    #data = get_data()
    data = [line+'\n' for line in get_data()]
    print(fname)
    print(data)
    write_file(fname,data)


序列操作符
seq[ind]		#获取下标元素
seq[ind1:ind2]	#截取ind1和ind2之间数
seq * expr		#重复expr次
seq1 + seq2		#连接序列seq1和seq2
obj in seq		#判断obj是否在seq中
obj not in seq	#判断obj是否不在seq中

内建函数
list(iter)	#把可迭代对象转换为列表
str(obj)	#将obj转换为字符串
tuple(iter)	#把可迭代对象转换为元组
len(seq)	#返回seq的长度
max(seq)	#求seq中最大值
min(seq)	#求seq中最小值
enumerate	#枚举，返回序列索引和索引位置对应的值,索引从0开始
sorted(iter) #接受一个迭代器,返回一个有序的列表,升序排列
reversed(seq) #接受一个序列作为参数,返回一个逆序排列的迭代器

字符串操作符
比较操作符:按ascii码进行比较
切片操作符:[],[:],[::]	[::-1]表示从后往前
成员关系操作符:in,not in

#!/usr/bin/env python3
'''
程序接受用户输入
判断用户输入的标识符是否合法
用户输入的标识符不能使用关键字
有不合法字符，需要指明第几个字符不合法
'''
import string
import keyword

#定义首字符和其余字符
first_char = string.ascii_letters+'_'
other_char = string.ascii_letters+string.digits+'_'

#检查用户输入字符是否合法
def check_id(idt):
    #判断首字符是否合法
    if idt[0] not in first_char:
        return '1st invalid'
    #判断其余字符是否合法
    for ind,val in enumerate(idt[1:]):
        if val not in other_char:
            return 'char in position %s invalid' %(ind+2)
    #判断是否为关键字
    if keyword.iskeyword(idt):
        return 'is keyword'
    #以上都不满足,则为合法字符
    return '%s is vaild' %idt

#测试
if __name__ == '__main__':
    print(check_id('8hello'))
    print(check_id('hell+o'))
    print(check_id('hello'))
    print(check_id('True'))


格式花操作符
%c 字符占位符
%s 字符串占位符
%d/%i 十进制数占位符
%o 八进制数占位符
%e/%E 科学计数法
%f/%F 浮点数占位符
print('%5.2f'%(2.5))	//宽度为5,保留2位小数
* 定义宽度或者小数点精度 %5.2f
- 左对齐
+ 右对齐
<sp> 正数前面显示空格
# 
0 位数不够使用0填充,不用空格

format函数
print('{1},{0}'.format('bob',23))	//按位置传参,{0}表示bob,{1}表示23
{:[填充字符,默认空格][对齐方式<^>][宽度]}
print('{1:^8},{0:>10}')	//填充<左对齐,^居中,>右对齐
print('{0[name]},{1[age]}'.format({'name':'bob'},{'age':24}))  //使用关键字参数
print('{0[0]},{0[1]}'.format(['bob',23]))   //使用索引

原始字符串操作符
alist = r'C:\test\nsd1809' //所有字符都不会转义,原样输出

import subprocess	//可以使用shell命令的模块
subprocess.call('cmd',shell=True)

创建随机密码的脚本randpass.py
from random import choice
from string import ascii_letters
from string import digits

all_choice = ascii_letters + digits + '_'

def pas(num=8):
    result = ''
    for i in range(num):
        tmp = choice(all_choice)
        result += tmp
    return result

if __name__ == '__main__':
    print(pas())

创建用户脚本
  编写一个程序，实现创建用户的功能
  提示用户输入用户名
  随机生成8位密码
  创建用户并设置密码
  将用户相关信息写入指定文件

import subprocess
import randpass	//调用随机密码的模块

def create_user(user,pwd,file):
    subprocess.call('useradd %s' %user,shell=True)
    subprocess.call(
        'echo %s | passwd --stdin %s' %(pwd,user),
        shell=True
    )
    with open(file,'a') as f:
        f.write('user:%s\npwd:%s\n' %(user,pwd))

if __name__ == '__main__':
    user = 'nsd'
    pwd = randpass.pas(16)
    file = '/tmp/a.txt'
    create_user(user,pwd,file)


字符串内建函数
调用方式 字符串.函数
string.capitalize()	//字符串的第一个字符大写
string.title()	//单词首字母大写

string.center(width,'*')	//居中字符串,指定长度为width,默认空格填充,也可手工修改填充字符
string.ljust(width,'*')  //指定长度为width,用*填充,并左对齐
string.rjust(width,'*')  //指定长度为width,用*填充,并右对齐

string.count(str,beg=0,end=len(string))  //统计str出现的次数,可以设定范围

string.endswith(obj,beg=0,end=len(string))  //判断是否以obj结束,是返回True,否则False
string.startwith(同上)	//判断开始字符串,返回True或False

string.islower()	//判断是否全为小写,是返回True,否则False
string.isupper()	//判断是否全为大写,是返回True,否则False

string.isdigit()	//判断是否为数字
string.isalpha()	//判断是否为字母
string.isalnum()	//判断是否为数字或字母

string.strip()	//删除string字符串两端的空白
string.lstrip()	//删除左边空白字符
string.rstrip()	//删除右边空白字符

string.upper()	//将小写字母转换为大写字母
string.lower()	//将大写字母转换为小写字母

string.split('str',num=string.count(str))  //分隔字符串,以str分隔
print(string.split())
print('*'.join(list)) 	//以*将列表中字符串拼接起来

列表
通过下标只能更新值，不能添加新值
list.append(5)	#向列表末尾添加一个值5
list.index(60)	#获取列表中60的下标值
list.insert(index,value)	#向列表中指定的位置插入值
list.count(60)	#统计60的出现次数
list.remove(60)	#删除第一个出现的值60
list.pop(2)		#弹出下标为2的值
list.reverse()	#翻转
list.sort()		#升序排序
list.sor(reverser=True)	#直接降序排列
list.extend(seq)	#把序列seq内容添加到列表中

元组
静态的列表，元素组本身不可增删改，但元素中的列表、字典等元素仍可以改变
tuple.count()	#统计出现次数
tuple.index()	#查询值的下标

编程思路：
1、思考
程序运行方式：交互？非交互？
如果交互，如何提示用户输入，用户如何回答，直到结束
2、分析程序有哪些功能，把这些功能写成函数，写出程序的大体框架
3、逐一编写每个函数
4、测试代码，修补

#coding:utf-8
#列表模拟栈结构
#栈：先进后出的结构,后出先进结构
# import os
import subprocess

stack = []
#压栈功能
def push_it():
    subprocess.call('clear')
    data = input('data to push:').strip()
    if data:
        stack.append(data)
        print('\033[31;1msucessful!\033[0m')

#出栈功能
def pop_it():
    subprocess.call('clear')
    if stack:
        print('from stack popped \033[31;1m%s\033[0m' %stack.pop())
    else:
        print('\033[31;1mEmpty stack!\033[0m')

#查询功能
def view_it():
    subprocess.call('clear')
    print('\033[32;1m%s\033[0m' %stack)

#菜单功能
def show_menu():
    cmds = {'0':push_it,'1':pop_it,'2':view_it}
    alist = ['0','1','2','3']
    prompt = '''[0] push
[1] pop
[2] view
[3] quit
Please input your choice (0/1/2/3):'''
    while True:
        choice = input(prompt).strip()
        if choice not in alist:
            subprocess.call('clear')
            print('Invalid choice.Try again!')
            continue
        if choice == '3':
            break

        cmds[choice]() 	#cmds['0']()=>push_it()
        # if choice == '0':
        #     push_it()
        # elif choice == '1':
        #     pop_it()
        # else:
        #     view_it()


if __name__ == '__main__':
    show_menu()

########################################################################################################

python2
Day01
学习方法；
1.清楚难点、重点。先掌握重点知识
2.记主要内容，其他的要了解功能
3.编程思路
4.代码量

git pull https://github.com/MrZhangzhg/nsd_2018.git

字典：容器、可变、映射
1、创建字典的方式
adict = {'name':'bob','age':24}
bdict = dict(['ab',['qq','62121878'],('phone','13828456471')])
cdict = {}.fromkeys(('ab','ls','cd'),8)
2、访问字典
只能访问字典的键key，得到值，不能直接访问值
print(len(adict))
for key in adict:
    print('%s:%s' %(key,adict[key]))
print('%(name)s is %(age)s year old' %adict)
3、更新字典
字典的key不能重复
通过key更新字典，有则更新，没有添加

字典的相关函数
不可变的才可以作为key，可变的不能作为key
dict.len()		#返回字典长度
dict.hash()		#判断是否可以作为字典的键
dict.keys()		#取出字典的key
dict.values()	#取出字典的value
dict.items()	#取出字典的键和值
dict.get(key,'指定返回值')		#重点，通过键寻找值，找到返回值，没找到默认返回None，也可以指定返回值
adict = {'name':'bob','age':24}
print(adict.get('qq'))	==>None
print(adict.get('qq','not found'))	==>not found
print(adict.get('name','not found'))	==>bob

dict.pop(key)		#弹出指定key，value
dict.popitem()	#随机弹出一对键值
bdict = adict	#两个字典指向同一个地址空间
id(adict)		#查看字典在内存中的地址

dict.copy()		#重新拷贝一份内容
cdict = adict.copy()	#内容相同，空间地址不同，复制了一份

dict.update(dict)	#合并其他字典
dict.clear()	#清空字典
del dict[key]	#删除字典中的元素，也可以删除整个字典

练习一：模拟用户登陆信息系统
支持新用户注册，新用户名和密码注册到字典中
支持老用户登陆，用户名和密码正确提示登陆成功
主程序通过循环询问进行何种操作，根据用户的选择，执行注册或是登陆操作
#coding:utf-8
import getpass
import subprocess
user = {}

def register():
    subprocess.call('clear')
    username = input('请输入用户名：')
    passwd = getpass.getpass('请输入密码：')
    if username in user:
        print('\033[31;1m用户%s以存在，注册失败！\033[0m' %username)
    else:
        user[username] = passwd

def login():
    subprocess.call('clear')
    username = input('请输入用户名：')
    passwd = getpass.getpass('请输入密码：')
    # if username in user and passwd == user[username]:
    if user.get(username) == passwd:
        print('\033[32;1m登陆成功！\033[0m')
    else:
        print('\033[31;1m登陆失败!\033[0m')

def show_menu():
    cmds = {'0':register,'1':login}
    prompt = '''[0]注册
[1]登陆
[2]退出 
请选择：'''
    while True:
        choice = input(prompt).strip()
        if choice not in ['0','1','2']:
            print('无效选择，请重试！')
            continue
        if choice == '2':
            break
        cmds[choice]()

if __name__ == '__main__':
    show_menu()

cd - 	//切回上次目录
空白字符：空格、\n回车、\t制表符、\r回车不换行、\v\f

练习二：编写unix2dos的程序
#coding:utf-8
'''
Windows文本文件的行结束标志是\r\n
类unix文本文件的行结束标志是\n
编写程序，将unix文本文件格式转换为windows文本文件的格式
'''

import sys

def unxin2doc(fname):
    dst_fname = fname + '.txt'
    with open(fname) as src_fobj:
        with open(dst_fname,'w') as dst_fobj:
            for line in src_fobj:
                line = line.rstrip('\n\r ') + '\r\n'
                dst_fobj.write(line)


if __name__ == '__main__':
    unxin2doc(sys.argv[1])


练习三：编写类进度条程序
在屏幕上打印20个#号
符号@从20个#号穿过
当@符号到达尾部，再从头开始
#coding:utf-8

import time

counter = 19
n = 0

print('*' * counter,end='')
while True:
    print('\r%s@%s' %('*' * n,'*' * (counter - n)),end='')
    n += 1
    time.sleep(0.3)
    if n == counter:
        n = 0

集合：由不同的、不可变元素构成一个集合，它是无序的
集合类似一个没有值的字典，只有键
可变的集合：set
不可变的集合：frozenset
aset = set('abc')
bset = set('cde')
aset | bset 	#并集
aset & bset		#交集
aset - bset		#补差，aset中有bset中没有的
aset.add('new')	#添加new到集合，add是将new这个整体添加，可变的类型不可添加
aset.update()	#将字符串、列表等拆分成单个加入到集合中
bset.issubset(aset)  #判断bset是否为aset的子集
aset.issuperset(bset)  #判断aset是否为bset的超集
aset.union(bset)	# aset | bset
aset.intersection(bset)  # aset & bset 
aset.difference(bset) 	# aset - bset

通过集合可以去重
import random
alist = [random.randint(1,20) for i in range(20)]	
aset = set(alist)	#将列表转换为集合
blist = list(aset)	#将集合转换为列表

时间表示方式：重要
import time
1、时间戳：某一时刻距离1970年1月1日0点的妙数，time.time()查看到目前为止的秒数
2、UTC：世界协调时间。把全球分为24个时区，以格林威治为分隔点，中国utc+8，time.ctime()查看当前时间
3、9元组：time.localtime()
>>>t = time.localtime()
>>>t.tm_year	#年份
>>>t.tm_wday	#周几，0-6

time模块常用方法：
time.time()	#返回当前时间的时间戳
time.ctime()	#返回当前时间的UTC形式
time.localtime()	#返回当前时间的9元组
time.sleep(3)	#休眠3秒
time.strftime('%F')	#显示年月日，可以打印以下所有属性

%a	Locale的缩写工作日名称。	
%A	Locale的整个工作日名称。	
%b	语言环境的缩写月份名称。	
%B	Locale的完整月份名称。	
%c	语言环境的适当日期和时间表示。	
%d	一个十进制数字[01,31]。	
%H	小时（24小时制），十进制数[00,23]。	
%I	小时（12小时制）十进制数[01,12]。	
%j	一年中的十进制数[001,366]。	
%m	月为十进制数[01,12]。	
%M	以十进制数分钟[00,59]。	
%p	Locale相当于AM或PM。	
%S	秒为十进制数[00,61]。
%U	年的星期数（星期日为星期的第一天）为十进制数[00,53]。在第一个星期日之前的新的一年的所有天被认为是在第0周。	
%w	工作日为十进制数[0（星期日），6]。	
%W	年的星期数（星期一作为星期的第一天）作为十进制数[00,53]。在第一个星期一之前的新的一年中的所有天被认为是在第0周。	（3）
%x	语言环境的适当日期表示。	
%X	语言环境的适当时间表示。	
%y	年，无世纪作为十进制数[00,99]。	
%Y	年份以世纪为十进制数。	
%z	指示与+ HHMM或-HHMM形式的UTC / GMT的正或负时差的时区偏移，其中H表示十进制小时数字，M表示十进制分数字[-23：59，+23：59]。	
%Z	时区名称（如果没有时区，则不包含字符）。	
%%	字面值'%'字符。

datetime模块
from datetime import datetime
t = datetime.now()	#年月日时分妙毫秒
t.year
t.month
t.day
t.hour
t.minute
t.second
t.microsecond	#毫秒
t1 = datetime(2018,10,1,...)
t > t1	#比较时间

时间计算
from datetime import timedelta	
days = timedelta(days=50,hour=5,...)
t - days	#50天以前的时间
t + days	#50天以后的时间
https://yiyibooks.cn ==> python352中文官方文档翻译 ==> 库参考中

异常处理
将异常自行处理，不要让系统崩溃，使用try-except语句
#coding:utf-8
try:
    num = int(input('数字：'))
    result = 100 / num
    
except (ValueError,ZeroDivisionError):	#多个条件用(，)间隔
    print('无效输入！')
# except ZeroDivisionError:
#     print('无效输入')
except (EOFError,KeyboardInterrupt):
    print('\n手动退出')
    exit()
# except KeyboardInterrupt:
#     print('\n退出')
#     exit()
else:		#不发生异常才执行
    print(result)	
finally:	#不管异常发不发生都会执行
    print('Done')

主动触发异常
1、使用raise触发异常
def set_age(name,age):
    if not 0 < age < 120:
        raise ValueError('年龄超过范围')
    print('%s is %s years old' %(name,age))
２、使用assert断言异常
def set_age1(name,age):
    assert 0 < age < 120,'年龄超过范围'
    print('%s is %s years old' %(name,age))
常用组合try-except和try-finally

os模块，访问文件系统
os.getcwd()		#pwd
os.mkdir('/tmp/mydemo')	#mkdir /tmp/mydemo
os.listdir('/tmp/mydemo')	#ls /tmp/mydemo
os.chdir('/tmp/mydemo')		#cd /tmp/mydemo
os.mknod('abc.txt')		#touch abc.txt
os.chmod('abc.txt',0o644)	#chmod 644 abc.txt，linux权限是8进制数，o表示8进制数
os.symlink('/etc/hosts','zj')	#ln -s /etc/hosts zj，软连接
os.unlink('zj')		#unlink zj，删除快捷方式
os.remove('zj')		#rm zj
os.path.isfile('/etc/hosts')	#判断是否是文件
os.path.isdir('/etc/hosts')	#判断是否是目录
os.path.islink('/etc/grub2.cfg')	#判断是否是软连接
os.path.exists('/etc')	#判断是否存在
os.path.split('/etc/sysconfig/network-scripts/ifcfg-eth0') #切割路径
('/etc/sysconfig/network-scripts', 'ifcfg-eth0')
os.path.join('/etc/sysconfig/network-scripts', 'ifcfg-eth0')	#拼接路径
os.path.basename('/etc/sysconfig/network-scripts/ifcfg-eth0')	#获取最后文档名
os.path.dirname('/etc/sysconfig/network-scripts/ifcfg-eth0')	#获取目录名

pickle模块
常规文件写操作，只能把字符串对象写入。如果希望写入任意类型数据，取出时不变，使用pickle模块
pickle是个存储器，可以把任意类型的数据写到文件中，还能再无损地取出来。
>>> import pickle
>>> shoplist = ['egg', 'banana', 'apple', 'brush']
>>> f = open('/tmp/shop.data', 'wb')
>>> pickle.dump(shoplist, f)	#将列表写入文件

>>> f = open('/tmp/shop.data', 'rb')
>>> alist = pickle.load(f)	#读取文件内容
>>> type(alist)
<class 'list'>
>>> alist
['egg', 'banana', 'apple', 'brush']

#######################################################################################################

Day02
函数
创建函数，未声明的函数不能对其进行调用def md5(dir):
    

def foo():
    print('in foo')
    bar()
foo()		#此处调用函数会报错，找不到bar函数，因为程序从上向下执行
def bar():
    print('in bar')

if __name__ == '__main__':
    foo()
调用函数
使用()，不加()只是引用函数，显示函数在内存中的位置
关键字参数
参数的个数必须与指定的参数个数相同
def get_age(name,age):
    print('%s is %s years old' %(name,age))
get_age(age=20,name='bob')	#默认参数时从前往后一一对应，否则需用此种方式指定参数值

参数个数不固定的函数
def func1(*args):		#*args表示一个元组，可以接收任意多个参数 
    print(args)
func1()
func1(20)
func1(10,20,30,'bob','alias')

def func2(**kwargs):	#**kwargs表示一个字典，存储键值对，接收多个参数
    print(kwargs)
func2()
func2(name='bob',age=20)

函数传递参数时，如果使用*号，表示把这个参数的值拆开
def add(x,y):
    print(x + y)
num = [20,15]
add(*num)		#将列表的值拆开传参

#加减法小游戏
#coding:utf-8
import random

def exam():
    cmds = {'+':lambda x,y : x + y,'-':lambda x,y: x - y}
    nums = [random.randint(1,100) for i in range(2)]
    nums.sort(reverse=True)
    op = random.choice('+-')
    result = cmds[op](*nums)
    prompt = '%s %s %s = ' %(nums[0],op,nums[1])
    counter = 0
    while counter < 3:
        try:
            answer = int(input(prompt))
        except:     #except为空表示匹配所有异常,不推荐
            print()
            continue
        if answer == result:
            print('\nVery good!')
            break
        # else:
        print('\nWrong answer!')
        counter += 1
    else:
        print('%s%s' %(prompt,result))

def main():
    while True:
        exam()
        try:
            yn = input('Contine(y/n)?').strip()[0]
        except IndexError:
            continue
        except (KeyboardInterrupt,EOFError):
            yn = 'n'
        if yn in 'nN':
            print('\nByeBye!')
            break

if __name__ == '__main__':
    main()

匿名函数:没有名称的函数,通过lambda定义
a = lambda x,y: x + y	#x,y是两个参数,x+y是返回结果
a(10,20)

filter(func,seq)函数
import random

def func1(x):   # 接收整数作为参数
    return x % 2    # 1为True，0为False

if __name__ == '__main__':
    nums = [random.randint(1, 100) for i in range(10)]
    # [36, 73, 74, 50, 44, 41, 45, 79, 72, 74]
    print(nums)
    # filter的第一个参数是函数，nums中各项将会当成func1的参数
    # 经过func1的计算，如果返回值是True则保留，False舍弃
    result = filter(func1, nums)
    result2 = filter(lambda x: x % 2, nums)	#使用匿名函数
    print(list(result))
    print(list(result2))

map(func,seq)函数
用函数处理seq中的每个元素并保留结果
result = map(lambda x: x * 2 + 1, nums)
print(list(result))

变量
1、全局变量：在函数外面定义的变量。作用域整个程序中都可以调用，直到程序结束
2、局部变量：在函数内部定义的变量。作用域只在函数内可用，函数调用结束，局部变量消失
3、全局和局部如果有同名的变量，函数调用时，首先查找局部。局部变量将会把全局变量遮盖住。
x = 10
def func():
    x = 'hello'
    print(x)
func()	#局部x，值是hello
x		#全局x，值是10
4、在函数内部使用global语句，调用全局变量
x = 10
def add():
    global x
    x += 10
    print(x)
add()		#x的值为20
print(x)	#x的值为20

名字空间
系统查询顺序：查找局部变量，全局变量，内建变量

偏函数：相当于改造现有函数，将一些参数固定下来后，生成新的函数
>>>from functools import partial
>>> def add(a, b, c, d, e):
...     return a + b + c + d + e
函数接受5个参数，但是大多数情况下，调用函数，前4个参数是固定的
>>> add(10, 20, 30, 40, 5)
>>> add(10, 20, 30, 40, 8)
可以改造add函数，将前4个参数固定，生成的新函数取名为myadd
>>> myadd = partial(add, 10, 20, 30, 40)
>>> myadd(5)
>>> myadd(8)

简单的GUI程序代码
#导入模块
import tkinter
from functools import partial

#定义windows句柄
window = tkinter.Tk()
#定义界面标签显示内容
lb = tkinter.Label(window,text='Hello world!')
#使用偏函数定义tkinter.Button函数
MyButton = partial(tkinter.Button,window,fg='white',bg='blue')
#定义三个按钮内容
b1 = MyButton(text='button 1')
b2 = MyButton(text='button 2')
b3 = MyButton(text='button 3',command=window.quit) #选择3退出
#使用for循环安装3个按钮
for i in (lb,b1,b2,b3):
    i.pack()
#主程序方法，显示窗口
window.mainloop()

Tkinter： Tkinter 模块(Tk 接口)是 Python 的标准 Tk GUI 工具包的接口 .Tk 和 Tkinter 可以在大多数的 Unix 平台下使用,同样可以应用在 Windows 和 Macintosh 系统里。Tk8.0 的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。
Label	标签控件；可以显示文本和位图
Button 按钮控件；在程序中显示按钮。
Text	文本控件；用于显示多行文本

递归函数
快速排序：将第一个数假设为中间值，比它小的放到小列表，大的放到大列表，再把这三项拼接起来。
小列表、大列表仍然要用同样的方法继承排序
import random
def sort(seq):
    if len(seq) < 2:
        return seq

    middle = seq[0]
    smaller = []
    larger = []
    for i in seq[1:]:
        if middle > i:
            smaller.append(i)
        else:
            larger.append(i)
    return sort(smaller) + [middle] + sort(larger)

if __name__ == '__main__':   
    nums = [random.randint(1,100) for i in range(10)]
    print(nums)
    print(sort(nums))

#冒泡排序
def sort(seq):
    count = len(seq)
    for i in range(0,count):
        for j in range(i+1,count):
            if seq[i] > seq[j]:
                seq[i],seq[j] = seq[j],seq[i]
    return seq
if __name__ == '__main__':
    nums = [random.randint(1,100) for i in range(10)]
    print(nums)
    print(sort(nums))

生成器：本质上是一个函数。常规的函数只能通过return返回一个结果，但是生成器可以通过yield语句返回多个中间结果。
程序遇到yield会暂停,直到再向生成器取数据时继续执行
def mygen():
    yield 'hello world'
    a = 10 + 320
    yield a
    yield [1,2,3]
a = mygen()
a.__next__()	#一个一个值调出，且只能调用一次
for i in a:		#一般使用for循环调用
    print(i)

每次取文件中10行内容并打印
def blocks(fobj):
    content = []
    counter = 0
    for line in fobj:
        content.append(line)    # 向列表追加数据
        counter += 1
        if counter == 10:   # 如果已经向列表追加了10行，则生成
            yield content   # 遇到yield，返回数据，暂停执行，直到再向生成器取数据时才继续向下执行
            content.clear() # 生成完数据后，再把列表清空
            counter = 0     # 计数器清0
    if content:
        yield content   # 如果最后不足10行，也要把它返回


if __name__ == '__main__':
    fname = '/etc/passwd'
    with open(fname) as fobj:
        for lines in blocks(fobj):  # blocks是一个生成器，每次返回10行
            print(lines)
            print('*' * 20)

闭包：自定义函数中嵌套自定义函数
def say_hi(word):
    def greet():
        lb.config(text='Hello %s' % word)
    return greet

装饰器：也是闭包
def hello():
    return 'Hello World!'

@set_color	#相当于将welcome传入set_color中
def welcome():
    return 'Hello China'

def set_color(func):
    def color():
        return '\033[31;1m%s\033[0m' % func()
    return color

if __name__ == '__main__':
    a = set_color(hello)
    print(a())
    b = set_color(welcome)
    print(b())

查看系统模块文件：按住ctrl会变成超连接
###########################################################################################

Day03

模块
1、模块导入的时候会搜索两个路径
（1）sys.path定义的路径,可以在python中查询已定义路径，''表示当前路径
（2）PYTHONPATH环境变量定义的路径
2、导入模块的方法
import time,os,sys	#导入多个模块，不推荐此写法
from random import choice	#导入模块中某个函数
import pickle as p	#导入模块并定义别名
3、模块文件导入和加载
一个模块不管被导入多少次，只会被加载一次

包
1、类似文件的目录，可以当成特殊的模块
sys.path.clear()	#实际存放的方式是sys/path/clear.py
2、如果是python2，需在目录下创建__init__.py文件才能成为包
3、写到__init__.py文件中的内容将成为包的内容(python2/3一样)

绝对导入
sys.path和PYTHONPATH
相对导入
from . import xxx	#当前目录导入xxx模块
from .. import xxx #上一级目录导入xxx模块

内置模块
www.cmd5.com	#密文查询明文网站
hashlib模块
1、md5：是一种单向加密的算法。
/etc/shadow中加密用的是sha512加密方式
单向加密就是相同的数据总是能生成相同长度的乱码。源数据相同，乱码也一定是相同的。
不能通过乱码反推回原始数据。可以用来存储密码，也可以用来校验文件的完整性。
2、应用
>>> import hashlib
>>> m = hashlib.md5(b'123456')
>>> m.hexdigest()

>>> with open('/etc/passwd', 'rb') as fobj:
...     data = fobj.read()
>>> m = hashlib.md5(data)
>>> m.hexdigest()

#生成文件md5值的程序
import sys
import hashlib

def check_md5(fname):
    m = hashlib.md5()
    with open(fname,'rb') as fobj:
        while True:
            data = fobj.read(4096)
            if not data:
                break
            m.update(data)
    return m.hexdigest()

if __name__ == '__main__':
    print(check_md5(sys.argv[1]))

tarfile模块
创建tar文件，支持gzip、bzip2格式
1、压缩
>>> import tarfile
>>> tar = tarfile.open('/tmp/mydemo/anquan.tar.gz', 'w:gz')	#以gz格式创建并打开一个压缩文件
>>> tar.add('/etc/hosts')	#向压缩文件中添加需要压缩的文件
>>> import os
>>> os.chdir('/etc')	#切换目录到/etc下
>>> tar.add('security')
>>> tar.close()
2、解压
>>> os.chdir('/tmp/mydemo')
>>> tar = tarfile.open('/tmp/mydemo/anquan.tar.gz', 'r:gz')	#以gz格式打开压缩文件
>>> tar.extractall()	#解压缩
>>> tar.close()

备份文档程序
'''
    需要支持完全和增量备份
    周一执行完全备份
    其他时间执行增量备份
    备份文件需要打包为tar文件并使用gzip格式压缩
'''
from time import strftime
import os
import tarfile
import pickle
import hashlib

#校验文件md5值
def check_md5(fname):
    m = hashlib.md5()
    with open(fname, 'rb') as fobj:
        while True:
            data = fobj.read(4096)
            if not data:
                break
            m.update(data)	#更新md5值
    return m.hexdigest()		#返回文件的md5值

#完全备份
def full_back(src,dest,md5file):
    #打包整个文件，并且计算每个文件的md5值
    #备份名：文件名_完全/增量_时间.tar.gz
    fname = os.path.basename(src.rstrip('/'))	#获取最右边名字，并取消/
    fname = '%s_full_%s.tar.gz' %(fname,strftime('%Y%m%d'))
    fname = os.path.join(dest,fname)	#拼接文件的绝对路径

     #打包文件
    tar = tarfile.open(fname,'w:gz')
    tar.add(src)
    tar.close()

     #对应每个文件生成md5值保存到字典中
    md5_dict = {}
    #os.walk递归显示文件，元组形式，第一项是文件目录，第二项是目录下的目录，第三项是目录中的文件，拼接1，3即绝对路径
    for path,dir,files in os.walk(src):	#遍历目录文件
        for file in files:		#遍历目录下的文件
            full_file = os.path.join(path,file)	#将目录名和文件名拼接，得到绝对路径
            md5_dict[full_file] = check_md5(full_file)	#获得每个文件md5值

     #将字典存入文件，永久保存
    with open(md5file,'wb') as fobj:
        pickle.dump(md5_dict,fobj)

def incr_back(src,dest,md5file):
    fname = os.path.basename(src.rstrip('/'))
    fname = '%s_incr_%s.tar.gz' % (fname, strftime('%Y%m%d'))
    fname = os.path.join(dest, fname)

    with open(md5file,'rb') as fobj:
        old_md5 = pickle.load(fobj)

    new_md5 = {}
    for path, dir, files in os.walk(src):
        for file in files:
            full_file = os.path.join(path, file)
            new_md5[full_file] = check_md5(full_file)

    tar = tarfile.open(fname,'w:gz')
    for key in new_md5:
	  #if key not in old_md5 or new_md5[key] != old_md5[key]:
        if old_md5.get(key) != new_md5[key]:	#判断老的字典中是否有新字典的值且相等，没有或不等则备份
            tar.add(key)
    tar.close()

    with open(md5file,'wb') as fobj:	#更新md5文件
        pickle.dump(new_md5,fobj)

if __name__ == '__main__':
    src = '/tmp/mydemo/security/'
    dest = '/tmp/mydemo/'
    md5file = '/tmp/mydemo/md5.data'
    if strftime('%a') == 'Mon':
        full_back(src,dest,md5file)
    else:
        incr_back(src,dest,md5file)


OOP：面向对象的编程
将数据和行为进行融合。可以先创建一个蓝图，然后再根据蓝图创建具体的实例。
可以极大的减少代码量
class Bear():   #定义类
    def __init__(self,color,size):
        #在实例化的时候，自动调用。实例自动成为第一个参数self
        self.color = color  #把属性绑定到具体的实例
        self.size = size

    def sing(self):
        print('My is %s!' %self.size)

if __name__ == '__main__':
    bear_big = Bear('brown','large')    #创建实例
    print(bear_big.color,bear_big.size)
    bear_big.sing()     #实例bear_big自动成为第一个参数传递

    bear2 = Bear('brown','middle')
    bear2.sing()	#bear2自动成为第一个参数


修改全文某个单词：选中单词shift + f6
组合：在类中加入其他的类增加功能
class Vendor:
    def __init__(self, ph):
        self.phone = ph

class Bear:
    def __init__(self, color, size, phone):
        self.color = color  # 把属性绑定到具体的实例
        self.size = size
        self.vendor = Vendor(phone)	#类中调用其他类，组合

    def sing(self):
        print("My color is %s, Lalala" % self.color)

if __name__ == '__main__':
    bear1 = Bear('Brown', 'Large', '400-123-5678')
    print(bear1.vendor.phone)
    v1 = Vendor('400-111-2222')
    print(v1.phone)

创建子类（派生或继承）
在圆括号中写明父类名即可继承其所有属性和方法
若子类和父类有相同的方法，父类将被覆盖，若不想覆盖，明确指明使用父类的方法，可用super函数
class Bear():   #定义类
    def __init__(self,color,size):
        #在实例化的时候，自动调用。实例自动成为第一个参数self
        self.color = color  #把属性绑定到具体的实例
        self.size = size

    def sing(self):
        print('My is %s!' % self.size)

class NewBear(Bear):	#创建子类，包含父类(基类)的所有方法和属性，还有自身额外的一些属性和方法
    def __init__(self,name,color,size):
        #Bear.__init__(self,color,size)	#效果与下相同，但不推荐，尽量不要出现父类名字
        super(NewBear, self).__init__(color,size)  #推荐写法，调用父类方法
        self.name = name

    def run(self):
        print('I can run...')

if __name__ == '__main__':
    bear1 = NewBear('brown','larger')
    print(bear1.color,bear1.size)
    bear1.run()
    print(bear1.name)

多重继承：一个子类可以拥有多个父类的属性
若父类中有相同的方法，子类查找顺序：自身查找-->从左向右，找到第一个就停止
class A():
    def hello(self):
        print('hello')

class B():
    def welcome(self):
        print('welcome')

class C(A,B):	#继承多个父类
    pass

if __name__ == '__main__':
    mc = C()
    mc.hello()
    mc.welcome()

特殊方法
OOP编程时，有一些以__开头和结尾的方法，被称作magic魔法方法
class Book():
    def __init__(self,title,author):	#构造函数，默认会第一个调用此方法
        self.title = title
        self.author = author

    def __str__(self):	#用于将值转化为适于人阅读的形式
        return '《%s》'%self.title

    def __call__(self):	#调用类时使用此方法
        print('《%s》is written by %s' %(self.title,self.author))

if __name__ == '__main__':
    core_py = Book('Core Python','Wesley')	#调用__init__
    print(core_py)	#调用__str__
    core_py()		#调用__call__

类方法
1、使用classmethod装饰器定义，第一个参数cls表示类本身（了解即可）
2、静态方法staticmethod
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    @classmethod   # 声明成类方法，没有实例也可以调用
    def create_date(cls, str_date):  # cls表示类Date,不是实例
        """
        一般来说，需要先创建实例，再通过实例调用方法。没有实例就需要调用方法
        可以将方法声明为类方法。
        """
        date_list = str_date.split('-')
        y = int(date_list[0])
        m = int(date_list[1])
        d = int(date_list[2])
        return cls(y, m, d)

    @staticmethod  # 定义静态方法。相当于跟类没有任何关系，硬塞到类中的方法
    def is_date_valid(str_date):
        y, m, d = map(int, str_date.split('-'))
        return y < 4000 and 1 <= m <= 12 and 1 <= d <=31

if __name__ == '__main__':
    d1 = Date(2019, 2, 20)
    d2 = Date.create_date('2019-2-21')  # 通过类方法创建实例
    print(d2.year)
    print(Date.is_date_valid('2019-2-2'))
############################################################################################

Day04
正则表达式
匹配单个字符
.	匹配任意单个字符
[]	匹配字符组中的任意单个字符
[^]	匹配不在字符组中的字符
\d	匹配数字，相当于[0-9]
\D	\d取反
\w	匹配数字、字母、下划线，[0-9a-Z_]
\W	\w取反
\s	匹配空白字符，相当于[\r\v\f\t\n]
\S	\s取反
匹配一组字符
re1 | re2	匹配正则re1或re2
*		匹配前一个字符任意次数
+		匹配前一个字符出现最少一次
?		匹配前一个字符出现最多一次
{M,N}		匹配前一个字符出现最少M次最多N此
其他元字符
^	匹配字符串开头
$	匹配字符串结尾
\b	匹配单词边界
()	对正则表达式分组
\nn	匹配已保存的子组

贪婪匹配：*、+、？都是贪婪匹配操作符，在其后加上？可以取消贪婪匹配行为（就是最短匹配）

核心函数和方法
re模块
>>> import re
>>> re.match('f..', 'food')  # 如果匹配到模式，返回匹配对象
>>> print(re.match('f..', 'seafood'))   # 没匹配到返回None
>>> m = re.match('f..', 'food')
>>> m.group()   # 通过group方法获取匹配结果
>>> m = re.search('f..', 'seafood')
>>> m.group()

>>> re.findall('f..', 'seafood is food')	#返回匹配到的内容
>>> re.finditer( 'f..', 'seafood is food')
>>> list(re.finditer( 'f..', 'seafood is food'))
finditer将匹配到的所有匹配对象组成一个匹配列表
>>> for m in re.finditer('f..', 'seafood is food'):
...     m.group()

>>> re.split('\.|-', 'hello-world.tar.gz')  # 以点和-作为分隔符切分
>>> re.sub('x', 'zs', 'Hi x. nice to meet you, x.')  # 把x替换为zs

如果匹配的数量非常大，可以把模式先编译，以提升效率
>>> patt = re.compile('f..')
>>> m = patt.search('seafood')
>>> m.group()
>>> patt.findall('seafood is food')

'''
编写count_patt.py脚本，实现一个apche日志分析脚本：

    统计每个客户端访问apache服务器的次数
    将统计信息通过字典的方式显示出来
    分别统计客户端是Firefox和MSIE的访问次数
    分别使用函数式编程和面向对象编程的方式实现
'''
import re

#使用对象模式
class CountPatt():
    def __init__(self,fname):
        self.name = fname

    def count_patt(self,patt):
        cpatt = re.compile(patt)
        patt_dict = {}
        with open(self.name) as fobj:
            for line in fobj:
                m = cpatt.search(line)
                if m:
                    key = m.group()
                    patt_dict[key] = patt_dict.get(key,0) + 1
        return patt_dict

#使用函数模式
def count_patt(fname, patt):
    cpatt = re.compile(patt)  # 编译模式，提升效率
    patt_dict = {}
    with open(fname) as fobj:
        for line in fobj:
            m = cpatt.search(line)
            if m:  # 如果匹配到了，返回的是匹配对象，非空即为真，没匹配到是None，None是假
                key = m.group()
                # if key not in patt_dict:
                #     patt_dict[key] = 1
                # else:
                #     patt_dict[key] += 1
                patt_dict[key] = patt_dict.get(key, 0) + 1
    return patt_dict

if __name__ == '__main__':
    fname = 'access_log'
    ip = '^(\d+\.){3}\d+'   # 1.10.125.3, 1000.12345.23.1234567
    print(count_patt(fname, ip))
    br = 'Chrome|Firefox|MSIE'
    print(count_patt(fname, br))
    print(count_patt('/etc/passwd', 'bash$|nologin$'))
    w = CountPatt(fname)		#定义实例
    print(w.count_patt(br))

socket模块：网络编程的底层模块
套接字：抽象概念，可以想象成网卡接口。需要绑定地址信息(TCP/UDP、IP地址、端口)
TCP服务器创建过程
addr = ('127.0.0.1','12345')
s = socket.socket()	#创建套接字
s.bind(addr)	#绑定地址和端口到套接字
s.listen()	#启动监听
s.accept()	#接受客户端连接(数据，地址端口)
recv()/sedn()	#与客户端通信
s.close()	#关闭套接字

TCP客户端创建过程
addr = ('127.0.0.1','12345')
c = socket.socket()	#创建套接字
c.connect(addr)		#请求建立连接
c.send()/c.recv()		#与服务器通信
c.close		#关闭套接字

UDP服务器创建过程
addr = ('127.0.0.1','12345')
s = socket.socket()	
s.bind(addr)
s.recvfrom()/s.sendto()
s.close

UDP客户端创建过程
c = socket.socket()
c.sendto()/c.recvfrom()
c.close()

#创建TCP服务器
import socket

host = ''   # 0.0.0.0
port = 12345
addr = (host, port)
s = socket.socket()  # 默认创建TCP套接字
# 当程序结束后，系统默认会把地址保留1分钟，1分钟内任何程序都无法使用这个端口
# 加上以下选项，可以立即重新运行起来服务
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(addr)   # 将地址绑定到套接字
s.listen(1)  # 启动监听，1表示允许的客户端数目，必须提供，但是没有太大意义
cli_sock, cli_addr = s.accept()  # 接收客户端的连接请求，返回元组(客户机套接字, 客户机地址)
data = cli_sock.recv(1024)  # 一次最多接收1024字节，类似于文件的read
print(data)
print(data.decode())  # 将bytes类型转换成utf8字符
sdata = '吃了吗？\r\n'  # 网络发送数据一般结尾是回车换行
# sdata是UTF8编码，发送的时候，用encode把UTF8编码转成bytes类型
cli_sock.send(sdata.encode())  # 网络发送数据要求是bytes类型
cli_sock.close()  # 关闭客机户机套接字
s.close()  # 关闭服务器套接字

#创建TCP服务器与客户端循环交互
import socket

host = ''
port = 12345
addr = (host, port)
s = socket.socket()
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(addr)
s.listen(1)

while True:
    try:
        cli_sock, cli_addr = s.accept()
    except KeyboardInterrupt:
        break
    while True:
        data,cli_addr = cli_sock.recv(1024)
        if data.strip() == b'quit':
            break
        print(data.decode())
        sdata = input('> ') + '\r\n'
        cli_sock.send(sdata.encode())
    cli_sock.close()

s.close()


#创建TCP客户端
import socket

server = '127.0.0.1'
port = 12345
addr = (server,port)
c = socket.socket()
c.connect(addr)

while True:
    data = input('>>>') + '\r\n'
    c.send(data.encode())
    if data.strip() == 'quit':
        break
    rdata = c.recv(1024)
    print(rdata.decode())

c.close()

#创建UDP服务器
import socket

host = ''
port = 12345
addr = (host,port)
s = socket.socket(type=socket.SOCK_DGRAM)
s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
s.bind(addr)

while True:
    data,cli_addr = s.recvfrom(1024)
    print(data.decode())
    sdata = input('>') + '\r\n'
    s.sendto(sdata.encode(),cli_addr)

s.close()

#创建UDP客户端
import socket

host = '127.0.0.1'
port = 12345
addr = (host,port)
c = socket.socket(type=socket.SOCK_DGRAM)

while True:
    data = input('>') + '\r\n'
    if data.strip() == 'quit':
        break
    c.sendto(data.encode(),addr)
    rdata,serv_addr = c.recvfrom(1024)
    print(rdata.decode())

c.close()

使用OOP创建TCP服务器
from time import strftime
import socket

class TcpTimeServ:
    def __init__(self,host,port):
        self.addr = (host,port)
        self.serv = socket.socket()
        self.serv.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
        self.serv.bind(self.addr)
        self.serv.listen(1)

    def chat(self,cli_sock):
        while True:
            data = cli_sock.recv(1024)
            data = data.decode()
            if data.strip() == 'quit':
                break
            sdata = '[%s] %s' %(strftime('%H:%M:%S'),data)
            cli_sock.send(sdata.encode())

    def mainloop(self):
        while True:
            try:
                cli_sock,cli_data = self.serv.accept()
            except (KeyboardInterrupt,EOFError):
                break
            self.chat(cli_sock)
            cli_sock.close()

if __name__ == '__main__':
    tcp = TcpTimeServ(host='',port=12345)
    tcp.mainloop()
####################################################################################

Devops
Day01
多进程、多线程主要用于提升效率

脚本执行方式：
1、# bash script.sh    => fork执行，使用bash作为解释器
2、# ./script.sh   => fork执行，使用脚本中指定的解释器
3、# source script.sh  => 在当前进程中执行，不会fork出子进程

fork编程思路：
1、父子进程的分工
2、一般来说，父进程用于生成子进程
3、子进程做具体的工作，工作结束后要退出(exit)

#fork多进程测试主机存活状态
import subprocess
import os

def ping(host):
    rc = subprocess.call('ping -c2 -i 0.2 %s &> /dev/null' %host,shell=True)
    if rc == 0:
        print('%s:up' %host)
    else:
        print('%s:down' %host)


if __name__ == '__main__':
    ips = ['176.121.202.%s'%i for i in range(1,255)]
    for i in ips:
        ret_val = os.fork()
        if not ret_val:
            ping(i)
            exit()


#解决僵尸进程
当父进程的waitpid执行时，检测子进程是僵尸进程时处理，不是则不处理
import os
import time

ret_val = os.fork()	#返回2个值,针对父进程返回进程的PID,对于子进程,返回PID
if ret_val:
    print('父进程')
    time.sleep(10)
    #waitpid一次只能处理一个僵尸进程
    result = os.waitpid(-1,0)	#waitpid(-1，状态)，-1默认参数，表示与wait函数相同，状态0表示挂起父进程，1表示不挂起父进程
    print(result)	#（0，0） #返回值第一个参数0表示子进程尚未结束，否则返回子进程PID
    time.sleep(10)
    print('父进程结束')
else:
    print('子进程')
    time.sleep(30)	#父进程20秒结束，30秒后子进程结束将变成僵尸进程
    print('子进程结束')
    exit()


fork服务器：父进程负责生成子进程，子进程与客户端通信
父进程接收到客户端连接后，生成子进程，父子进程都有服务器套接字和客户机套接字，
父进程用不到客户机套接字，可以将其关闭；同理子进程也可以将服务器套接字关闭

import socket
import os
from time import strftime

class TcpTimeServ:
    def __init__(self, host, port):
        '初始化结束后，生成一个可以用的TCP套接字'
        self.addr = (host, port)
        self.serv = socket.socket()
        self.serv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.serv.bind(self.addr)
        self.serv.listen(1)

    def chat(self, cli_sock):
        while True:
            data = cli_sock.recv(1024)
            data = data.decode()
            if data.strip() == 'quit':
                break
            sdata = "[%s] %s" % (strftime('%H:%M:%S'), data)
            cli_sock.send(sdata.encode())

    def mainloop(self):
        while True:
            try:
                cli_sock, cli_addr = self.serv.accept()
            except KeyboardInterrupt:
                break
            ret_val = os.fork()
            if not ret_val:  # 子进程
                self.serv.close()  # 关闭服务器套接字
                self.chat(cli_sock)  # 与客户机通信
                exit()  # 退出
            cli_sock.close()  # 父进程关闭客户机套接字

            while True:
                result = os.waitpid(-1, 1)  # 一个waitpid只能处理一个子进程
                if result[0] == 0:  # result是个元组
                    break

        self.serv.close()

if __name__ == '__main__':
    tcp = TcpTimeServ(host='', port=12345)  # 调用__init__
    tcp.mainloop()



《python基础教程 第三版》

程序：存储在磁盘上的可执行文件
进程：加载到内存中的一系列指令，每个进程有自己的运行空间
线程：轻量级进程，一个进程可以包含多个线程。进程内的线程共享进程的内存空间


多线程编程：
1、主线程和工作线程
2、主线程负责生成工作线程
3、工作线程做具体的工作，不会产生僵尸进程
Windows只有多线程，没有多进程

import threading
import socket
from time import strftime

class TcpTimeServ:
    def __init__(self,host,port):
        self.addr = (host,port)
        self.serv = socket.socket()
        self.serv.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
        self.serv.bind(self.addr)
        self.serv.listen(1)

    def chat(self,cli_sock):
        while True:
            data = cli_sock.recv(1024)
            data = data.decode()
            if data.strip() == 'quit':
                break
            sdata = '[%s] %s' %(strftime('%H:%M:%S'),data)
            cli_sock.send(sdata.encode())
        cli_sock.close()

    def mainlook(self):
        while True:
            try:
                cli_sock,cli_addr = self.serv.accept()
            except (KeyboardInterrupt,EOFError):
                break
            t = threading.Thread(target=self.chat,args=(cli_sock,))
            t.start()
        self.serv.close()

if __name__ == '__main__':
    tcp = TcpTimeServ('',12345)
    tcp.mainlook()

GIL：Global Interpreter Lock全局解释器锁
GIL限制某一时刻只能有一个线程使用解释器

CPU密集型(计算密集型)应用：多进程适合，多线程不能提升效率
IO密集型应用：多进程和多线程都可以提升效率
多进程：多个CPU同时工作
多线程：单个CPU轮流工作，不是同时工作

import time
import os
import threading

def add(n=20000000):
    result = 0
    for i in range(n):
        result += i
    print(result)

if __name__ == '__main__':
    start = time.time()

     #单进程模式
    # for i in range(5):
    #     add()

     #多进程模式
    # for i in range(5):
    #     ret_val = os.fork()  # 创建两个子进程，分别计算
    #     if not ret_val:
    #         add()
    #         exit() 
    # for i in range(5):
    #     os.waitpid(-1, 0)  # 一个waitpid只能挂起处理一个子进程

     #多线程模式
    tlist = []
    for i in range(5):
        t = threading.Thread(target=add)
        t.start()
        tlist.append(t)  # 把线程存入列表
    for t in tlist:  # 在列表中取出线程
        t.join()     # 挂载主线程，等待工作线程结束
    end = time.time()
    print(end - start)

###############################################################################################

Day02
https://pypi.org官网
百度搜索python镜像站点
使用国内镜像站点安装
mkdir ~/.pip
cat << eof > ~/.pip/pip.conf
[global]
index-url=http://pypi.douban.com/simple
[install]
trusted-host=pypi.douban.com
pip3 install 包名
pip3 list  查看安装的包

pymysql:
1、安装
# cd pymysql_pkgs/
# pip3 install *
2、数据库
为一个小公司设计数据库，要求存储员工基本信息和工资情况
字段：
员工ID  姓名    性别    出生日期        联系方式        部门    工资日期        基本工资        奖金    >工资总额
数据库表应该尽量减少冗余：重复录入、占空间、容易造成数据不一致
可以通过分表实现减少冗余
员工表：
员工ID  姓名    性别    出生日期        联系方式        部门ID
部门表：
部门ID 部门名称
工资表：
员工ID 工资日期 基本工资        奖金    工资总额
数据库范式：
所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，
所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项
根据1NF，联系方式需要进一步拆分：家庭住址、email、电话号码
第二范式（2NF）是在第一范式（1NF）的基础上建立起来的。
第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。
根据2NF，需要给工资表加上一个主键。没有合适的，可以使用“行号”
第三范式（3NF）第三范式就是属性不依赖于其它非主属性。
根据3NF，总工资不应该出现在数据库中
经过这三个范式，确定最终的三张表字段如下：
员工表：
员工ID 姓名     性别    出生日期        email 部门ID
部门表：
部门ID 部门名称
工资表：
auto_id 员工ID 工资日期 基本工资        奖金

pymysql数据库

import pymysql

#创建数据库连接
conn = pymysql.connect(
    host = '127.0.0.1',
    port = 3306,
    user = 'root',
    passwd = '123456',
    db = 'nsd1809',
    charset = 'utf8'
)

cursor = conn.cursor()  #游标，通过sql语句取出/插入对应数据的接口/句柄

#创建部门表
# create_departments = """create table departments(
# dep_id int,dep_name varchar(20) not null unique,
# primary key(dep_id)
# )"""
# cursor.execute(create_departments)    #通过游标，执行sql语句

#创建员工表
# create_employees = '''create table employees(
# emp_id int,emp_name varchar(20),gender varchar(6),
# birth_data date,email varchar(50),dep_id int,
# PRIMARY KEY(emp_id),
# FOREIGN KEY(dep_id) REFERENCES departments(dep_id)
# )'''
# cursor.execute(create_employees)
#
# #创建工资表
# create_salary = '''create table salary(
# auto_id int primary key,emp_id int,date date,basic int,awards int,
# foreign key(emp_id) REFERENCES employees(emp_id)
# )'''
# cursor.execute(create_salary)

#插入部门信息
insert_dep1 = '''insert into departments values(%s,%s)'''
# cursor.execute(insert_dep1,(1,'人事部'))
# cursor.executemany(insert_dep1,[(2,'运维部'),(3,'开发部')])
# cursor.executemany(insert_dep1,[(4,'销售部'),(5,'财务部'),(6,'采购部')])

#插入员工表信息
insert_emp1 = '''insert into employees values(%s,%s,%s,%s,%s,%s)'''
# cursor.executemany(   #many执行多条SQL语句，格式[(),(),...]列表套多个元组
#     insert_emp1,[
#         (1,'黄涛','男','1991-1-10','ht@qq.com',2),
#         (2,'小张','男','1996-10-10','xz@qq.com',3)
#     ]
# )

#查询数据
query_dep1 = 'select * from departments order by dep_id'
cursor.execute(query_dep1)
# result1 = cursor.fetchone() #取一行
# print(result1)
# print('*' * 30)
# # cursor.execute(query_dep1)
# result3 = cursor.fetchmany(3) #除去上面一行取3行
# print(result3)
# print('*' * 30)
result2 = cursor.fetchall() #除去上面取出的4行取出全部
print(result2)

#设定移动游标，类似光标的位置
# cursor.scroll(2,mode='absolute')    #默认ralative相对位置开始
# result4 = cursor.fetchone()
# print(result4)
# print('*' * 30)
# cursor.scroll(1)    #默认从相对位置移动1位
# result5 = cursor.fetchone()
# print(result5)

#修改数据
update_dep1 = 'update departments set dep_name=%s where dep_name=%s'
cursor.execute(update_dep1,('运营部','运维部'))


#删除
# delete_dep1 = 'delete from departments where dep_id=%s'
# cursor.execute(delete_dep1,(6,))

conn.commit()   #增，删，改必须提交
cursor.close()
conn.close()

ORM：对象关系映射
O：对象 -> class类
R：对象 -> 关系型数据库
M：映射 -> 将数据库中的表映射为一个class，表中的每个子段映射为一个类属性

sqlalchemy
1、安装
pip3 install SQLAlchemy-1.2.14.tar.gz
2、新建数据库
create database tedu1809 defualt charset utf8;


创建dbconn.py文件
from sqlalchemy import create_engine, Column, Integer, String, Date, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

engine = create_engine(
    'mysql+pymysql://root:tedu.cn@127.0.0.1/tedu1809?charset=utf8',
    # 用户名:密码@服务器/数据库
    encoding='utf8',  # 编码
    # echo=True  # 控制台显示详细的日志输出，生产环境下要关闭
)
Session = sessionmaker(bind=engine)
Base = declarative_base()  # 创建ORM映射的基类

class Departments(Base):   # 继承于Base基类，对应一张表
    __tablename__ = 'departments'  # 声明该类对应哪张表
    dep_id = Column(Integer, primary_key=True)  # 主键默认自动增长
    dep_name = Column(String(20), unique=True, nullable=False)

    def __str__(self):
        return "部门: %s" % self.dep_name

class Employees(Base):
    __tablename__ = 'employees'
    emp_id = Column(Integer, primary_key=True)
    emp_name = Column(String(20), nullable=False)
    gender = Column(String(20))
    birth_date = Column(Date)
    email = Column(String(50))
    dep_id = Column(Integer, ForeignKey('departments.dep_id'))

    def __str__(self):
        return "员工: %s" % self.emp_name

class Salary(Base):
    __tablename__ = 'salary'
    auto_id = Column(Integer, primary_key=True)
    emp_id = Column(Integer, ForeignKey('employees.emp_id'))
    date = Column(Date)
    basic = Column(Integer)
    awards = Column(Integer)

if __name__ == '__main__':
    Base.metadata.create_all(engine)

创建crdu.py文件
from dbconn import Departments, Employees, Session

session = Session()  #连接session接口

hr = Departments(dep_name='人事部')
ops = Departments(dep_name='运维部')
dev = Departments(dep_name='开发部')
qa = Departments(dep_name='测试部')
finance = Departments(dep_name='财务部')
xz = Departments(dep_name='行政部')
# session.add(hr)
# session.add_all([ops, dev, qa, finance, xz])
#######################################
# gyh = Employees(
#     emp_name='耿宇航',
#     gender='男',
#     birth_date='1993-8-23',
#     email='gyh@qq.com',
#     dep_id=2
# )
# zjy = Employees(
#     emp_name='张钧溢',
#     gender='男',
#     birth_date='1990-10-15',
#     email='zjy@163.com',
#     dep_id=2
# )
# jp = Employees(
#     emp_name='蒋鹏',
#     gender='男',
#     birth_date='1995-3-23',
#     email='jp@qq.com',
#     dep_id=3
# )
# ljj = Employees(
#     emp_name='李杰君',
#     gender='男',
#     birth_date='1995-4-18',
#     email='ljj@126.com',
#     dep_id=3
# )
# ghn = Employees(
#     emp_name='郭浩南',
#     gender='男',
#     birth_date='1992-2-5',
#     email='ghn@qq.com',
#     dep_id=1
# )
# wyf = Employees(
#     emp_name='王宇峰',
#     gender='男',
#     birth_date='1994-12-9',
#     email='wyf@qq.com',
#     dep_id=4
# )
# cl = Employees(
#     emp_name='陈磊',
#     gender='男',
#     birth_date='1994-11-2',
#     email='cl@qq.com',
#     dep_id=2
# )
# xkn = Employees(
#     emp_name='徐康宁',
#     gender='男',
#     birth_date='1994-9-12',
#     email='xkn@qq.com',
#     dep_id=2
# )
# ytt = Employees(
#     emp_name='余婷婷',
#     gender='女',
#     birth_date='1996-5-18',
#     email='ytt@qq.com',
#     dep_id=3
# )
# session.add_all([gyh, zjy, jp, ljj, ghn, wyf, cl, xkn, ytt])

#数据库查询
#######################################
query1 = session.query(Departments)
print(query1)  # query1只是一个SQL查询语句
print(query1.all())  # 返回的是Departments所有实例组成的列表
for dep in query1:   # 取出查询结果中的每一个实例
    print(dep)
for dep in query1:
    print('%s: %s' % (dep.dep_id, dep.dep_name))  # 打印实例的属性
#######################################
#查询时对指定子段进行排序
query2 = session.query(Departments).order_by(Departments.dep_id)
for dep in query2:
    print('%s :%s' %(dep.dep_id,dep.dep_name))

#######################################
#查询类中的单个属性
query3 = session.query(Employees.emp_name,Employees.email)
print(query3)	#一个SQL查询语句
print(query3.all())	#返回一个列表，里面由元组组成
for name,email in query3:
    print('%s:%s' %(name,email))	#按指定格式打印出来

#######################################
#为子段改别名,select name as 部门 from xxx;
query4 = session.query(Departments.dep_name.label('部门'))
# print(query4)
for dep in query4:
    print(dep.部门)

#########################################
#数据进行分片查询
query6 = session.query(Departments).order_by(Departments.dep_id)
dep = query6[0]	#单独打印出来是具体的值
print(dep)
print('%s:%s' %(dep.dep_id,dep.dep_name))

qset = query6[2:]	#对数据进行分片处理
for dep in qset:
    # print(dep)
    print('%s:%s' %(dep.dep_id,dep.dep_name))

#########################################
#加条件查询
query7 = session.query(Employees).filter(Employees.dep_id==2)
print(query7)
for dep in query7:
    print('%s:%s' %(dep.emp_name,dep.dep_id))

#可以加多重条件查找==，!=,like
query8 = session.query(Employees).filter(Employees.dep_id==2).filter(Employees.email.like('%@tedu.com')).filter(Employees.gender=='女')
print(query8)
for emp in query8:
    print('%s:%s'%(emp.emp_name,emp.email))

#查找条件in，not in使用示例，判断子段是否为空将in_改为is_(None)和isnot(None)
query9 = session.query(Departments).filter(Departments.dep_id.in_([1,2,3]))
# print(query9)
for dep in query9:
    print('%s:%s' %(dep.dep_id,dep.dep_name))	#打印dep_id在1，2，3中的数据
query9 = session.query(Departments).filter(～Departments.dep_id.in_([1,2,3]))
# print(query10)
for dep in query10:
    print('%s:%s' %(dep.dep_id,dep.dep_name))	#打印dep_id不在1，2，3里的数据

#条件查找and_和or_需单独倒入模块
from sqlalchemy import and_
query11 = session.query(Departments)\
    .filter(and_(Departments.dep_id>2,Departments.dep_id<5))
print(query11)
for dep in query11:
    print('%s:%s' %(dep.dep_id,dep.dep_name))

from sqlalchemy import or_
query12 = session.query(Departments)\
    .filter(or_(Departments.dep_id>4,Departments.dep_id<2))
print(query12)
for dep in query12:
    print('%s:%s' % (dep.dep_id, dep.dep_name))

#########################################
查询对象返回值all(),one()比较常用,first(),scalar()作为了解
query13 = session.query(Departments)
print(query13.all())  # 返回实例列表，常用
print(query13.first())  # 返回all实例列表中的第一项
#######################################
query14 = session.query(Departments).filter(Departments.dep_id==1)
print(query14.one())  # 返回一个具体的实例，多于1或少于1都会报错，常用
#######################################
query15 = session.query(Departments.dep_name, Departments.dep_id)\
    .filter(Departments.dep_id==1)
print(query15.scalar())  # 返回one结果中的第一项

#########################################
#聚合count()的使用
query15 = session.query(Departments).count()
print(query15)

#########################################
#多表查询
query16 = session.query(Employees.emp_name,Departments.dep_name)\
    .join(Departments,Employees.dep_id==Departments.dep_id)
print(query16)
for dep in query16:
    print('%s:%s' %(dep.emp_name,dep.dep_name))

#########################################
#修改数据
query17 = session.query(Departments).filter(Departments.dep_id==1)
hr = query17.one()	#取出要修改的第一条记录
hr.dep_name = '人力资源部'	#修改数据

query17 = session.query(Departments).filter(Departments.dep_id==3)
query17.update({Departments.dep_name:'dev部门'})	#修改匹配到的数据

#########################################
#删除数据
query18 = session.query(Departments).filter(Departments.dep_id==6)
xz = query18.one()
session.delete(xz)

session.commit()
session.close()

##########################################################################################

Day03
HTTP: 超文本传输协议
请求Request：(1)浏览器输入网址访问站点; (2) 在文本框中输入内容，点击提交按钮
            (3)在网页中点击一个超链接
响应Response：一个请求只能对应一个响应

HTTP常用的方法：GET/POST
get: (1)浏览器输入网址访问站点; (2)在网页中点击一个超链接; (3) 提交表单
post: 一般都是用在提交表单，比如登陆

通过telnet访问baidu首页
[root@room8pc16 ~]# telnet www.baidu.com 80
GET / HTTP/1.1
Host: www.baidu.com

HTTP状态码：
200：正常 OK
3XX：重定向
4XX：客户端错误
5XX：服务器内部错误

命令
eog：打开图片文件
file：查看文件类型

#################################
爬虫爬取网页图片

from urllib import request
import os
import re
import time

def down(url,fname):
    html = request.urlopen(url)
    with open(fname,'wb') as fobj:
        while True:
            data = html.read(1024)
            if not data:
                break
            fobj.write(data)

def get_urls(patt,fname,encoding='utf8'):
    cpatt = re.compile(patt)
    alist = []

    with open(fname,encoding=encoding) as fobj:
        for line in fobj:
            m = cpatt.search(line)
            if m:
                alist.append(m.group())

    return alist


if __name__ == '__main__':
    fname = '/tmp/myimg'
    if not os.path.exists(fname):
        os.mkdir(fname)
    get_fname = os.path.join(fname,'163.html')
    url_163 = 'http://www.163.com'
    down(url_163,get_fname)
    patt = 'https?://[-\w./]+\.(png|jpg|jpeg|gif)'
    url_img = get_urls(patt,get_fname,encoding='gbk')
    start = time.time()
    for line in url_img:
        ret_val = os.fork()
        if not ret_val:
            # tmp = os.path.join(fname,os.path.basename(line))
            tmp = os.path.join(fname,line.split('/')[-1])
            # print(tmp)
            down(line,tmp)
            exit()
    end = time.time()
    print(end - start)


模拟通过浏览器访问WEB服务器
1、配置头部信息
>>> from urllib import request
>>> header = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0'}
2、创建Request对象
>>> url = 'http://127.0.0.1/'
>>> r = request.Request(url, headers=header)
3、打开Request对象，观察日志
>>> html = request.urlopen(r)

数据编码：
在URL中，只支持一部分字符集，其他字符需要进行编码。
1、如，在搜狗中搜索“达内”，URL可以看到汉字，但是复制到下面，这就是这样的显示：
https://www.sogou.com/web?query=%E8%BE%BE%E5%86%85
2、通过urllib进行数据编码
>>> url = 'https://www.sogo.com/web?query='
>>> word = request.quote('达内')
>>> url + word
'https://www.sogo.com/web?query=%E8%BE%BE%E5%86%85'

异常处理
1、环境准备
http://127.0.0.1/abc   => 不存在
http://127.0.0.1/ban   -> 没权限
2、通过urllib进行访问，观察异常
>>> url1 = 'http://127.0.0.1/abc/'
>>> url2 = 'http://127.0.0.1/ban/'
>>> request.urlopen(url1)
>>> request.urlopen(url2)
3、异常处理
>>> import urllib.error

qq主页，下载后通过file命令查看，它是gzip文件，不是html文件。
>>> import gzip
>>> f = gzip.open('/tmp/qq.html', 'rb')
>>> data = f.read()
>>> f.close()
>>> data.decode('gbk')  # 默认是utf8

#高层应用支持的模块wget
[root@room8pc16 day04]# pip3 install wget
>>> import wget
>>> wget.download(url='https://upload-images.jianshu.io/upload_images/12347101-0548326de2ebc9bc.png', '/tmp/')


paramiko模块：ssh客户端
1、安装
[root@room8pc16 zzg_pypkgs]# cd paramiko_pkgs/
[root@room8pc16 paramiko_pkgs]# pip3 install *
2、应用
>>> import paramiko
>>> ssh = paramiko.SSHClient()  # 创建SSHClient的实例
>>> ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 回答yes
>>> ssh.connect('192.168.4.4', username='root', password='123456')
>>> ssh.exec_command('mkdir /tmp/mydemo')  # 执行命令
>>> ssh.close()  # 关闭连接
3、执行命令的返回值
>>> ssh = paramiko.SSHClient()
>>> ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
>>> ssh.connect('192.168.4.4', username='root', password='123456')
>>> result = ssh.exec_command('id root; id tom')
>>> len(result)  => 3
执行命令返回的值共有3项，分别是输入、输出和错误的类文件对象
>>> result[1].read()
b'uid=0(root) gid=0(root) \xe7\xbb\x84=0(root)\n'
>>> result[2].read()
b'id: tom: no such user\n'	#默认输出时bytes，加decode()可转换为string类型输出
>>> ssh.close()


###################实现简单的PSSH########################
import paramiko
import os
import threading
import sys
import getpass

def rcmd(host,passwd=None,cmds=None,port=22,user='root'):
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(host,password=passwd,port=port,username=user)
    stdin,stdout,stderr = ssh.exec_command(cmds)
    out = stdout.read()
    err = stderr.read()
    if out:
        print('[\033[32;1mOUT\033[0m] %s:\n%s' %(host,out.decode()))
    if err:
        print('[\033[31;1mERROR\033[0m] %s:\n%s' % (host, err.decode()))
    ssh.close()

if __name__ == '__main__':
    if not sys.argv != 3:
        print('Usage: %s ipfile "command"' % sys.argv[0])
        exit(1)
    if not os.path.isfile(sys.argv[1]):
        print('No such file:', sys.argv[1])
        exit(2)
    ipfile = sys.argv[1]
    cmd = sys.argv[2]
    password = getpass.getpass()
    with open(ipfile) as fobj:
        for line in fobj:
            ip = line.strip()
            # rcmd(ip,passwd=password,cmds=cmd)
            t = threading.Thread(target=rcmd,args=(ip,password,cmd))
            t.start()   #target(ip,password,cmd)


###########################################################################################

Day04

#单机版发送邮件测试
from email.mime.text import MIMEText
from email.header import Header
import smtplib

# 准备邮件
message = MIMEText('Python email test.\r\n', 'plain', 'utf8')
message['From'] = Header('root', 'utf8')
message['To'] = Header('bob', 'utf8')
message['Subject'] = Header('Email Test', 'utf8')

# 发送邮件
smtp = smtplib.SMTP(host='127.0.0.1')
smtp.sendmail('root@tedu.cn', ['root@localhost', 'bob@localhost'], message.as_bytes())


#使用python在网络发送邮件
from email.mime.text import MIMEText
from email.header import Header
import smtplib
import getpass

def send_email(text,sender,receivers,subject,host,user,passwd):
    message = MIMEText(text,'plain','utf8')
    message['From'] = Header(sender)    #新浪不支持两个utf8参数
    message['To'] = Header(receivers[0],'utf8')
    message['Subject'] = Header(subject,'utf8')

    smtp = smtplib.SMTP()
    smtp.connect(host)
    # smtp.starttls()    #若有加密需求开启此选项
    smtp.login(user,passwd)
    smtp.sendmail(sender,receivers,message.as_string())

if __name__ == '__main__':
    text = '这是一封python测试邮件'
    sender = 'lxf_712@sina.com'
    receivers = ['lxf_712@sina.com']
    subject = 'Email Test'
    host = 'smtp.sina.com'
    user = 'lxf_712@sina.com'
    passwd = getpass.getpass()
    send_email(text,sender,receivers,subject,host,user,passwd)


requests模块：实现web客户端
Requests内部采用来urillib3
1、安装
# cd requests_pkgs/
[root@room8pc16 requests_pkgs]# pip3 install *
2、获取网络资源（文本）
>>> import requests
>>> r = requests.get('http://www.baidu.com')
>>> r.text
如果出现乱码，可以修改字符编码
>>> r.encoding   # ISO-8859-1
>>> r.encoding = 'utf8'
>>> r.text
3、获取网络资源（JSON格式数据）
url = 'http://www.weather.com.cn/data/sk/101010100.html'
>>> r = requests.get(url)
>>> r.encoding = 'utf8'
>>> r.json()
>>> bj = r.json()
>>> bj['weatherinfo']['SD']
4、获取网络资源（非文本数据）
>>> url = 'https://upload-images.jianshu.io/upload_images/1857973-202b35156b596a68'>>>
>>> r = requests.get(url)
>>> with open('/tmp/m.jpg', 'wb') as fobj:
...     fobj.write(r.content)
5、修改头部信息
>>> headers = {'User-Agent': "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"}
>>> r = requests.get('http://127.0.0.1', headers=headers)
6、状态码
>>> r.status_code
>>> r = requests.get('http://127.0.0.1/abc')
>>> r.status_code   # 404
7、使用参数（查快递）
参考：http://yshblog.com/blog/33
>>> url = 'http://www.kuaidi100.com/query'
>>> params = {'type': 'yunda', 'postid': '3834440052379'}
>>> r = requests.get(url, params=params)
>>> r.json()
>>> r.json()['data'][0]['context']


#官方文档：https://www.zabbix.com/documentation/4.0/zh/manual
zabbix api:	#zabbix应用程序接口
http://192.168.4.2/zabbix/api_jsonrpc.php		#根据实际情况寻找此文件路径

import requests
import json

url = 'http://192.168.4.2/zabbix/api_jsonrpc.php'		
headers = {'Content-Type': 'application/json-rpc'}	#官方文档API手册首页有详细介绍
###################################
# 版本信息不需要认证
# data = {
#     "jsonrpc": "2.0",  # jsonrpc协议的版本，固定的
#     "method": "apiinfo.version",  # 方法，获取zabbix版本
#     "params": [],   # 参数
#     "id": 11  # 随便填写一个数字，表示执行任务的ID
# }
###################################
# 通过用户名和密码生成一个token通行证
# 66bd7e91aa832a7f113acf81f5307bb5
# data = {
#     "jsonrpc": "2.0",
#     "method": "user.login",
#     "params": {
#         "user": "Admin",
#         "password": "zabbix"
#     },
#     "id": 1
# }
###################################
#
data = {
    "jsonrpc": "2.0",
    "method": "host.get",
    "params": {
        "filter": {
            "host": [
                "Zabbix server",
                "Linux server"
            ]
        }
    },
    "auth": "66bd7e91aa832a7f113acf81f5307bb5",
    "id": 1
}
###################################
r = requests.post(url, headers=headers, data=json.dumps(data))
print(r.json())


################################################################################

Day05
开发->发布流程
1、程序员将写好的代码从本地推送到gitlab服务器
2、发布服务器(jenkins)到gitlab上拉取代码
3、jenkins服务器处理代码(比如，将java程序包通maven等程序打包成war包)
4、应用服务器从jenkins上下载软件包(如war包)
5、部署到应用服务器(如tomcat把war包放到文档目录后，重启服务即可自动解压war包)

CI/CD(持续集成/持续交付)

jenkins应用
1、虚拟机网络
# virt-manager -> 编辑 -> 连接详情 -> 虚拟网络 -> 激活default
default网络是kvm的默认网络，采用nat模式，连到此网络的虚拟机可以直接上网

2、准备一台虚拟机，安装jenkins。jenkins需要外网下载插件
node4:
eth0: private1  192.168.4.4/24
eth1: 连接到default网络，用于互联网联接
(1) # nmtui  -> 添加新网络eth1，IP地址采用自动获取的方式
(2) # ifconfig virbr0 down
(3) # brctl delbr virbr0
(4) # systemctl restart NetworkManager
3、配置yum

4、安装jenkins
(1)拷贝jenkins到虚拟机并安装
[root@node4 ~]# rpm -ihv jenkins-2.138.2-1.1.noarch.rpm
(2) 启动
[root@node4 ~]# systemctl start jenkins
[root@node4 ~]# systemctl enable jenkins
5、配置
访问http://192.168.4.4:8080
安装插件时，选择自定义后不安装任何插件。因为现在是到国外远程服务器安装，速度太慢
6、通过国内镜像站点安装插件
https://blog.csdn.net/you227/article/details/81076032
https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json

7、安装插件
可选插件 -> Git Parameter -> 直接安装 -> 安装完成后重启Jenkins(空闲时)


CI/CD:
一、程序员编写项目代码
1、本地编写代码
[root@room8pc16 day05]# mkdir /tmp/nsd1809
[root@room8pc16 day05]# cd /tmp/nsd1809
[root@room8pc16 nsd1809]# echo '<h1>Hello World!</h1>' > index.html
2、加入git管理
[root@room8pc16 nsd1809]# git init .   # 初始化
[root@room8pc16 nsd1809]# git add .    # 将当前目录所有文件存入暂存区
[root@room8pc16 nsd1809]# git commit -m "myproject 1.0"  # 存入版本库
3、打标签
[root@room8pc16 nsd1809]# git tag 1.0   # 将当前状态标记为1.0版本
[root@room8pc16 nsd1809]# git tag    # 查看
[root@room8pc16 nsd1809]# git tag -d 标签    # 删除本地标签
4、继续开发，编写代码
[root@room8pc16 nsd1809]# echo '<h2>新版本加入一行</h2>' >> index.html
5、提交到版本库，并打标签
[root@room8pc16 nsd1809]# git add .
[root@room8pc16 nsd1809]# git commit -m "myproject 2.0"
[root@room8pc16 nsd1809]# git tag 2.0

二、推送代码到gitlab服务器
1、配置gitlab
群组Group：为每一个团队创建一个组
项目Project：每个团队都可能创建多个软件项目
成员Member：每个组都有多个成员，一个项目不一定需要所有成员参与

创建一个名为devops的组，在该项目下创建名为nsd1809的项目。
创建一个用户，配置该用户是nsd1809项目的主程序员。
2、推送本地代码到服务器
[root@room8pc16 nsd1809]# cd /tmp/nsd1809/
[root@room8pc16 nsd1809]# git remote rename origin old-origin
如果出现以下错误，忽略即可
error: 不能重命名配置小节 'remote.origin' 到 'remote.old-origin'
[root@room8pc16 nsd1809]# git remote add origin http://192.168.4.1/devops/nsd1809.git
[root@room8pc16 nsd1809]# git push -u origin --all
[root@room8pc16 nsd1809]# git push -u origin --tag

三、jenkins拉取gitlab服务器上的代码
1、创建一个freestyle自由风格的项目
2、参数化构建过程 => git parameter =>
 name: webver, default value: origin/master(origin仓库/master分支)
=> 源码管理 git, Repository URL: http://192.168.4.1/devops/nsd1809.git
如果jenkins服务器上没有git，需要yum install -y git =>
Branch Specifier (blank for 'any'): $webver =>
3、执行工程
点击 Build with Parameters => 选择1.0 => 开始构建
4、查看下载到的本地目录
[root@node4 ~]# ls /var/lib/jenkins/workspace/
myweb
[root@node4 ~]# ls /var/lib/jenkins/workspace/myweb/
index.html
[root@node4 ~]# cat /var/lib/jenkins/workspace/myweb/index.html
<h1>Hello World!</h1>
5、调整项目，下载的软件放到子目录中
点开jenkins的工程 => 左侧的“配置” =>    Additional Behaviours:
checkout to a subdirectory : Local subdirectory for repo: myweb-$webver
6、重新构建项目
[root@node4 ~]# rm -rf /var/lib/jenkins/workspace/myweb/
再次构建项目Build with Parameters
[root@node4 ~]# ls /var/lib/jenkins/workspace/myweb/

7、为了方便应用服务器到jenkins上下载软件包，在jenkins上安装apache
[root@node4 ~]# yum install -y httpd
[root@node4 ~]# systemctl start httpd
[root@node4 ~]# systemctl enable httpd
8、创建保存软件包的目录
[root@node4 ~]# mkdir -pv /var/www/deploy/packages
[root@node4 ~]# chown -R jenkins /var/www/deploy/
9、修改jenkins工程
将下载的软件放到/var/www/html/deploy/packages目录下，并压缩
构建 => 增加构建步骤 => 执行shell
appdir=/var/www/html/deploy
cp -r myweb-$webver $appdir/packages/
cd $appdir/packages/
rm -rf myweb-$webver/.git
tar czf myweb-$webver.tar.gz myweb-$webver
md5sum myweb-$webver.tar.gz | awk '{print $1}' > myweb-$webver.tar.gz.md5
rm -rf myweb-$webver

10、重新构建

11、生成当前版本和前一个版本的说明文件
appdir=/var/www/html/deploy
cp -r myweb-$webver $appdir/packages/
cd $appdir/packages/
rm -rf myweb-$webver/.git
tar czf myweb-$webver.tar.gz myweb-$webver
md5sum myweb-$webver.tar.gz | awk '{print $1}' > myweb-$webver.tar.gz.md5
rm -rf myweb-$webver
cd $appdir
[ -f live_version ] && cat live_version > last_version
echo $webver > live_version
12、重新构建

####################################
git分支应用：
[root@room8pc16 zzg_pypkgs]# git init /tmp/mygit
[root@room8pc16 zzg_pypkgs]# cd /tmp/mygit
[root@room8pc16 mygit]# cp /etc/hosts .
[root@room8pc16 mygit]# git add .
[root@room8pc16 mygit]# git commit -m "c1"
[root@room8pc16 mygit]# cp /etc/issue .
[root@room8pc16 mygit]# git add .
[root@room8pc16 mygit]# git commit -m "c2"
[root@room8pc16 mygit]# cp /etc/passwd .
[root@room8pc16 mygit]# git add .
[root@room8pc16 mygit]# git commit -m "c3"
[root@room8pc16 mygit]# git branch   # 查看分支
[root@room8pc16 mygit]# git branch b1   # 创建新分支b1
[root@room8pc16 mygit]# git branch
[root@room8pc16 mygit]# cp /etc/selinux/config .
[root@room8pc16 mygit]# git add .
[root@room8pc16 mygit]# git commit -m "c4"
[root@room8pc16 mygit]# git checkout b1   # 切换到b1分支
[root@room8pc16 mygit]# ls   # 工作区中没有config
[root@room8pc16 mygit]# cp /root/anaconda-ks.cfg .
[root@room8pc16 mygit]# git add .
[root@room8pc16 mygit]# git commit -m "c5"
[root@room8pc16 mygit]# git checkout master
[root@room8pc16 mygit]# git merge b1 -m "c6"  # 将分支b1合并到master
[root@room8pc16 mygit]# git branch -d b1  # 如果b1没有用了，可以删除
#######################################

四、在应用服务器上编写自动部署代码
1、检查是否有新版本
2、下载软件
3、校验文件，检查下载的软件包是否损坏
4、部署软件


应用服务器目录规划：
/var/www/download/: 存软件包和md5值
/var/www/deploy/：存live_version和解压的软件包
/var/www/html/nsd1809: deploy中最新版本目录的软链接

##############################################################################

Day06
ansible
1、安装
[root@room8pc16 zzg_pypkgs]# cd ansible_pkg/
[root@room8pc16 ansible_pkg]# pip3 install *
如果安装过程中有报错，提示某些tar包没有安装上，可以pip3 install xxx.tar.gz
单独安装，然后再执行pip3 install *
[root@room8pc16 day07]# python3
>>> import ansible
2、创建工作目录
[root@room8pc16 day07]# mkdir mykvm
[root@room8pc16 day07]# cd mykvm
3、创建配置文件
[root@room8pc16 mykvm]# vim ansible.cfg
[defaults]
inventory = hosts
remote_user = root
4、创建主机清单文件
[root@room8pc16 mykvm]# vim hosts
[dbservers]
node4.tedu.cn

[webservers]
node5.tedu.cn
node6.tedu.cn
5、配置名称解析
[root@room8pc16 mykvm]# for i in {1..254}
> do
> echo -e "192.168.4.$i\tnode$i.tedu.cn\tnode$i" >> /etc/hosts
> done
6、收集主机密钥
[root@room8pc16 mykvm]# ssh-keyscan node{4..6}.tedu.cn >> /root/.ssh/known_hosts
7、测试
[root@room8pc16 mykvm]# ansible all -m ping -k


ansible执行任务：
一、adhoc临时命令
[root@room8pc16 mykvm]# ansible webservers -m shell -a "id root" -k

二、playbook
1、修改vim
[root@room8pc16 mykvm]# vim ~/.vimrc
autocmd FileType yaml setlocal sw=2 ts=2 et ai
2、创建playbook，实现免密登陆
[root@room8pc16 ~]# ansible-doc authorized_key
[root@room8pc16 mykvm]# vim auth.yml
---
- name: configure authentication
  hosts: all
  tasks:
    - name: upload public key
      authorized_key:
        user: root
        state: present
        key: "{{ lookup('file', '/root/.ssh/id_rsa.pub') }}"
3、语法检查
[root@room8pc16 mykvm]# ansible-playbook --syntax-check auth.yml
[root@room8pc16 mykvm]# ansible-playbook auth.yml -k

4、配置yum
(1) [root@room8pc16 mykvm]# mkdir files
[root@room8pc16 mykvm]# vim files/server.repo
(2)[root@room8pc16 mykvm]# vim yum.yml
---
- name: upload yum config file
  hosts: all
  tasks:
    - name: upload file
      copy:
        src: files/server.repo
        dest: /etc/yum.repos.d/server.repo
(3) 执行
[root@room8pc16 mykvm]# ansible-playbook --syntax-check yum.yml
[root@room8pc16 mykvm]# ansible-playbook yum.yml

5、实现LAMP
[root@room8pc16 mykvm]# vim lamp.yml
---
- name: configure db servers
  hosts: dbservers
  tasks:
    - name: install db pkgs
      yum:
        name: mariadb-server
        state: latest
    - name: start db service
      service:
        name: mariadb
        state: started
        enabled: yes

- name: configure web servers
  hosts: webservers
  tasks:
    - name: install web pkgs
      yum:
        name: [httpd, php, php-mysql]
        state: present
    - name: start web service
      service:
        name: httpd
        state: started
        enabled: yes
[root@room8pc16 mykvm]# ansible-playbook --syntax-check lamp.yml
[root@room8pc16 mykvm]# ansible-playbook lamp.yml

ansible手册
https://docs.ansible.com/  => ansible documentation
搜索python api

命名的元组
基于元组做进一步的扩展，为元组的下标起名
>>> from collections import namedtuple
>>> Point = namedtuple('Point', ['x', 'y', 'z'])
>>> p1 = Point(10, 20, 30)
>>> p1[0]
10
>>> p1[1:]
(20, 30)
>>> for p in p1:
...     print(p)
...
10
20
30
>>> p1.x
10
>>> p1.y
20
>>> p1.z
30


#####################python example api##########################
import shutil
from collections import namedtuple
from ansible.parsing.dataloader import DataLoader
from ansible.vars.manager import VariableManager
from ansible.inventory.manager import InventoryManager
from ansible.playbook.play import Play
from ansible.executor.task_queue_manager import TaskQueueManager
import ansible.constants as C

# since API is constructed for CLI it expects certain options to always be set, named tuple 'fakes' the args parsing options object
# 通过命名的元组，定义ansible临时命令的选项
# connection：连接类型，有local(在本机执行命令)、ssh、smart(智能)
# module_path: 指定自定义模块的路径
# forks: 创建子进程的数目
# become: 是否切换成其他用户，比如通过普通用户连接远程主机，执行任务的时候切换成管理员
# check: 只是预测执行命令后在远程主机上将会产生什么样的影响，不会真正地执行命令
# diff: 当改变文件和模板时，显示改变了哪些内容
Options = namedtuple('Options', ['connection', 'module_path', 'forks', 'become', 'become_method', 'become_user', 'check', 'diff'])
options = Options(connection='smart', module_path=['/to/mymodules'], forks=10, become=None, become_method=None, become_user=None, check=False, diff=False)

# initialize needed objects
# Dataloader负责查找、读取yaml/json/ini文件，分析它们的结构，转换成python的数据类型
loader = DataLoader()  # Takes care of finding and reading yaml, json and ini files
# passwords用于存储各类密码，免密方式，密码为空即可
passwords = dict()

# create inventory, use path to host config file as source or hosts in a comma separated string
# inventory: 主机清单文件，列出ansible管理的机器有哪些
# 表示方式，可以用逗号把所有的主机分隔开，也可以使用主机清单文件列表
# inventory = InventoryManager(loader=loader, sources='localhost,')
inventory = InventoryManager(loader=loader, sources=['mykvm/hosts'])

# variable manager takes care of merging all the different sources to give you a unifed view of variables available in each context
# variable_mananger: 用于分析ansible变量
variable_manager = VariableManager(loader=loader, inventory=inventory)

# create datastructure that represents our play, including tasks, this is basically what our YAML loader does internally.
# 定义执行任务的相关信息
play_source = dict(
        name="My Ansible Task Test",
        hosts='webservers',  # 定义在哪些主机上执行任务
        gather_facts='no',   # 不收集主机信息
        tasks=[
            dict(action=dict(module='shell', args='id root'), register='shell_out'),
            dict(action=dict(module='debug', args=dict(msg='{{shell_out.stdout}}')))
         ]
    )

# Create play object, playbook objects use .load instead of init or new methods,
# this will also automatically create the task objects from the info provided in play_source
# 创建play实例
play = Play().load(play_source, variable_manager=variable_manager, loader=loader)

# Run it - instantiate task queue manager, which takes care of forking and setting up all objects to iterate over host list and tasks
# 创建任务队列管理器的实例
tqm = None
try:
    tqm = TaskQueueManager(
              inventory=inventory,
              variable_manager=variable_manager,
              loader=loader,
              options=options,
              passwords=passwords,
          )
    result = tqm.run(play) # most interesting data for a play is actually sent to the callback's methods
finally:
    # we always need to cleanup child procs and the structres we use to communicate with them
    if tqm is not None:
        tqm.cleanup()

    # Remove ansible tmpdir
    shutil.rmtree(C.DEFAULT_LOCAL_TMP, True)


#########################ansible-playbook编写##############################
from collections import namedtuple
from ansible.parsing.dataloader import DataLoader
from ansible.vars.manager import VariableManager
from ansible.inventory.manager import InventoryManager
from ansible.executor.playbook_executor import PlaybookExecutor

def run_playbook(sources=None, pb_path=None):
    Options = namedtuple(
        'Options',
        [
            'connection',
            'remote_user',
            'ask_sudo_pass',
            'verbosity',
            'ask_pass',
            'module_path',
            'forks',
            'become',
            'become_method',
            'become_user',
            'check',
            'listhosts',
            'listtasks',
            'listtags',
            'syntax',
            'sudo_user',
            'sudo',
            'diff'
        ]
    )
    options = Options(
        connection='smart',
        remote_user=None,
        ask_pass=None,
        sudo_user=None,
        forks=5,
        sudo=None,
        ask_sudo_pass=False,
        verbosity=5,
        module_path=None,
        become=None,
        become_method=None,
        become_user=None,
        check=False,
        diff=False,
        listhosts=None,
        listtasks=None,
        listtags=None,
        syntax=None
    )

    loader = DataLoader()
    passwords = dict()
    inventory = InventoryManager(loader=loader, sources=sources)
    variable_manager = VariableManager(loader=loader, inventory=inventory)

    playbook = PlaybookExecutor(
        playbooks=pb_path,
        inventory=inventory,
        variable_manager=variable_manager,
        loader=loader,
        options=options,
        passwords=passwords
    )
    result = playbook.run()
    return result

if __name__ == '__main__':
    sources = ['mykvm/hosts']
    # pb_path = ['mykvm/lamp.yml']
    pb_path = ['mykvm/yum.yml']
    run_playbook(sources, pb_path)


######################ansible模块编写###########################
#!/usr/bin/env python3

from ansible.module_utils.basic import AnsibleModule
import shutil

def main():
    module = AnsibleModule(
        argument_spec=dict(
            yuan=dict(required=True, type='str'),
            mubiao=dict(required=True, type='str')
        )
    )
    shutil.copy(module.params['yuan'], module.params['mubiao'])
    module.exit_json(changed=True)

if __name__ == '__main__':
    main()

编写ansible模块
1、创建一个保存自定义模块的路径
[root@room8pc16 day07]# cd library/
2、创建环境变量，声明当ansible执行任务时，也会到第1步创建的目录查找模块
[root@room8pc16 day07]# export ANSIBLE_LIBRARY=/var/ftp/nsd_2018/nsd1809/devops/day07/library
3、编写模块，如模块名为fuzhi.py
4、测试
[root@room8pc16 mykvm]# ansible dbservers -m fuzhi -a "yuan=/etc/hosts mubiao=/tmp/zhuji.txt"


安装python软件包
[root@node4 ~]# unzip wget-3.2.zip
[root@node4 ~]# cd wget-3.2/
[root@node4 wget-3.2]# python setup.py install


ansible-cmdb:分析ansible收集来的主机信息，生成网页形式
1、安装
# cd ansible-cmdb_pkgs/
# pip3 install *
2、修改程序
[root@room8pc16 ansible-cmdb_pkgs]# which ansible-cmdb
# vim /usr/local/bin/ansible-cmdb
将PY_BIN=$(which python)
改成
PY_BIN=$(which python3)
3、生成主机信息到/tmp/out目录
# ansible all -m setup --tree /tmp/out
4、通过ansible-cmdb分析主机信息，生成网页
# ansible-cmdb /tmp/out/ > /tmp/hosts.html
# firefox /tmp/hosts.html

python文件追踪：python -m trace --trace 文件
###########################################################################################

Devweb
Day01
web编程：
前端：网页制作、DIV＋CSS、javascript
后端：python/php/java/asp

html语法+css(层叠样式表)
bootstrap: twitter公司开源的前端框架

HTML标记(标签、元素)：
双标记：<html>...</html>
单标记：<br>

注释：ctrl + / 和  ctrl+shift+/

块级元素：无论多少内容，必须独占一行
标题元素 => h1 ... h6
段落元素 => p
div元素

特殊字符显示：&le,&gt,&nbsp空格，hr分割线，br换行...
字体修饰：b粗体，i斜体，u下划线，s删除线，sup字体向上放，sub字体向下放
标题：hn（n：1～6）标题字体大小
图片处理：<img src="car.jpg">	，可以是网络文件
超连接：<a href="http://fanyi.sogou.com">搜狗翻译</a>
锚点（页面调转）：<a href="#down">显示内容</a>
表格：talbe>tr*4>td*3(TAB),快速创建4行3列的表格，td中的rowspan（合并行）colspan（合并列）
列表：ul>li*4(TAB),四个无序的列表，默认实心圆点，ol>li*4(TAB)，4个有序的列表，默认数字排序
表单及控件：form可以制作按钮连接表单

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>我的测试页面</title>
</head>
<body>
    <!--有序列表的使用，快速创建ol*2>li*4（Tab补全）-->
    <ol type="a">  <!--默认是数字，type修改前方标志-->
        <li>linux</li>
        <li>debain</li>
        <li>windows</li>
        <li>unux</li>
    </ol>
    <ol type="I">
        <li>linux</li>
        <li>unux</li>
        <li>debain</li>
        <li>fedora</li>
    </ol>
    <hr>

    <!--无序列表的使用-->
    <ul type="square">  <!--默认是实心小圆，type修改前方图形标志-->
        <li>linux</li>
        <li>debain</li>
        <li>windows</li>
        <li>unux</li>
    </ul>
    <ul type="circle">  <!--空心圆-->
        <li>linux</li>
        <li>unux</li>
        <li>debain</li>
        <li>fedora</li>
    </ul>
    <hr>

    <!--创建表格，快速创建table>tr*2>td*3（Tab补全）-->
    <table border="30">
        <tr>
            <td>姓名</td>
            <td>性别</td>
            <td>城市</td>
        </tr>
        <tr>
            <td rowspan="2">1</td>  <!--合并2行单元格为一格-->
            <td colspan="2">1</td>  <!--合并2列单元格为一列-->
        </tr>
        <tr>
            <td>1</td>
            <td>1</td>
        </tr>
    </table>
    <hr>

    <!--锚点，页面内调转位置-->
    <a href="#down"><i>调转到底部</i></a>
    <hr>

    <!--超链接-->
    <a href="http://fanyi.sogou.com">搜狗翻译</a>   <!--直接在当前页面打开-->
    <a href="https://www.qq.com" target="_blank">   <!--blank表示在新窗口打开-->
        <img src="car.jpg">
    </a>
    <hr>    <!--用一条横线分割-->

    <!--插入图片-->
    <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1551504785937&di=4600ffe459b0e4c4d457de2c51508b32&imgtype=0&src=http%3A%2F%2Fpic3.16pic.com%2F00%2F57%2F89%2F16pic_5789804_b.jpg">  <!--直接指向网站并设置宽度高度-->
    <img src="car.jpg"> <!--本地图片-->
    <hr>

    <!--标题-->
    <h1><b>这是一个标题！！！</b></h1>
    <h2><i>这是一个标题！！！</i></h2>
    <h3><u>这是一个标题！！！</u></h3>
    <h4>这是一个标题！！！</h4>
    <h5>这是一个标题！！！</h5>
    <h6><s>这是一个标题！！！</s></h6>
    <p>fasdsafasfsafd</p>
    <div>safdsdfsdf</div>
    <hr>

    <!--字体修饰-->
    <b>加粗</b>
    <i>倾斜线</i>
    <u>下划线</u>
    <s>删除线</s>
    2<sup>3</sup>&ne;9
    log<sub>2</sub>
    <hr>

    <!--特殊符号显示-->
    &le; 小于等于
    &gt; 大于
    &nbsp; 空格
    <br> 换行
    &copy; ©
    &ddarr; ⇊
    &uuarr; ⇈
    &delta; δ
    <hr id="down">
    <a href="#"><i>返回顶部</i></a>

</body>
</html>
##########################################################################
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <!--下拉菜单选项-->
    <form action="">
        <select name="" id="">
            <option value="linux">linux</option>
            <option value="windows">windows</option>
            <option value="python">python</option>
        </select>
        <textarea name="" id="" cols="30" rows="10"></textarea>
        <input type="reset">
    </form>


    <a href="https://github.com/LiXiaofeng-712/NSD1809/tree/master/Tedu" target="_blank">git笔记</a>
    <hr>
    <!--多选按钮-->
    <form action="https://www.baidu.com/s" target="_blank">
        <label><input type="checkbox" name="wd" value="linux"> linux</label> <br>
        <label><input type="checkbox" name="wd" value="windows"> windows</label> <br>
        <label><input type="checkbox" name="wd" value="python"> python</label> <br>
        <input type="submit" value="百度搜索">
        <input type="reset" value="刷新">
    </form>

    <hr>
    <!--单选按钮，按钮可以和文字一体-->
    <form action="https://www.baidu.com/s" target="_blank">
        <input type="radio" name="wd" value="linux"><label>linux</label> <br>
        <label><input type="radio" name="wd" value="windows"> windows</label> <br>
        <input type="radio" name="wd" id="py" value="python"><label for="py">python</label> <br>
        <input type="submit" value="百度搜索"> <br>
    </form>

    <hr>
    <!--隐藏密码-->
    <form action="">
        <label>用户名：</label><input type="text" placeholder="用户名">
        <label>密码：</label><input type="password" placeholder="密码">
    </form>
    <hr>
    <!--form表单-->
    <!--action:是指提交数据给哪个网址。input的name=query：是提交数据时的变量
    input文本框中的内容，是变量的值-->
    <form action="https://www.sogo.com/web" target="_blank">
        <input type="text" name="query">
        <input type="submit" value="搜狗搜索">
    </form>
    <hr>
    <!--制作一个搜索图片的按钮-->
    <form action="http://image.baidu.com/search/index" target="_blank">
        <input type="hidden" value="baiduimage" name="tn">  <!--隐藏字段-->
        <input type="text" name="word">
        <input type="submit" value="百度图片">
    </form>
    <hr>


</body>
</html>
####################################################################

Day02
CSS特性：
继承性：元素可以嵌套，下一级元素继承上一级元素的样式
层叠性：元素可以从不同位置得到多种样式
优先级：越靠近元素的样式越优先

选择器：为谁设置样式（可以使用外部连接）
元素选择器：html自带的标签
*: 通用选择器，匹配所有标签(格式同下)
类选择器：可以将一些元素放到一个分组中，统一为这个分组设置样式
	<span class="cloud">达内</span>	声明一个自定义组名class="xxx"
	另一个文件中定义样式
	.cloud {font-weight:bold;color:red;}  使用.组名class="xxx"定义类选择器
id选择器：id是某一元素在整个页面中的唯一标识
	<h3 id="p1">这是3号标题</h3>
	另一个文件中定义样式
	#p1 {color:darkred;}	
群组选择器：使用逗号间隔各个元素，统一定义样式(h2,h3...)
伪类选择器：一般用于超连接，设置访问前、鼠标悬停，访问后的样式
	<a href="http://www.baidu.com">百度</a>
	另一个文件中定义样式
	a:link{text-decoration:none}	超链接访问前的样式(去除下划线)
	a:hover{} 鼠标停留是的样式
	a:visited{} 访问后的样式
一个元素可以有多个类：一个元素可以属于多个组，若相同属性，由样式表中class先后顺序决定
	<p class="important">重要</p>
	<p class="warning">警告</p>
	<p class="important warning">及重要合警告</p>
	另一个文件中定义样式（有相同属性，跟最后一个属性）
	.important {
		font-weight: bold;
		color:red
	}
	.warning {
		color:blue
	}
	
	p .blue{}  在p元素中，属于blue类的内容<p>xxx<span class="blue">yyy</span></p>
	p.blue{}  p标记，它的class是blue才生效<p class="blue">xxx</p>
	
颜色：
1、单词
2、rgb颜色：rgb(10进制数)  red/green/blue
每种颜色都采用0-255之间的一个数字，值越大，表示这个颜色越亮，值小表示暗
如果三种颜色明暗程度一样，就是灰色
3、rgb颜色：#16进制

盒子模型	
padding: 10px;      内边距
margin: 20px;       外边距(0 auto自动居中)
border: 5px solid black;    边框
float: left/right		向左/右覆盖，用于多行居中
margin-left:400px		向左移动400px

bootstrap:    http://www.bootcss.com/
twitter公司的开源前端框架，可以简单理解为它就是一个大样式表
将前一个班的样式表文件复制过来
# cp -r ../../../nsd1808/devweb/day03/static/ .
# tree static/
static/
├── css    # 样式表文件目录
│   ├── bootstrap.css
│   ├── bootstrap.css.map
│   ├── bootstrap.min.css
│   ├── bootstrap.min.css.map
│   ├── bootstrap-theme.css
│   ├── bootstrap-theme.css.map
│   ├── bootstrap-theme.min.css
│   └── bootstrap-theme.min.css.map
├── fonts   # 字体文件目录
│   ├── CabinSketch-Bold.ttf
│   ├── glyphicons-halflings-regular.eot
│   ├── glyphicons-halflings-regular.svg
│   ├── glyphicons-halflings-regular.ttf
│   ├── glyphicons-halflings-regular.woff
│   └── glyphicons-halflings-regular.woff2
├── imgs    # 图片目录
│   ├── banner.jpg
│   ├── first.jpg
│   ├── heart.jpeg
│   ├── html_css.jpeg
│   ├── linux.jpg
│   ├── second.jpg
│   └── third.jpg
└── js      # javascript目录
    ├── bootstrap.js
    ├── bootstrap.min.js
    ├── jquery.min.js
    └── npm.js
####################################################################

Day04
django: 是一个web框架，用于编写网站程序
MTV模式：
M: Model模型 对应数据库
T: Template模板 对应html页面
V: View视图 对应相关的函数

URLConf: 路由系统 => 将URL和相应的函数关联

python虚拟环境：创建一个文件夹，将python环境限制到这个文件夹中，安装模块等
都是安装到了这个文件夹。
1、创建虚拟环境
[root@room8pc16 day04]# python3 -m venv /opt/djenv
2、激活虚拟环境
[root@room8pc16 day04]# source /opt/djenv/bin/activate
3、现在的虚拟环境，运行python，默认就是python3
4、在虚拟环境中，安装django
(djenv) [root@room8pc16 zzg_pypkgs]# cd dj_pkgs/
(djenv) [root@room8pc16 dj_pkgs]# pip install *
(djenv) [root@room8pc16 dj_pkgs]# python
>>> import django
>>> django.__version__
'1.11.6'


django项目可以分成很多小的应用，每个小的应用由一或几个人负责。
也就是说django项目是由多个应用构成的。
1、创建项目
(djenv) [root@room8pc16 day04]# django-admin startproject mysite
(djenv) [root@room8pc16 day04]# tree mysite/
mysite/
├── manage.py         # 管理项目的脚本文件
└── mysite
    ├── __init__.py   # 使目录成为包
    ├── settings.py   # 项目配置文件
    ├── urls.py       # 路由系统文件，程序入口
    └── wsgi.py       # 部署django项目时需要的文件

1 directory, 5 files
2、pycharm配置
(1) 将解释器改为虚拟环境的解释器
File -> Settings -> Project -> Project Interpreter ->点击右侧的齿轮图
标 -> Add Local -> Existing Environment(把Make available to all
projects 勾选) -> 点击三个图标 -> /opt/djenv/bin/python
(2) 设置django的根路径
File -> Settings -> Languages & Frameworks -> Django -> 启用支持，在
根目录部分填入外层mysite，再选择settings.py的位置(mysite/settings)

3、启动django虚拟服务器
django内建了一个web服务器系统，可以展示django项目。
(djenv) [root@room8pc16 mysite]# python manage.py runserver
访问http://127.0.0.1:8000/
4、配置django
# mysite/settings.py
ALLOWED_HOSTS = '*'   # 允许所有的客户端访问
MIDDLEWARE = [
    ... ...
    # 'django.middleware.csrf.CsrfViewMiddleware',  # 关闭安全选项
    ... ...
]
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',   # 采用mysql数据库
        'NAME': 'dj1809',
        'USER': 'root',
        'PASSWORD': 'tedu.cn',
        'HOST': '127.0.0.1',
        'PORT': '3306',
    }
}
LANGUAGE_CODE = 'zh-hans'     # 改为中文语言
TIME_ZONE = 'Asia/Shanghai'   # 时区
USE_TZ = False
5、配置数据库
(djenv) [root@room8pc16 dj_pkgs]# mysql -uroot -ptedu.cn
MariaDB [(none)]> CREATE DATABASE dj1809 DEFAULT CHARSET utf8;
6、安装pymysql模块
(djenv) [root@room8pc16 zzg_pypkgs]# cd pymysql_pkgs/
(djenv) [root@room8pc16 pymysql_pkgs]# pip install *
(python2连接mysql的模块是MySQLdb，但是python3没有，取而代之的是pymysql，
但是django仍然寻找MySQLdb模块，需要写入以下代码，使pymysql像MySQLdb一样工作)
# vim mysite/__init__.py
import pymysql

pymysql.install_as_MySQLdb()
7、启动测试服务器，运行在0.0.0.0的80端口
(djenv) [root@room8pc16 mysite]# python manage.py runserver 0:80

8、生成django默认的数据库表
(djenv) [root@room8pc16 mysite]# python manage.py makemigrations	#检查
(djenv) [root@room8pc16 mysite]# python manage.py migrate		#生成数据库表
9、创建超级用户
(djenv) [root@room8pc16 mysite]# python manage.py createsuperuser	
10、后台管理界面：http://127.0.0.1/admin

建站流程：
1、UI设计师设计页面风格（配色、文字）
2、WEB前端设计师将UI设计师的图片变成WEB页面
3、后台程序员编写网站后台程序
4、做好的网站交给运维部门，放到web服务器上，对外提供服务

创建应用：
1、一个项目（如博客网站）可以由多个应用（发布文章、留言、投票）构成
2、创建投票应用
(djenv) [root@room8pc16 mysite]# python manage.py startapp polls
3、将应用绑定到项目中
# mysite/settings.py
INSTALLED_APPS = [
    ... ...
    'polls',
]
4、投票规划
(1) http://127.0.0.1/polls/   投票首页：列出所有的投票题目
(2) http://127.0.0.1/polls/1/   1号投票题目的详情
(3) http://127.0.0.1/polls/1/result/     1号投票题目的结果
5、应用授权
一个项目中有很多的应用，每个应用又拥有很多个URL。如果将每个URL对应的函数声明
都写到项目的urls.py中，这个文件将会变得非常大，不易于管理。我们可以将每个应用
的URL授权给该应用自行处理。
# mysite/urls.py
from django.conf.urls import url, include
from django.contrib import admin

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^polls/', include('polls.urls')),
]
说明：^polls/是正则表示式，从http://127.0.0.1/后面开始匹配
# vim polls/urls.py
from django.conf.urls import url

urlpatterns = [
]
6、创建投票首页
(1) url: 应用匹配URL的时候，从http://127.0.0.1/polls/后面开始匹配
# polls/urls.py
from django.conf.urls import url
from . import views

urlpatterns = [
    url(r'^$', views.index, name='index'),
]
说明：from . import views是相对导入，表示在当前目录中导入views模块
^$匹配空字符串，这个路径用views模块中的index函数去处理。name='index'是
给http://127.0.0.1/polls/起个名，叫index
(2) 编写视图函数
from django.shortcuts import render

def index(request):
    return render(request, 'index.html')
说明：函数index需要有一个参数，用户发来的请求会传递给这个参数。函数将会把
index.html返回给用户
(3) 创建模板文件index.html
(djenv) [root@room8pc16 mysite]# mkdir polls/templates
# polls/templates/index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>投票首页</title>
</head>
<body>
<h1>投票首页</h1>
</body>
</html>
(4) 访问http://127.0.0.1/polls/将会看到index.html内容

7、创建投票详情页
(1) url
# polls/urls.py
    # url(r'^\d+/$', views.detail, name='detail'),
    url(r'^(?P<question_id>\d+)/$', views.detail, name='detail'),
说明：\d+匹配数字，然后把这个数字保存到question_id变量中，传递给detail函数
(2) 视图函数
# polls/views.py
def detail(request, question_id):
    return render(request, 'detail.html', {'question_id': question_id})
说明：字典{'question_id': question_id}的key将作为变量传给detail.html
模板，它的值是question_id的值。如http://127.0.0.1/1/，将会把1赋值给
question_id，前端模板拿到的值就是{'question_id': 1}
(3) 模板
# polls/templates/detail.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>投票详情</title>
</head>
<body>
<h1>{{ question_id }}号问题投票详情</h1>
</body>
</html>
(4) 访问http://127.0.0.1/polls/数字/

https://yiyibooks.cn/		#中文python文档
https://yiyibooks.cn/xx/Django_1.11.6/intro/tutorial01.html

1.创建结果页
(1) urls.py
# polls/urls.py
    url(r'(?P<question_id>\d+)/result/$', views.result, name='result'),
(2) 函数
# polls/views.py
def result(request, question_id):
    return render(request, 'result.html', {'question_id': question_id})
(3) 模板
# polls/templates/result.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>投票结果页</title>
</head>
<body>
<h1>{{ question_id }}号问题的投票结果</h1>
</body>
</html>


编写模型
1、投票应用需要的表
(1) 问题表：id/问题/发布时间
(2) 选项表：id/选项/问题id/票数
2、编写模型
# polls/models.py
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200, unique=True, null=False)
    pub_date = models.DateTimeField()

    def __str__(self):
        return self.question_text

class Choice(models.Model):
    choice_text = models.CharField(max_length=100)
    votes = models.IntegerField()
    q = models.ForeignKey(Question)

    def __str__(self):
        return "%s=>%s: %s" % (self.q, self.choice_text, self.votes)
3、生成数据库的表
(djenv) [root@room8pc16 mysite]# python manage.py makemigrations
(djenv) [root@room8pc16 mysite]# python manage.py migrate
4、分析表结构
[root@room8pc16 mysite]# mysql -uroot -ptedu.cn
MariaDB [(none)]> use dj1809;
MariaDB [dj1809]> show tables;
表名构成： polls_question/polls_choice => 应用名_类名
MariaDB [dj1809]> desc polls_question;
表中的字段：类变量。对于外键来说，需要给类变量加上_id。如选项表中的外键q，在
数据库表中的名称是q_id。另外，没有声明主键，将会自动创建一个名为id的主键。
5、修改表结构
将选项表的票数加上默认值，并且将表中的q_id改为question_id
class Choice(models.Model):
    choice_text = models.CharField(max_length=100)
    votes = models.IntegerField(default=0)
    question = models.ForeignKey(Question)

    def __str__(self):
        return "%s=>%s: %s" % (self.question, self.choice_text, self.votes)
(djenv) [root@room8pc16 mysite]# python manage.py makemigrations
(djenv) [root@room8pc16 mysite]# python manage.py migrate
在数据库中查看polls_choice的表结构。
MariaDB [dj1809]> desc polls_question;
6、将模型注册到后台
# polls/admin.py
from django.contrib import admin
from .models import Question, Choice

admin.site.register(Question)
admin.site.register(Choice)
说明：.models表示当前目录中的models模块


操作数据库
1、运行python shell(初始化django环境)
(djenv) [root@room8pc16 mysite]# python manage.py shell
2、导入问题
>>> from polls.models import Question
3、增加数据
(1) 创建实例的方式
>>> from django.utils import timezone   # 为了设置时间，导入时间工具
>>> q1 = Question(question_text='你心仪的公司是哪家？', pub_date=timezone.now())
>>> q1.save()
>>> q1.id
>>> q1.question_text
>>> q1.pub_date
(2) 通过类的管理器
django为每个class都创建了一个名为objects的管理器，可以通过这个管理器进行
增删改查
>>> q2 = Question.objects.create(question_text='散伙饭去哪吃？', pub_date=timezone.now())

4、为Choice增加数据
(1) 创建实例
>>> from polls.models import Choice
>>> c1 = Choice(choice_text='达内', question=q1)
>>> c1.save()
(2) 通过管理器
>>> c2 = Choice.objects.create(choice_text='阿里巴巴', question=q1)
(3) 通过问题反向创建选项
通过主外键约束，django自动为主键实例创建了一个名为“外键表_set”的管理器，通过
这个管理器，可以直接创建外键表的实例
>>> q1.choice_set.create(choice_text='小米')

5、修改数据，只要通过实例，对它的属性重新赋值即可
>>> q1.question_text = '你期待哪家公司给你发Offer？'
>>> q1.save()
6、删除记录
>>> q1.delete()   # 默认也会将相关的选项一起删掉

查询
1、查询所有的内容
>>> Question.objects.all()   # 返回所有问题实例组成的集合
>>> for q in Question.objects.all():   # 取出集合中的每个实例
...    print(q.question_text, q.pub_date)
2、排序
>>> Question.objects.order_by('pub_date')  # 返回所有问题实例组成的集合
>>> for q in Question.objects.order_by('pub_date'):
...     print(q.question_text, q.pub_date)
>>> for q in Question.objects.order_by('-pub_date'):  # 降序排列
...     print(q.question_text, q.pub_date)

3、取出某一个问题的实例
>>> q1 = Question.objects.get(id=1)
>>> q1.question_text
>>> q1.pub_date
注意：get必须返回1个实例，如果返回值多了或少了，都会发生错误
4、通过过滤方法获取问题实例组成的集合，该集合中可以有任意数目的实例(0到多)
>>> qset1 = Question.objects.filter(id=1)  # 集合中只有一个问题实例
>>> len(qset1)
>>> qset2 = Question.objects.filter(id__gt=1)
>>> len(qset2)
>>> qset3 = Question.objects.filter(id__lt=1)
>>> len(qset3)
>>> for q in qset2:
...     print(q.question_text, q.pub_date)

5、过滤数据
在django中，过滤条件采用双下划线表示属性。
id=1实际上是id__exact=1的简写
（1）数字
大于：id__gt=1
大于等于：id__gte=1
小于：id__lt=1
小于等于：id__lte=1
（2）字符串
字符串方法
>>> question_text = '从达内结业后，你希望去哪个城市工作？'
>>> question_text.startswith('从达内结业后')
在django的过滤中，也是用双下划线表示方法
>>> Question.objects.filter(question_text__startswith='从达内结业后')
>>> Question.objects.filter(question_text__endswith='Offer？')
(3) 时间
>>> t1 = timezone.now()
>>> t1.year
>>> t1.month
>>> t1.month == 3
>>> t1.year >= 2019
>>> Question.objects.filter(pub_date__year=2019)
>>> Question.objects.filter(pub_date__year__gte=2019)
>>> Question.objects.filter(pub_date__month=3)

修改投票首页
1、修改视图函数
# polls/views.py
from django.shortcuts import render
from .models import Question

def index(request):
    questions = Question.objects.order_by('-pub_date')
    return render(request, 'index.html', {'questions': questions})
2、修改模板文件
# polls/templates/index.html
<body>
<h1>投票首页</h1>
{{ questions }}
</body>
3、在模板中使用循环
# polls/templates/index.html
<body>
<h1>投票首页</h1>
<ol>
    {% for question in questions %}
        <li>{{ question.question_text }} {{ question.pub_date }}</li>
    {% endfor %}
</ol>
</body>
4、为投票内容加入超链接
<body>
<h1>投票首页</h1>
<ol>
    {% for question in questions %}
        <li>
{#            <a href="/polls/{{ question.id }}/" target="_blank">#}
            <a href="{% url 'detail' question_id=question.id %}" target="_blank">
                {{ question.question_text }}
            </a>
            {{ question.pub_date }}
        </li>
    {% endfor %}
</ol>
</body>

修改投票详情首页
1、修改视图函数
def detail(request, question_id):
    question = Question.objects.get(id=question_id)
    return render(request, 'detail.html', {'question': question})
2、修改模板
(1) 通过问题获取选项
>>> q1 = Question.objects.get(id=1)
>>> q1.choice_set.all()   # 通过问题反向获取所有选项实例构成的集合
(2) 修改模板
# detail.html
<body>
<h1>{{ question.id }}号问题投票详情</h1>
<h2>{{ question.question_text }}</h2>
<ol>
    {% for choice in question.choice_set.all %}
        <li>{{ choice.choice_text }}</li>
    {% endfor %}
</ol>
</body>
(3) 在模板中使用判断，如果有选项列出选项，没有选项显示尚无选项
<body>
<h1>{{ question.id }}号问题投票详情</h1>
<h2>{{ question.question_text }}</h2>
{% if question.choice_set.all %}   {% comment %}如果选项集不是空的{% endcomment %}
    <ol>
        {% for choice in question.choice_set.all %}
            <li>{{ choice.choice_text }}</li>
        {% endfor %}
    </ol>
{% else %}
    <h3>尚无选项</h3>
{% endif %}
</body>


django:
运行原理：MTV模式
客户端访问通过urlconf连接django-->view视图中寻找对应函数-->
Model对应的数据库中寻找数据-->将数据返回给template模块下的html页面--> 返回给客户端
一、初始化python虚拟环境
1、创建虚拟环境
2、激活虚拟环境
3、安装django

二、django项目部署
1、创建项目
2、若用pycharm，修改pycharm配置（解释器，项目位置），无则跳过
3、修改django的settings.py文件
4、配置真实数据库（需安装pymysql模块）
5、检查、生成数据库表
6、创建用户

三、django应用部署
1、创建应用
2、绑定应用到项目
3、在项目中为应用授权


四、部署一个投票应用
1、定义投票首页
2、定义视图函数
3、创建模版目录和文件
4、创建投票详情页同上

五、编写模型（投票应用的表格）
1、在模型中定义class类（类的变量就是表字段）
2、真机生成数据库表
3、将模型注册到后台，admin文件

六、数据库的基本操作
1、增删改查
2、过滤（数字、字符串、时间）

七、修改投票页
1、修改视图函数（定义模型中的信息）
2、修改html文件































DDoS攻击、CC攻击的攻击方式和防御方法
DDoS介绍

DDoS是英文Distributed Denial of Service的缩写，意即“分布式拒绝服务”，那么什么又是拒绝服务（Denial of Service）呢？可以这么理解，凡是能导致合法用户不能够访问正常网络服务的行为都算是拒绝服务攻击。也就是说拒绝服务攻击的目的非常明确，就是要阻止合法用户对正常网络资源的访问，从而达成攻击者不可告人的目的。分布式拒绝服务攻击一旦被实施，攻击网络包就会从很多DOS攻击源(俗称肉鸡)犹如洪水般涌向受害主机，从而把合法用户的网络包淹没，导致合法用户无法正常访问服务器的网络资源，因此，拒绝服务攻击又被称之为“洪水式攻击”，常见的DDOS攻击手段有SYN Flood、ACK Flood、UDP Flood、ICMP Flood、TCP Flood、Connections Flood、Script Flood、Proxy Flood等。

目前而言，黑客甚至对攻击进行明码标价，打1G的流量到一个网站一小时，只需50块钱。DDoS的成本如此之低，而且攻击了也没人管。

 
关于DDos攻击的常见方法

1. SYN Flood：利用TCP协议的原理，这种攻击方法是经典最有效的DDOS方法，可通杀各种系统的网络服务，主要是通过向受害主机发送大量伪造源IP和源端口的SYN或ACK 包，导致主机的缓存资源被耗尽或忙于发送回应包而造成拒绝服务。TCP通道在建立以前，需要三次握手：
a. 客户端发送一个包含SYN标志的TCP报文， 同步报文指明客户端所需要的端口号和TCP连接的初始序列号
b. 服务器收到SYN报文之后，返回一个SYN+ ACK报文，表示客户端请求被接受，TCP初始序列号加1
c.客户端也返回一个确认报文ACK给服务器，同样TCP序列号加1
d. 如果服务器端没有收到客户端的确认报文ACK，则处于等待状态，将该客户IP加入等待队列，然后轮训发送SYN+ACK报文
所以攻击者可以通过伪造大量的TCP握手请求，耗尽服务器端的资源。

2. HTTP Flood：针对系统的每个Web页面，或者资源，或者Rest API，用大量肉鸡，发送大量http request。这种攻击主要是针对存在ASP、JSP、PHP、CGI等脚本程序，并调用MSSQLServer、MySQLServer、Oracle等数据库的网站系统而设计的，特征是和服务器建立正常的TCP连接，并不断的向脚本程序提交查询、列表等大量耗费数据库资源的调用，典型的以小博大的攻击方法。缺点是对付只有静态页面的网站效果会大打折扣。

3. 慢速攻击：Http协议中规定，HttpRequest以\r\n\r\n结尾来表示客户端发送结束。攻击者打开一个Http 1.1的连接，将Connection设置为Keep-Alive， 保持和服务器的TCP长连接。然后始终不发送\r\n\r\n， 每隔几分钟写入一些无意义的数据流， 拖死机器。

4. P2P攻击：每当网络上出现一个热门事件，比如XX门， 精心制作一个种子， 里面包含正确的文件下载， 同时也包括攻击目标服务器的IP。这样，当很多人下载的时候， 会无意中发起对目标服务器的TCP连接。

 
DDOS攻击现象判定方法

1.SYN类攻击判断：A.CPU占用很高；B.网络连接状态：netstat –na,若观察到大量的SYN_RECEIVED的连接状态；C.网线插上后，服务器立即凝固无法操作，拔出后有时可以恢复，有时候需要重新启动机器才可恢复。
2.CC类攻击判断：A.网站出现service unavailable提示；B.CPU占用率很高；C.网络连接状态：netstat –na,若观察到大量的ESTABLISHED的连接状态 单个IP高达几十条甚至上百条；D.用户无法访问网站页面或打开过程非常缓慢,软重启后短期内恢复正常,几分钟后又无法访问。
3.UDP类攻击判断：A.观察网卡状况 每秒接受大量的数据包；B.网络状态：netstat –na TCP信息正常。
4.TCP洪水攻击判断：A.CPU占用很高；B.netstat –na,若观察到大量的ESTABLISHED的连接状态 单个IP高达几十条甚至上百条

 
DDoS攻击防御方法：

1. 过滤不必要的服务和端口：可以使用Inexpress、Express、Forwarding等工具来过滤不必要的服务和端口，即在路由器上过滤假IP。比如Cisco公司的CEF(Cisco Express Forwarding)可以针对封包Source IP和Routing Table做比较，并加以过滤。只开放服务端口成为目前很多服务器的流行做法，例如WWW服务器那么只开放80而将其他所有端口关闭或在防火墙上做阻止策略。
2. 异常流量的清洗过滤：通过DDOS硬件防火墙对异常流量的清洗过滤，通过数据包的规则过滤、数据流指纹检测过滤、及数据包内容定制过滤等顶尖技术能准确判断外来访问流量是否正常，进一步将异常流量禁止过滤。单台负载每秒可防御800-927万个syn攻击包。
3. 分布式集群防御：这是目前网络安全界防御大规模DDOS攻击的最有效办法。分布式集群防御的特点是在每个节点服务器配置多个IP地址（负载均衡），并且每个节点能承受不低于10G的DDOS攻击，如一个节点受攻击无法提供服务，系统将会根据优先级设置自动切换另一个节点，并将攻击者的数据包全部返回发送点，使攻击源成为瘫痪状态，从更为深度的安全防护角度去影响企业的安全执行决策。
4. 高防智能DNS解析：高智能DNS解析系统与DDOS防御系统的完美结合，为企业提供对抗新兴安全威胁的超级检测功能。它颠覆了传统一个域名对应一个镜像的做法，智能根据用户的上网路线将DNS解析请求解析到用户所属网络的服务器。同时智能DNS解析系统还有宕机检测功能，随时可将瘫痪的服务器IP智能更换成正常服务器IP，为企业的网络保持一个永不宕机的服务状态。

DDoS攻击的网络流量清洗

当发生DDOS攻击时，网络监控系统会侦测到网络流量的异常变化并发出报警。在系统自动检测或人工判断之后，可以识别出被攻击的虚拟机公网IP地址。这时，可调用系统的防DDOS攻击功能接口，启动对相关被攻击IP的流量清洗。流量清洗设备会立即接管对该IP地址的所有数据包，并将攻击数据包清洗掉，仅将正常的数据包转发给随后的网络设备。这样，就能保证整个网络正常的流量通行，而将DDOS流量拒之门外。
采用云DDoS清洗方式，可以为企业用户带来诸多好处。其表现在不仅可以提升综合防护能力，用户能够按需付费，可弹性扩展，而且还能够基于大数据来分析预测攻击，同时能够免费升级。对于企业用户来说，则可实现零运维、零改造。

 
CC攻击介绍

CC攻击（Challenge Collapsar）是DDOS（分布式拒绝服务）的一种，前身名为Fatboy攻击，也是一种常见的网站攻击方法。攻击者通过代理服务器或者肉鸡向向受害主机不停地发大量数据包，造成对方服务器资源耗尽，一直到宕机崩溃。相比其它的DDOS攻击CC似乎更有技术含量一些。这种攻击你见不到真实源IP，见不到特别大的异常流量，但造成服务器无法进行正常连接。最让站长们忧虑的是这种攻击技术含量低，利用更换IP代理工具和一些IP代理一个初、中级的电脑水平的用户就能够实施攻击。

 
CC攻击防御方法

1. 利用Session做访问计数器：利用Session针对每个IP做页面访问计数器或文件下载计数器，防止用户对某个页面频繁刷新导致数据库频繁读取或频繁下载某个文件而产生大额流量。（文件下载不要直接使用下载地址，才能在服务端代码中做CC攻击的过滤处理）
2. 把网站做成静态页面：大量事实证明，把网站尽可能做成静态页面，不仅能大大提高抗攻击能力，而且还给骇客入侵带来不少麻烦，至少到现在为止关于HTML的溢出还没出现，看看吧！新浪、搜狐、网易等门户网站主要都是静态页面，若你非需要动态脚本调用，那就把它弄到另外一台单独主机去，免的遭受攻击时连累主服务器。
3. 增强操作系统的TCP/IP栈
Win2000和Win2003作为服务器操作系统，本身就具备一定的抵抗DDOS攻击的能力，只是默认状态下没有开启而已，若开启的话可抵挡约10000个SYN攻击包，若没有开启则仅能抵御数百个，具体怎么开启，自己去看微软的文章吧！《强化 TCP/IP 堆栈安全》。也许有的人会问，那我用的是Linux和FreeBSD怎么办？很简单，按照这篇文章去做吧！《SYN Cookies》。
4. 在存在多站的服务器上，严格限制每一个站允许的IP连接数和CPU使用时间，这是一个很有效的方法。CC的防御要从代码做起，其实一个好的页面代码都应该注意这些东西，还有SQL注入，不光是一个入侵工具，更是一个DDOS缺口，大家都应该在代码中注意。举个例子吧，某服务器，开动了5000线的CC攻击，没有一点反应，因为它所有的访问数据库请求都必须一个随机参数在Session里面，全是静态页面，没有效果。突然发现它有一个请求会和外面的服务器联系获得，需要较长的时间，而且没有什么认证，开800线攻击，服务器马上满负荷了。代码层的防御需要从点点滴滴做起，一个脚本代码的错误，可能带来的是整个站的影响，甚至是整个服务器的影响!
5. 服务器前端加CDN中转(免费的有百度云加速、360网站卫士、加速乐、安全宝等)，如果资金充裕的话，可以购买高防的盾机，用于隐藏服务器真实IP，域名解析使用CDN的IP，所有解析的子域名都使用CDN的IP地址。此外，服务器上部署的其他域名也不能使用真实IP解析，全部都使用CDN来解析。
另外，防止服务器对外传送信息泄漏IP地址，最常见的情况是，服务器不要使用发送邮件功能，因为邮件头会泄漏服务器的IP地址。如果非要发送邮件，可以通过第三方代理(例如sendcloud)发送，这样对外显示的IP是代理的IP地址。
总之，只要服务器的真实IP不泄露，10G以下小流量DDOS的预防花不了多少钱，免费的CDN就可以应付得了。如果攻击流量超过20G，那么免费的CDN可能就顶不住了，需要购买一个高防的盾机来应付了，而服务器的真实IP同样需要隐藏






























